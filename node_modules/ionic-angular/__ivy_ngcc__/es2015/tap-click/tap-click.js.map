{"version":3,"file":"tap-click.js","sources":["tap-click.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;sGAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;4LAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Injectable } from '@angular/core';\nimport { Activator } from './activator';\nimport { App } from '../components/app/app';\nimport { Config } from '../config/config';\nimport { DomController } from '../platform/dom-controller';\nimport { GestureController } from '../gestures/gesture-controller';\nimport { Platform } from '../platform/platform';\nimport { hasPointerMoved, pointerCoord } from '../util/dom';\nimport { POINTER_EVENT_TYPE_TOUCH } from '../gestures/pointer-events';\nimport { RippleActivator } from './ripple';\nimport { UIEventManager } from '../gestures/ui-event-manager';\n/**\n * @hidden\n */\nexport class TapClick {\n    constructor(config, plt, dom, app, gestureCtrl) {\n        this.plt = plt;\n        this.app = app;\n        this.gestureCtrl = gestureCtrl;\n        this.disableClick = 0;\n        this.events = new UIEventManager(plt);\n        let activator = config.get('activator');\n        if (activator === 'ripple') {\n            this.activator = new RippleActivator(app, config, dom);\n        }\n        else if (activator === 'highlight') {\n            this.activator = new Activator(app, config, dom);\n        }\n        this.usePolyfill = config.getBoolean('tapPolyfill');\n        (void 0) /* console.debug */;\n        const doc = plt.doc();\n        this.events.listen(doc, 'click', this.click.bind(this), { passive: false, capture: true });\n        this.pointerEvents = this.events.pointerEvents({\n            element: doc,\n            pointerDown: this.pointerStart.bind(this),\n            pointerMove: this.pointerMove.bind(this),\n            pointerUp: this.pointerEnd.bind(this),\n            passive: true\n        });\n        this.pointerEvents.mouseWait = DISABLE_NATIVE_CLICK_AMOUNT;\n    }\n    pointerStart(ev) {\n        if (this.startCoord) {\n            return false;\n        }\n        if (!this.app.isEnabled()) {\n            return false;\n        }\n        this.lastTouchEnd = 0;\n        this.dispatchClick = true;\n        if (this.plt.doc() === ev.target) {\n            this.startCoord = pointerCoord(ev);\n            return true;\n        }\n        this.activatableEle = getActivatableTarget(ev.target);\n        if (!this.activatableEle) {\n            this.startCoord = null;\n            return false;\n        }\n        this.startCoord = pointerCoord(ev);\n        this.activator && this.activator.downAction(ev, this.activatableEle, this.startCoord);\n        return true;\n    }\n    pointerMove(ev) {\n        if (this.startCoord && this.shouldCancelEvent(ev)) {\n            this.pointerCancel(ev);\n        }\n    }\n    pointerEnd(ev, pointerEventType) {\n        if (!this.dispatchClick)\n            return;\n        (void 0) /* runInDev */;\n        if (!this.startCoord) {\n            return;\n        }\n        if (this.activator && ev.target !== this.plt.doc()) {\n            let activatableEle = getActivatableTarget(ev.target) || this.activatableEle;\n            if (activatableEle) {\n                this.activator.upAction(ev, activatableEle, this.startCoord);\n            }\n        }\n        if (this.usePolyfill && pointerEventType === POINTER_EVENT_TYPE_TOUCH && this.app.isEnabled()) {\n            this.handleTapPolyfill(ev);\n        }\n        this.startCoord = null;\n        this.activatableEle = null;\n    }\n    pointerCancel(ev) {\n        (void 0) /* console.debug */;\n        this.startCoord = null;\n        this.activatableEle = null;\n        this.dispatchClick = false;\n        this.activator && this.activator.clearState(false);\n        this.pointerEvents.stop();\n    }\n    shouldCancelEvent(ev) {\n        return (this.app.isScrolling() ||\n            this.gestureCtrl.isCaptured() ||\n            hasPointerMoved(POINTER_TOLERANCE, this.startCoord, pointerCoord(ev)));\n    }\n    click(ev) {\n        if (this.shouldCancelClick(ev)) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            return;\n        }\n        if (this.activator && this.plt.doc() !== ev.target) {\n            // cool, a click is gonna happen, let's tell the activator\n            // so the element can get the given \"active\" style\n            const activatableEle = getActivatableTarget(ev.target);\n            if (activatableEle) {\n                this.activator.clickAction(ev, activatableEle, this.startCoord);\n            }\n        }\n        (void 0) /* runInDev */;\n    }\n    shouldCancelClick(ev) {\n        if (this.usePolyfill) {\n            if (!ev.isIonicTap && this.isDisabledNativeClick()) {\n                (void 0) /* console.debug */;\n                return true;\n            }\n        }\n        else if (!this.dispatchClick) {\n            (void 0) /* console.debug */;\n            return true;\n        }\n        if (!this.app.isEnabled()) {\n            (void 0) /* console.debug */;\n            return true;\n        }\n        if (this.gestureCtrl.isCaptured()) {\n            (void 0) /* console.debug */;\n            return true;\n        }\n        return false;\n    }\n    profileClickDelay(ev) {\n        if (this.lastTouchEnd) {\n            let diff = Date.now() - this.lastTouchEnd;\n            if (diff < 100) {\n                (void 0) /* console.debug */;\n            }\n            else {\n                console.warn(`SLOW click dispatched. Delay(ms):`, diff, ev);\n            }\n            this.lastTouchEnd = null;\n        }\n        else {\n            (void 0) /* console.debug */;\n        }\n    }\n    handleTapPolyfill(ev) {\n        (void 0) /* assert */;\n        // only dispatch mouse click events from a touchend event\n        // when tapPolyfill config is true, and the startCoordand endCoord\n        // are not too far off from each other\n        let endCoord = pointerCoord(ev);\n        if (hasPointerMoved(POINTER_TOLERANCE, this.startCoord, endCoord)) {\n            (void 0) /* console.debug */;\n            return;\n        }\n        // prevent native mouse click events for XX amount of time\n        this.disableClick = Date.now() + DISABLE_NATIVE_CLICK_AMOUNT;\n        if (this.app.isScrolling()) {\n            // do not fire off a click event while the app was scrolling\n            (void 0) /* console.debug */;\n        }\n        else {\n            // dispatch a mouse click event\n            (void 0) /* console.debug */;\n            let clickEvent = this.plt.doc().createEvent('MouseEvents');\n            clickEvent.initMouseEvent('click', true, true, this.plt.win(), 1, 0, 0, endCoord.x, endCoord.y, false, false, false, false, 0, null);\n            clickEvent.isIonicTap = true;\n            ev.target.dispatchEvent(clickEvent);\n        }\n    }\n    isDisabledNativeClick() {\n        return this.disableClick > Date.now();\n    }\n}\nTapClick.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nTapClick.ctorParameters = () => [\n    { type: Config, },\n    { type: Platform, },\n    { type: DomController, },\n    { type: App, },\n    { type: GestureController, },\n];\nfunction getActivatableTarget(ele) {\n    let targetEle = ele;\n    for (let x = 0; x < 10; x++) {\n        if (!targetEle)\n            break;\n        if (isActivatable(targetEle)) {\n            return targetEle;\n        }\n        targetEle = targetEle.parentElement;\n    }\n    return null;\n}\n/**\n * @hidden\n */\nexport function isActivatable(ele) {\n    if (ACTIVATABLE_ELEMENTS.indexOf(ele.tagName) > -1) {\n        return true;\n    }\n    for (let i = 0, l = ACTIVATABLE_ATTRIBUTES.length; i < l; i++) {\n        if (ele.hasAttribute && ele.hasAttribute(ACTIVATABLE_ATTRIBUTES[i])) {\n            return true;\n        }\n    }\n    return false;\n}\nconst ACTIVATABLE_ELEMENTS = ['A', 'BUTTON'];\nconst ACTIVATABLE_ATTRIBUTES = ['tappable', 'ion-button'];\nconst POINTER_TOLERANCE = 100;\nconst DISABLE_NATIVE_CLICK_AMOUNT = 2500;\n/**\n * @hidden\n */\nexport function setupTapClick(config, plt, dom, app, gestureCtrl) {\n    return function () {\n        return new TapClick(config, plt, dom, app, gestureCtrl);\n    };\n}\n"]}