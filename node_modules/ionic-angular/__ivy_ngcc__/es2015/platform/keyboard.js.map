{"version":3,"file":"keyboard.js","sources":["keyboard.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;sGAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;;2JAAE;AACF;AACA;AACA","sourcesContent":["import { EventEmitter, Injectable, NgZone } from '@angular/core';\nimport { Config } from '../config/config';\nimport { DomController } from './dom-controller';\nimport { isTextInput } from '../util/dom';\nimport { KEY_TAB } from './key';\nimport { Platform } from './platform';\n/**\n * @name Keyboard\n * @description\n * The `Keyboard` class allows you to work with the keyboard events provided\n * by the Ionic keyboard plugin.\n *\n * @usage\n * ```ts\n * export class MyClass {\n *\n *   constructor(public keyboard: Keyboard) { }\n *\n * }\n * ```\n */\nexport class Keyboard {\n    constructor(config, _plt, _zone, _dom) {\n        this._plt = _plt;\n        this._zone = _zone;\n        this._dom = _dom;\n        this.willShow = new EventEmitter();\n        this.willHide = new EventEmitter();\n        this.didShow = new EventEmitter();\n        this.didHide = new EventEmitter();\n        this.eventsAvailable = false;\n        this.focusOutline(config.get('focusOutline'));\n        const win = _plt.win();\n        if (win.Ionic && win.Ionic.keyboardPlugin) {\n            this.listenV2(win);\n        }\n        else {\n            this.listenV1(win);\n        }\n    }\n    listenV2(win) {\n        const platform = this._plt;\n        platform.registerListener(win, 'keyboardWillShow', (ev) => {\n            this._zone.run(() => {\n                this.willShow.emit(ev.keyboardHeight);\n            });\n        }, { zone: false, passive: true });\n        platform.registerListener(win, 'keyboardWillHide', () => {\n            this._zone.run(() => {\n                this.willHide.emit();\n            });\n        }, { zone: false, passive: true });\n        platform.registerListener(win, 'keyboardDidShow', (ev) => {\n            this._zone.run(() => {\n                this.didShow.emit(ev.keyboardHeight);\n            });\n        }, { zone: false, passive: true });\n        platform.registerListener(win, 'keyboardDidHide', () => {\n            this._zone.run(() => {\n                this.didHide.emit();\n            });\n        }, { zone: false, passive: true });\n        this.eventsAvailable = true;\n    }\n    listenV1(win) {\n        const platform = this._plt;\n        platform.registerListener(win, 'native.keyboardhide', () => {\n            this.blurActiveInput(true);\n        }, { zone: false, passive: true });\n        platform.registerListener(win, 'native.keyboardshow', () => {\n            this.blurActiveInput(false);\n        }, { zone: false, passive: true });\n    }\n    blurActiveInput(shouldBlur) {\n        const platform = this._plt;\n        platform.cancelTimeout(this._tmr);\n        if (shouldBlur) {\n            this._tmr = platform.timeout(() => {\n                // this custom cordova plugin event fires when the keyboard will hide\n                // useful when the virtual keyboard is closed natively\n                // https://github.com/ionic-team/ionic-plugin-keyboard\n                if (this.isOpen()) {\n                    platform.focusOutActiveElement();\n                }\n            }, 80);\n        }\n    }\n    /**\n     * Check to see if the keyboard is open or not.\n     *\n     * ```ts\n     * export class MyClass {\n     *   constructor(public keyboard: Keyboard) {\n     *\n     *   }\n     *\n     *   keyboardCheck() {\n     *     console.log('The keyboard is open:', this.keyboard.isOpen());\n     *   }\n     * }\n     * ```\n     *\n     * @return {boolean} returns a true or false value if the keyboard is open or not.\n     */\n    isOpen() {\n        return this.hasFocusedTextInput();\n    }\n    /**\n     * When the keyboard is closed, call any methods you want.\n     *\n     * ```ts\n     * export class MyClass {\n     *   constructor(public keyboard: Keyboard) {\n     *     this.keyboard.onClose(this.closeCallback);\n     *   }\n     *   closeCallback() {\n     *     // call what ever functionality you want on keyboard close\n     *     console.log('Closing time');\n     *   }\n     * }\n     * ```\n     *\n     * @param {function} callback method you want to call when the keyboard has been closed.\n     * @return {function} returns a callback that gets fired when the keyboard is closed.\n     */\n    onClose(callback, pollingInternval = KEYBOARD_CLOSE_POLLING, pollingChecksMax = KEYBOARD_POLLING_CHECKS_MAX) {\n        (void 0) /* console.debug */;\n        const self = this;\n        let checks = 0;\n        let promise = null;\n        if (!callback) {\n            // a callback wasn't provided, so let's return a promise instead\n            promise = new Promise(resolve => { callback = resolve; });\n        }\n        function checkKeyboard() {\n            (void 0) /* console.debug */;\n            if (!self.isOpen() || checks > pollingChecksMax) {\n                self._plt.timeout(function () {\n                    self._zone.run(function () {\n                        (void 0) /* console.debug */;\n                        callback();\n                    });\n                }, 400);\n            }\n            else {\n                self._plt.timeout(checkKeyboard, pollingInternval);\n            }\n            checks++;\n        }\n        self._plt.timeout(checkKeyboard, pollingInternval);\n        return promise;\n    }\n    /**\n     * Programmatically close the keyboard.\n     */\n    close() {\n        this._dom.read(() => {\n            if (this.isOpen()) {\n                // only focus out when a text input has focus\n                (void 0) /* console.debug */;\n                this._dom.write(() => {\n                    this._plt.focusOutActiveElement();\n                });\n            }\n        });\n    }\n    /**\n     * @hidden\n     */\n    focusOutline(setting) {\n        /* Focus Outline\n         * --------------------------------------------------\n         * By default, when a keydown event happens from a tab key, then\n         * the 'focus-outline' css class is added to the body element\n         * so focusable elements have an outline. On a mousedown or\n         * touchstart event, then the 'focus-outline' css class is removed.\n         *\n         * Config default overrides:\n         * focusOutline: true     - Always add the focus-outline\n         * focusOutline: false    - Do not add the focus-outline\n         */\n        const self = this;\n        const platform = self._plt;\n        const doc = platform.doc();\n        let isKeyInputEnabled = false;\n        let unRegMouse;\n        let unRegTouch;\n        const evOpts = { passive: true, zone: false };\n        function cssClass() {\n            self._dom.write(() => {\n                platform.doc().body.classList[isKeyInputEnabled ? 'add' : 'remove']('focus-outline');\n            });\n        }\n        if (setting === true) {\n            isKeyInputEnabled = true;\n            return cssClass();\n        }\n        else if (setting === false) {\n            return;\n        }\n        // default is to add the focus-outline when the tab key is used\n        function keyDown(ev) {\n            if (!isKeyInputEnabled && ev.keyCode === KEY_TAB) {\n                isKeyInputEnabled = true;\n                enableKeyInput();\n            }\n        }\n        function pointerDown() {\n            isKeyInputEnabled = false;\n            enableKeyInput();\n        }\n        function enableKeyInput() {\n            cssClass();\n            unRegMouse && unRegMouse();\n            unRegTouch && unRegTouch();\n            if (isKeyInputEnabled) {\n                // listen for when a mousedown or touchstart event happens\n                unRegMouse = platform.registerListener(doc, 'mousedown', pointerDown, evOpts);\n                unRegTouch = platform.registerListener(doc, 'touchstart', pointerDown, evOpts);\n            }\n        }\n        // always listen for tab keydown events\n        platform.registerListener(platform.doc(), 'keydown', keyDown, evOpts);\n    }\n    hasFocusedTextInput() {\n        const activeEle = this._plt.getActiveElement();\n        if (isTextInput(activeEle)) {\n            return (activeEle.parentElement.querySelector(':focus') === activeEle);\n        }\n        return false;\n    }\n    /**\n     * Set to true to hide the additional toolbar that is on top of the keyboard.\n     * This toolbar features the Prev, Next, and Done buttons.\n     * @param hidden\n     */\n    hideFormAccessoryBar(hidden) {\n        const win = this._plt.win();\n        if (win && win.Keyboard && win.Keyboard.hideFormAccessoryBar) {\n            win.Keyboard.hideFormAccessoryBar(hidden);\n        }\n    }\n}\nKeyboard.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nKeyboard.ctorParameters = () => [\n    { type: Config, },\n    { type: Platform, },\n    { type: NgZone, },\n    { type: DomController, },\n];\nconst KEYBOARD_CLOSE_POLLING = 150;\nconst KEYBOARD_POLLING_CHECKS_MAX = 100;\n"]}