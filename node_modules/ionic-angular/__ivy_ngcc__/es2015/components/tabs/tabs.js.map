{"version":3,"file":"tabs.js","sources":["tabs.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;qGAaE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA","sourcesContent":["import { Component, ElementRef, EventEmitter, Input, Optional, Output, Renderer, ViewChild, ViewContainerRef, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/add/operator/takeUntil';\nimport { App } from '../app/app';\nimport { Config } from '../../config/config';\nimport { DeepLinker } from '../../navigation/deep-linker';\nimport { Ion } from '../ion';\nimport { isBlank, isPresent } from '../../util/util';\nimport { Keyboard } from '../../platform/keyboard';\nimport { NavController } from '../../navigation/nav-controller';\nimport { DIRECTION_SWITCH, getComponent } from '../../navigation/nav-util';\nimport { formatUrlPart } from '../../navigation/url-serializer';\nimport { RootNode } from '../split-pane/split-pane';\nimport { Platform } from '../../platform/platform';\nimport { TabHighlight } from './tab-highlight';\nimport { ViewController } from '../../navigation/view-controller';\n/**\n * @name Tabs\n * @description\n * Tabs make it easy to navigate between different pages or functional\n * aspects of an app. The Tabs component, written as `<ion-tabs>`, is\n * a container of individual [Tab](../Tab/) components. Each individual `ion-tab`\n * is a declarative component for a [NavController](../../../navigation/NavController/)\n *\n * For more information on using nav controllers like Tab or [Nav](../../nav/Nav/),\n * take a look at the [NavController API Docs](../../../navigation/NavController/).\n *\n * ### Placement\n *\n * The position of the tabs relative to the content varies based on\n * the mode. The tabs are placed at the bottom of the screen\n * for iOS and Android, and at the top for Windows by default. The position can\n * be configured using the `tabsPlacement` attribute on the `<ion-tabs>` component,\n * or in an app's [config](../../config/Config/).\n * See the [Input Properties](#input-properties) below for the available\n * values of `tabsPlacement`.\n *\n * ### Layout\n *\n * The layout for all of the tabs can be defined using the `tabsLayout`\n * property. If the individual tab has a title and icon, the icons will\n * show on top of the title by default. All tabs can be changed by setting\n * the value of `tabsLayout` on the `<ion-tabs>` element, or in your\n * app's [config](../../config/Config/). For example, this is useful if\n * you want to show tabs with a title only on Android, but show icons\n * and a title for iOS. See the [Input Properties](#input-properties)\n * below for the available values of `tabsLayout`.\n *\n * ### Selecting a Tab\n *\n * There are different ways you can select a specific tab from the tabs\n * component. You can use the `selectedIndex` property to set the index\n * on the `<ion-tabs>` element, or you can call `select()` from the `Tabs`\n * instance after creation. See [usage](#usage) below for more information.\n *\n * @usage\n *\n * You can add a basic tabs template to a `@Component` using the following\n * template:\n *\n * ```html\n * <ion-tabs>\n *   <ion-tab [root]=\"tab1Root\"></ion-tab>\n *   <ion-tab [root]=\"tab2Root\"></ion-tab>\n *   <ion-tab [root]=\"tab3Root\"></ion-tab>\n * </ion-tabs>\n * ```\n *\n * Where `tab1Root`, `tab2Root`, and `tab3Root` are each a page:\n *\n *```ts\n * @Component({\n *   templateUrl: 'build/pages/tabs/tabs.html'\n * })\n * export class TabsPage {\n *   // this tells the tabs component which Pages\n *   // should be each tab's root Page\n *   tab1Root = Page1;\n *   tab2Root = Page2;\n *   tab3Root = Page3;\n *\n *   constructor() {\n *\n *   }\n * }\n *```\n *\n * By default, the first tab will be selected upon navigation to the\n * Tabs page. We can change the selected tab by using `selectedIndex`\n * on the `<ion-tabs>` element:\n *\n * ```html\n * <ion-tabs selectedIndex=\"2\">\n *   <ion-tab [root]=\"tab1Root\"></ion-tab>\n *   <ion-tab [root]=\"tab2Root\"></ion-tab>\n *   <ion-tab [root]=\"tab3Root\"></ion-tab>\n * </ion-tabs>\n * ```\n *\n * Since the index starts at `0`, this will select the 3rd tab which has\n * root set to `tab3Root`. If you wanted to change it dynamically from\n * your class, you could use [property binding](https://angular.io/docs/ts/latest/guide/template-syntax.html#!#property-binding).\n *\n * Alternatively, you can grab the `Tabs` instance and call the `select()`\n * method. This requires the `<ion-tabs>` element to have an `id`. For\n * example, set the value of `id` to `myTabs`:\n *\n * ```html\n * <ion-tabs #myTabs>\n *   <ion-tab [root]=\"tab1Root\"></ion-tab>\n *   <ion-tab [root]=\"tab2Root\"></ion-tab>\n *   <ion-tab [root]=\"tab3Root\"></ion-tab>\n * </ion-tabs>\n * ```\n *\n * Then in your class you can grab the `Tabs` instance and call `select()`,\n * passing the index of the tab as the argument. Here we're grabbing the tabs\n * by using ViewChild.\n *\n *```ts\n * export class TabsPage {\n *\n * @ViewChild('myTabs') tabRef: Tabs;\n *\n * ionViewDidEnter() {\n *   this.tabRef.select(2);\n *  }\n *\n * }\n *```\n *\n * You can also switch tabs from a child component by calling `select()` on the\n * parent view using the `NavController` instance. For example, assuming you have\n * a `TabsPage` component, you could call the following from any of the child\n * components to switch to `TabsRoot3`:\n *\n *```ts\n * switchTabs() {\n *   this.navCtrl.parent.select(2);\n * }\n *```\n * @demo /docs/demos/src/tabs/\n *\n * @see {@link /docs/components#tabs Tabs Component Docs}\n * @see {@link ../Tab Tab API Docs}\n * @see {@link ../../config/Config Config API Docs}\n *\n */\nexport class Tabs extends Ion {\n    constructor(parent, viewCtrl, _app, config, elementRef, _plt, renderer, _linker, keyboard) {\n        super(config, elementRef, renderer, 'tabs');\n        this.viewCtrl = viewCtrl;\n        this._app = _app;\n        this._plt = _plt;\n        this._linker = _linker;\n        /** @internal */\n        this._ids = -1;\n        /** @internal */\n        this._tabs = [];\n        /** @internal */\n        this._selectHistory = [];\n        /** @internal */\n        this._onDestroy = new Subject();\n        /**\n         * @output {any} Emitted when the tab changes.\n         */\n        this.ionChange = new EventEmitter();\n        this.parent = parent;\n        this.id = 't' + (++tabIds);\n        this._sbPadding = config.getBoolean('statusbarPadding');\n        this.tabsHighlight = config.getBoolean('tabsHighlight');\n        if (this.parent) {\n            // this Tabs has a parent Nav\n            this.parent.registerChildNav(this);\n        }\n        else if (viewCtrl && viewCtrl.getNav()) {\n            // this Nav was opened from a modal\n            this.parent = viewCtrl.getNav();\n            this.parent.registerChildNav(this);\n        }\n        else if (this._app) {\n            // this is the root navcontroller for the entire app\n            this._app.registerRootNav(this);\n        }\n        // Tabs may also be an actual ViewController which was navigated to\n        // if Tabs is static and not navigated to within a NavController\n        // then skip this and don't treat it as it's own ViewController\n        if (viewCtrl) {\n            viewCtrl._setContent(this);\n            viewCtrl._setContentRef(elementRef);\n        }\n        const keyboardResizes = config.getBoolean('keyboardResizes', false);\n        if (keyboard && keyboardResizes) {\n            keyboard.willHide\n                .takeUntil(this._onDestroy)\n                .subscribe(() => {\n                this._plt.timeout(() => this.setTabbarHidden(false), 50);\n            });\n            keyboard.willShow\n                .takeUntil(this._onDestroy)\n                .subscribe(() => this.setTabbarHidden(true));\n        }\n    }\n    /**\n     * @internal\n     */\n    setTabbarHidden(tabbarHidden) {\n        this.setElementClass('tabbar-hidden', tabbarHidden);\n        this.resize();\n    }\n    /**\n     * @internal\n     */\n    ngOnDestroy() {\n        this._onDestroy.next();\n        if (this.parent) {\n            this.parent.unregisterChildNav(this);\n        }\n        else {\n            this._app.unregisterRootNav(this);\n        }\n    }\n    /**\n     * @internal\n     */\n    ngAfterViewInit() {\n        this._setConfig('tabsPlacement', 'bottom');\n        this._setConfig('tabsLayout', 'icon-top');\n        this._setConfig('tabsHighlight', this.tabsHighlight);\n        if (this.tabsHighlight) {\n            this._plt.resize\n                .takeUntil(this._onDestroy)\n                .subscribe(() => this._highlight.select(this.getSelected()));\n        }\n        this.initTabs();\n    }\n    /**\n     * @internal\n     */\n    initTabs() {\n        // get the selected index from the input\n        // otherwise default it to use the first index\n        let selectedIndex = (isBlank(this.selectedIndex) ? 0 : parseInt(this.selectedIndex, 10));\n        // now see if the deep linker can find a tab index\n        const tabsSegment = this._linker.getSegmentByNavIdOrName(this.id, this.name);\n        if (tabsSegment) {\n            // we found a segment which probably represents which tab to select\n            selectedIndex = this._getSelectedTabIndex(tabsSegment.secondaryId, selectedIndex);\n        }\n        // get the selectedIndex and ensure it isn't hidden or disabled\n        let selectedTab = this._tabs.find((t, i) => i === selectedIndex && t.enabled && t.show);\n        if (!selectedTab) {\n            // wasn't able to select the tab they wanted\n            // try to find the first tab that's available\n            selectedTab = this._tabs.find(t => t.enabled && t.show);\n        }\n        let promise = Promise.resolve();\n        if (selectedTab) {\n            selectedTab._segment = tabsSegment;\n            promise = this.select(selectedTab);\n        }\n        return promise.then(() => {\n            // set the initial href attribute values for each tab\n            this._tabs.forEach(t => {\n                t.updateHref(t.root, t.rootParams);\n            });\n        });\n    }\n    /**\n     * @internal\n     */\n    _setConfig(attrKey, fallback) {\n        let val = this[attrKey];\n        if (isBlank(val)) {\n            val = this._config.get(attrKey, fallback);\n        }\n        this.setElementAttribute(attrKey, val);\n    }\n    /**\n     * @hidden\n     */\n    add(tab) {\n        this._tabs.push(tab);\n        return this.id + '-' + (++this._ids);\n    }\n    /**\n     * @param {number|Tab} tabOrIndex Index, or the Tab instance, of the tab to select.\n     */\n    select(tabOrIndex, opts = {}, fromUrl = false) {\n        const selectedTab = (typeof tabOrIndex === 'number' ? this.getByIndex(tabOrIndex) : tabOrIndex);\n        if (isBlank(selectedTab)) {\n            return Promise.resolve();\n        }\n        // If the selected tab is the current selected tab, we do not switch\n        const currentTab = this.getSelected();\n        if (selectedTab === currentTab && currentTab.getActive()) {\n            return this._updateCurrentTab(selectedTab, fromUrl);\n        }\n        // If the selected tab does not have a root, we do not switch (#9392)\n        // it's possible the tab is only for opening modal's or signing out\n        // and doesn't actually have content. In the case there's no content\n        // for a tab then do nothing and leave the current view as is\n        if (selectedTab.root) {\n            // At this point we are going to perform a page switch\n            // Let's fire willLeave in the current tab page\n            var currentPage;\n            if (currentTab) {\n                currentPage = currentTab.getActive();\n                currentPage && currentPage._willLeave(false);\n            }\n            // Fire willEnter in the new selected tab\n            const selectedPage = selectedTab.getActive();\n            selectedPage && selectedPage._willEnter();\n            // Let's start the transition\n            opts.animate = false;\n            return selectedTab.load(opts).then(() => {\n                this._tabSwitchEnd(selectedTab, selectedPage, currentPage);\n                if (opts.updateUrl !== false) {\n                    this._linker.navChange(DIRECTION_SWITCH);\n                }\n                (void 0) /* assert */;\n                this._fireChangeEvent(selectedTab);\n            });\n        }\n        else {\n            this._fireChangeEvent(selectedTab);\n            return Promise.resolve();\n        }\n    }\n    _fireChangeEvent(selectedTab) {\n        selectedTab.ionSelect.emit(selectedTab);\n        this.ionChange.emit(selectedTab);\n    }\n    _tabSwitchEnd(selectedTab, selectedPage, currentPage) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        // Update tabs selection state\n        const tabs = this._tabs;\n        let tab;\n        for (var i = 0; i < tabs.length; i++) {\n            tab = tabs[i];\n            tab.setSelected(tab === selectedTab);\n        }\n        if (this.tabsHighlight) {\n            this._highlight.select(selectedTab);\n        }\n        // Fire didEnter/didLeave lifecycle events\n        if (selectedPage) {\n            selectedPage._didEnter();\n            this._app.viewDidEnter.emit(selectedPage);\n        }\n        if (currentPage) {\n            currentPage && currentPage._didLeave();\n            this._app.viewDidLeave.emit(currentPage);\n        }\n        // track the order of which tabs have been selected, by their index\n        // do not track if the tab index is the same as the previous\n        if (this._selectHistory[this._selectHistory.length - 1] !== selectedTab.id) {\n            this._selectHistory.push(selectedTab.id);\n        }\n    }\n    /**\n     * Get the previously selected Tab which is currently not disabled or hidden.\n     * @param {boolean} trimHistory If the selection history should be trimmed up to the previous tab selection or not.\n     * @returns {Tab}\n     */\n    previousTab(trimHistory = true) {\n        // walk backwards through the tab selection history\n        // and find the first previous tab that is enabled and shown\n        (void 0) /* console.debug */;\n        for (var i = this._selectHistory.length - 2; i >= 0; i--) {\n            var tab = this._tabs.find(t => t.id === this._selectHistory[i]);\n            if (tab && tab.enabled && tab.show) {\n                if (trimHistory) {\n                    this._selectHistory.splice(i + 1);\n                }\n                return tab;\n            }\n        }\n        return null;\n    }\n    /**\n     * @param {number} index Index of the tab you want to get\n     * @returns {Tab} Returns the tab who's index matches the one passed\n     */\n    getByIndex(index) {\n        return this._tabs[index];\n    }\n    /**\n     * @return {Tab} Returns the currently selected tab\n     */\n    getSelected() {\n        const tabs = this._tabs;\n        for (var i = 0; i < tabs.length; i++) {\n            if (tabs[i].isSelected) {\n                return tabs[i];\n            }\n        }\n        return null;\n    }\n    /**\n     * @internal\n     */\n    getActiveChildNavs() {\n        const selected = this.getSelected();\n        return selected ? [selected] : [];\n    }\n    /**\n     * @internal\n     */\n    getAllChildNavs() {\n        return this._tabs;\n    }\n    /**\n     * @internal\n     */\n    getIndex(tab) {\n        return this._tabs.indexOf(tab);\n    }\n    /**\n     * @internal\n     */\n    length() {\n        return this._tabs.length;\n    }\n    /**\n     * \"Touch\" the active tab, going back to the root view of the tab\n     * or optionally letting the tab handle the event\n     */\n    _updateCurrentTab(tab, fromUrl) {\n        const active = tab.getActive();\n        if (active) {\n            if (fromUrl && tab._segment) {\n                // see if the view controller exists\n                const vc = tab.getViewById(tab._segment.name);\n                if (vc) {\n                    // the view is already in the stack\n                    return tab.popTo(vc, {\n                        animate: false,\n                        updateUrl: false,\n                    });\n                }\n                else if (tab._views.length === 0 && tab._segment.defaultHistory && tab._segment.defaultHistory.length) {\n                    return this._linker.initViews(tab._segment).then((views) => {\n                        return tab.setPages(views, {\n                            animate: false, updateUrl: false\n                        });\n                    }).then(() => {\n                        tab._segment = null;\n                    });\n                }\n                else {\n                    return tab.setRoot(tab._segment.name, tab._segment.data, {\n                        animate: false, updateUrl: false\n                    }).then(() => {\n                        tab._segment = null;\n                    });\n                }\n            }\n            else if (active._cmp && active._cmp.instance.ionSelected) {\n                // if they have a custom tab selected handler, call it\n                active._cmp.instance.ionSelected();\n                return Promise.resolve();\n            }\n            else if (tab.length() > 1) {\n                // if we're a few pages deep, pop to root\n                return tab.popToRoot();\n            }\n            else {\n                return getComponent(this._linker, tab.root).then(viewController => {\n                    if (viewController.component !== active.component) {\n                        // Otherwise, if the page we're on is not our real root\n                        // reset it to our default root type\n                        return tab.setRoot(tab.root);\n                    }\n                }).catch(() => {\n                    (void 0) /* console.debug */;\n                });\n            }\n        }\n    }\n    /**\n     * @internal\n     * DOM WRITE\n     */\n    setTabbarPosition(top, bottom) {\n        if (this._top !== top || this._bottom !== bottom) {\n            var tabbarEle = this._tabbar.nativeElement;\n            tabbarEle.style.top = (top > -1 ? top + 'px' : '');\n            tabbarEle.style.bottom = (bottom > -1 ? bottom + 'px' : '');\n            tabbarEle.classList.add('show-tabbar');\n            this._top = top;\n            this._bottom = bottom;\n        }\n    }\n    /**\n     * @internal\n     */\n    resize() {\n        const tab = this.getSelected();\n        tab && tab.resize();\n    }\n    /**\n     * @internal\n     */\n    initPane() {\n        const isMain = this._elementRef.nativeElement.hasAttribute('main');\n        return isMain;\n    }\n    /**\n     * @internal\n     */\n    paneChanged(isPane) {\n        if (isPane) {\n            this.resize();\n        }\n    }\n    goToRoot(opts) {\n        if (this._tabs.length) {\n            return this.select(this._tabs[0], opts);\n        }\n    }\n    /*\n     * @private\n     */\n    getType() {\n        return 'tabs';\n    }\n    /*\n     * @private\n     */\n    getSecondaryIdentifier() {\n        const tabs = this.getActiveChildNavs();\n        if (tabs && tabs.length) {\n            return this._linker._getTabSelector(tabs[0]);\n        }\n        return '';\n    }\n    /**\n     * @private\n     */\n    _getSelectedTabIndex(secondaryId = '', fallbackIndex = 0) {\n        // we found a segment which probably represents which tab to select\n        const indexMatch = secondaryId.match(/tab-(\\d+)/);\n        if (indexMatch) {\n            // awesome, the segment name was something \"tab-0\", and\n            // the numbe represents which tab to select\n            return parseInt(indexMatch[1], 10);\n        }\n        // wasn't in the \"tab-0\" format so maybe it's using a word\n        const tab = this._tabs.find(t => {\n            return (isPresent(t.tabUrlPath) && t.tabUrlPath === secondaryId) ||\n                (isPresent(t.tabTitle) && formatUrlPart(t.tabTitle) === secondaryId);\n        });\n        return isPresent(tab) ? tab.index : fallbackIndex;\n    }\n}\nTabs.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-tabs',\n                template: '<div class=\"tabbar\" role=\"tablist\" #tabbar>' +\n                    '<a *ngFor=\"let t of _tabs\" [tab]=\"t\" class=\"tab-button\" role=\"tab\" href=\"#\" (ionSelect)=\"select(t)\"></a>' +\n                    '<div class=\"tab-highlight\"></div>' +\n                    '</div>' +\n                    '<ng-content></ng-content>' +\n                    '<div #portal tab-portal></div>',\n                encapsulation: ViewEncapsulation.None,\n                providers: [{ provide: RootNode, useExisting: forwardRef(() => Tabs) }]\n            },] },\n];\n/** @nocollapse */\nTabs.ctorParameters = () => [\n    { type: NavController, decorators: [{ type: Optional },] },\n    { type: ViewController, decorators: [{ type: Optional },] },\n    { type: App, },\n    { type: Config, },\n    { type: ElementRef, },\n    { type: Platform, },\n    { type: Renderer, },\n    { type: DeepLinker, },\n    { type: Keyboard, },\n];\nTabs.propDecorators = {\n    'name': [{ type: Input },],\n    'selectedIndex': [{ type: Input },],\n    'tabsLayout': [{ type: Input },],\n    'tabsPlacement': [{ type: Input },],\n    'tabsHighlight': [{ type: Input },],\n    'ionChange': [{ type: Output },],\n    '_highlight': [{ type: ViewChild, args: [TabHighlight,] },],\n    '_tabbar': [{ type: ViewChild, args: ['tabbar',] },],\n    'portal': [{ type: ViewChild, args: ['portal', { read: ViewContainerRef },] },],\n};\nlet tabIds = -1;\n"]}