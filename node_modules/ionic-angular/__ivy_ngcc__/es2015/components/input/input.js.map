{"version":3,"file":"input.js","sources":["input.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;8GA+CE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Optional, Output, Renderer, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { NgControl } from '@angular/forms';\nimport { Subject } from 'rxjs/Subject';\nimport 'rxjs/add/operator/takeUntil';\nimport { App } from '../app/app';\nimport { Config } from '../../config/config';\nimport { Content } from '../content/content';\nimport { copyInputAttributes, hasPointerMoved, pointerCoord } from '../../util/dom';\nimport { DomController } from '../../platform/dom-controller';\nimport { Form } from '../../util/form';\nimport { BaseInput } from '../../util/base-input';\nimport { isTrueProperty } from '../../util/util';\nimport { Item } from '../item/item';\nimport { Platform } from '../../platform/platform';\n/**\n * @name Input\n * @description\n *\n * `ion-input` is meant for text type inputs only, such as `text`,\n * `password`, `email`, `number`, `search`, `tel`, and `url`. Ionic\n * still uses an actual `<input type=\"text\">` HTML element within the\n * component, however, with Ionic wrapping the native HTML input\n * element it's better able to handle the user experience and\n * interactivity.\n *\n * Similarly, `<ion-textarea>` should be used in place of `<textarea>`.\n *\n * An `ion-input` is **not** used for non-text type inputs, such as a\n * `checkbox`, `radio`, `toggle`, `range`, `select`, etc.\n *\n * Along with the blur/focus events, `input` support all standard text input\n * events like `keyup`, `keydown`, `keypress`, `input`, etc. Any standard event\n * can be attached and will function as expected. Example: `<ion-input (click)=\"someFunction()\"></ion-input>`\n *\n * @usage\n * ```html\n * <ion-list>\n *   <ion-item>\n *     <ion-label color=\"primary\">Inline Label</ion-label>\n *     <ion-input placeholder=\"Text Input\"></ion-input>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-label color=\"primary\" fixed>Fixed Label</ion-label>\n *     <ion-input type=\"tel\" placeholder=\"Tel Input\"></ion-input>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-input type=\"number\" placeholder=\"Number Input with no label\"></ion-input>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-label color=\"primary\" stacked>Stacked Label</ion-label>\n *     <ion-input type=\"email\" placeholder=\"Email Input\"></ion-input>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-label color=\"primary\" stacked>Stacked Label</ion-label>\n *     <ion-input type=\"password\" placeholder=\"Password Input\"></ion-input>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-label color=\"primary\" floating>Floating Label</ion-label>\n *     <ion-input></ion-input>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-input placeholder=\"Clear Input\" clearInput></ion-input>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-textarea placeholder=\"Enter a description\"></ion-textarea>\n *   </ion-item>\n * </ion-list>\n * ```\n *\n * @demo /docs/demos/src/input/\n */\nexport class TextInput extends BaseInput {\n    constructor(config, _plt, _form, _app, elementRef, renderer, _content, _item, ngControl, _dom) {\n        super(config, elementRef, renderer, 'input', '', _form, _item, ngControl);\n        this._plt = _plt;\n        this._app = _app;\n        this._content = _content;\n        this.ngControl = ngControl;\n        this._dom = _dom;\n        this._clearInput = false;\n        this._readonly = false;\n        this._type = 'text';\n        this._isTextarea = false;\n        this._onDestroy = new Subject();\n        this._useAssist = false;\n        this._relocated = false;\n        /**\n         * @input {string} Set the input's autocomplete property. Values: `\"on\"`, `\"off\"`. Default `\"off\"`.\n         */\n        this.autocomplete = '';\n        /**\n         * @input {string} Set the input's autocorrect property. Values: `\"on\"`, `\"off\"`. Default `\"off\"`.\n         */\n        this.autocorrect = '';\n        /**\n         * @input {string} Instructional text that shows before the input has a value.\n         */\n        this.placeholder = '';\n        /**\n         * @input {any} The minimum value, which must not be greater than its maximum (max attribute) value.\n         */\n        this.min = null;\n        /**\n         * @input {any} The maximum value, which must not be less than its minimum (min attribute) value.\n         */\n        this.max = null;\n        /**\n         * @input {any} Works with the min and max attributes to limit the increments at which a value can be set.\n         */\n        this.step = null;\n        /**\n         * @hidden\n         */\n        this.input = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.blur = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.focus = new EventEmitter();\n        this.autocomplete = config.get('autocomplete', 'off');\n        this.autocorrect = config.get('autocorrect', 'off');\n        this._autoFocusAssist = config.get('autoFocusAssist', 'delay');\n        this._keyboardHeight = config.getNumber('keyboardHeight');\n        this._isTextarea = !!(elementRef.nativeElement.tagName === 'ION-TEXTAREA');\n        if (this._isTextarea && _item) {\n            _item.setElementClass('item-textarea', true);\n        }\n        // If not inside content, let's disable all the hacks\n        if (!_content) {\n            return;\n        }\n        const hideCaretOnScroll = config.getBoolean('hideCaretOnScroll', false);\n        if (hideCaretOnScroll) {\n            this._enableHideCaretOnScroll();\n        }\n        const win = _plt.win();\n        const keyboardPlugin = win.Ionic && win.Ionic.keyboardPlugin;\n        if (keyboardPlugin) {\n            const keyboardResizes = config.getBoolean('keyboardResizes', false);\n            if (keyboardResizes) {\n                this._keyboardHeight = config.getNumber('keyboardSafeArea', 60);\n                this._enableScrollMove();\n            }\n            else {\n                this._enableScrollPadding();\n                this._enableScrollMove();\n            }\n        }\n        else {\n            this._useAssist = config.getBoolean('scrollAssist', false);\n            const usePadding = config.getBoolean('scrollPadding', this._useAssist);\n            if (usePadding) {\n                this._enableScrollPadding();\n            }\n        }\n    }\n    /**\n     * @input {boolean} If true, a clear icon will appear in the input when there is a value. Clicking it clears the input.\n     */\n    get clearInput() {\n        return this._clearInput;\n    }\n    set clearInput(val) {\n        this._clearInput = (!this._isTextarea && isTrueProperty(val));\n    }\n    /**\n     * @input {string} The type of control to display. The default type is text.\n     * Possible values are: `\"text\"`, `\"password\"`, `\"email\"`, `\"number\"`, `\"search\"`, `\"tel\"`, or `\"url\"`.\n     */\n    get type() {\n        return (this._isTextarea)\n            ? 'text'\n            : this._type;\n    }\n    set type(val) {\n        this._type = val;\n    }\n    /**\n     * @input {boolean} If true, the user cannot modify the value.\n     */\n    get readonly() {\n        return this._readonly;\n    }\n    set readonly(val) {\n        this._readonly = isTrueProperty(val);\n    }\n    /**\n     * @input {boolean} If true, the value will be cleared after focus upon edit.\n     * Defaults to `true` when `type` is `\"password\"`, `false` for all other types.\n     */\n    get clearOnEdit() {\n        return this._clearOnEdit;\n    }\n    set clearOnEdit(val) {\n        this._clearOnEdit = isTrueProperty(val);\n    }\n    ngAfterContentInit() { }\n    /**\n     * @hidden\n     */\n    ngAfterViewInit() {\n        (void 0) /* assert */;\n        // By default, password inputs clear after focus when they have content\n        if (this.clearOnEdit !== false && this.type === 'password') {\n            this.clearOnEdit = true;\n        }\n        const ionInputEle = this._elementRef.nativeElement;\n        const nativeInputEle = this._native.nativeElement;\n        // Copy remaining attributes, not handled by ionic/angular\n        copyInputAttributes(ionInputEle, nativeInputEle);\n        // prevent having tabIndex duplicated\n        if (ionInputEle.hasAttribute('tabIndex')) {\n            ionInputEle.removeAttribute('tabIndex');\n        }\n        // handle the autofocus attribute\n        if (ionInputEle.hasAttribute('autofocus')) {\n            ionInputEle.removeAttribute('autofocus');\n            switch (this._autoFocusAssist) {\n                case 'immediate':\n                    // config says to immediate focus on the input\n                    // works best on android devices\n                    nativeInputEle.focus();\n                    break;\n                case 'delay':\n                    // config says to chill out a bit and focus on the input after transitions\n                    // works best on desktop\n                    this._plt.timeout(() => nativeInputEle.focus(), 800);\n                    break;\n            }\n            // traditionally iOS has big issues with autofocus on actual devices\n            // autoFocus is disabled by default with the iOS mode config\n        }\n        // Initialize the input (can start emitting events)\n        this._initialize();\n        if (this.focus.observers.length > 0) {\n            console.warn('(focus) is deprecated in ion-input, use (ionFocus) instead');\n        }\n        if (this.blur.observers.length > 0) {\n            console.warn('(blur) is deprecated in ion-input, use (ionBlur) instead');\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._onDestroy.next();\n        this._onDestroy = null;\n    }\n    /**\n     * @hidden\n     */\n    initFocus() {\n        this.setFocus();\n    }\n    /**\n     * @hidden\n     */\n    setFocus() {\n        // let's set focus to the element\n        // but only if it does not already have focus\n        if (!this.isFocus()) {\n            this._native.nativeElement.focus();\n        }\n    }\n    /**\n     * @hidden\n     */\n    setBlur() {\n        if (this.isFocus()) {\n            this._native.nativeElement.blur();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onInput(ev) {\n        this.value = ev.target.value;\n        // TODO: deprecate this\n        this.input.emit(ev);\n    }\n    /**\n     * @hidden\n     */\n    onBlur(ev) {\n        this._fireBlur();\n        // TODO: deprecate this (06/07/2017)\n        this.blur.emit(ev);\n        this._scrollData = null;\n        if (this._clearOnEdit && this.hasValue()) {\n            this._didBlurAfterEdit = true;\n        }\n    }\n    /**\n     * @hidden\n     */\n    onFocus(ev) {\n        this._fireFocus();\n        // TODO: deprecate this (06/07/2017)\n        this.focus.emit(ev);\n    }\n    /**\n     * @hidden\n     */\n    onKeydown(ev) {\n        if (ev && this._clearOnEdit) {\n            this.checkClearOnEdit(ev.target.value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    _inputUpdated() {\n        super._inputUpdated();\n        const inputEle = this._native.nativeElement;\n        const value = this._value;\n        if (inputEle.value !== value) {\n            inputEle.value = value;\n        }\n    }\n    /**\n     * @hidden\n     */\n    clearTextInput() {\n        this.value = '';\n    }\n    /**\n    * Check if we need to clear the text input if clearOnEdit is enabled\n    * @hidden\n    */\n    checkClearOnEdit(_) {\n        if (!this._clearOnEdit) {\n            return;\n        }\n        // Did the input value change after it was blurred and edited?\n        if (this._didBlurAfterEdit && this.hasValue()) {\n            // Clear the input\n            this.clearTextInput();\n        }\n        // Reset the flag\n        this._didBlurAfterEdit = false;\n    }\n    _getScrollData() {\n        if (!this._content) {\n            return newScrollData();\n        }\n        // get container of this input, probably an ion-item a few nodes up\n        if (this._scrollData) {\n            return this._scrollData;\n        }\n        let ele = this._elementRef.nativeElement;\n        ele = ele.closest('ion-item,[ion-item]') || ele;\n        return this._scrollData = getScrollData(ele.offsetTop, ele.offsetHeight, this._content.getContentDimensions(), this._keyboardHeight, this._plt.height());\n    }\n    _relocateInput(shouldRelocate) {\n        if (this._relocated === shouldRelocate) {\n            return;\n        }\n        const platform = this._plt;\n        const componentEle = this.getNativeElement();\n        const focusedInputEle = this._native.nativeElement;\n        (void 0) /* console.debug */;\n        if (shouldRelocate) {\n            // this allows for the actual input to receive the focus from\n            // the user's touch event, but before it receives focus, it\n            // moves the actual input to a location that will not screw\n            // up the app's layout, and does not allow the native browser\n            // to attempt to scroll the input into place (messing up headers/footers)\n            // the cloned input fills the area of where native input should be\n            // while the native input fakes out the browser by relocating itself\n            // before it receives the actual focus event\n            // We hide the focused input (with the visible caret) invisiable by making it scale(0),\n            cloneInputComponent(platform, componentEle, focusedInputEle);\n            const inputRelativeY = this._getScrollData().inputSafeY;\n            // fix for #11817\n            const tx = this._plt.isRTL ? 9999 : -9999;\n            focusedInputEle.style[platform.Css.transform] = `translate3d(${tx}px,${inputRelativeY}px,0)`;\n            focusedInputEle.style.opacity = '0';\n        }\n        else {\n            removeClone(platform, componentEle, focusedInputEle);\n        }\n        this._relocated = shouldRelocate;\n    }\n    _enableScrollPadding() {\n        (void 0) /* assert */;\n        (void 0) /* console.debug */;\n        this.ionFocus.subscribe(() => {\n            const content = this._content;\n            const scrollPadding = this._getScrollData().scrollPadding;\n            content.addScrollPadding(scrollPadding);\n            content.clearScrollPaddingFocusOut();\n        });\n    }\n    _enableHideCaretOnScroll() {\n        (void 0) /* assert */;\n        const content = this._content;\n        (void 0) /* console.debug */;\n        content.ionScrollStart\n            .takeUntil(this._onDestroy)\n            .subscribe(() => scrollHideCaret(true));\n        content.ionScrollEnd\n            .takeUntil(this._onDestroy)\n            .subscribe(() => scrollHideCaret(false));\n        this.ionBlur.subscribe(() => this._relocateInput(false));\n        const self = this;\n        function scrollHideCaret(shouldHideCaret) {\n            // if it does have focus, then do the dom write\n            if (self.isFocus()) {\n                self._dom.write(() => self._relocateInput(shouldHideCaret));\n            }\n        }\n    }\n    _enableScrollMove() {\n        (void 0) /* assert */;\n        (void 0) /* console.debug */;\n        this.ionFocus.subscribe(() => {\n            const scrollData = this._getScrollData();\n            if (Math.abs(scrollData.scrollAmount) > 4) {\n                this._content.scrollTo(0, scrollData.scrollTo, scrollData.scrollDuration);\n            }\n        });\n    }\n    _pointerStart(ev) {\n        (void 0) /* assert */;\n        // input cover touchstart\n        if (ev.type === 'touchstart') {\n            this._isTouch = true;\n        }\n        if ((this._isTouch || (!this._isTouch && ev.type === 'mousedown')) && this._app.isEnabled()) {\n            // remember where the touchstart/mousedown started\n            this._coord = pointerCoord(ev);\n        }\n        (void 0) /* console.debug */;\n    }\n    _pointerEnd(ev) {\n        (void 0) /* assert */;\n        // input cover touchend/mouseup\n        (void 0) /* console.debug */;\n        if ((this._isTouch && ev.type === 'mouseup') || !this._app.isEnabled()) {\n            // the app is actively doing something right now\n            // don't try to scroll in the input\n            ev.preventDefault();\n            ev.stopPropagation();\n        }\n        else if (this._coord) {\n            // get where the touchend/mouseup ended\n            var endCoord = pointerCoord(ev);\n            // focus this input if the pointer hasn't moved XX pixels\n            // and the input doesn't already have focus\n            if (!hasPointerMoved(8, this._coord, endCoord) && !this.isFocus()) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                // begin the input focus process\n                this._jsSetFocus();\n            }\n        }\n        this._coord = null;\n    }\n    _jsSetFocus() {\n        (void 0) /* assert */;\n        // begin the process of setting focus to the inner input element\n        const content = this._content;\n        (void 0) /* console.debug */;\n        if (!content) {\n            // not inside of a scroll view, just focus it\n            this.setFocus();\n        }\n        var scrollData = this._getScrollData();\n        if (Math.abs(scrollData.scrollAmount) < 4) {\n            // the text input is in a safe position that doesn't\n            // require it to be scrolled into view, just set focus now\n            this.setFocus();\n            return;\n        }\n        // temporarily move the focus to the focus holder so the browser\n        // doesn't freak out while it's trying to get the input in place\n        // at this point the native text input still does not have focus\n        this._relocateInput(true);\n        this.setFocus();\n        // scroll the input into place\n        content.scrollTo(0, scrollData.scrollTo, scrollData.scrollDuration, () => {\n            // the scroll view is in the correct position now\n            // give the native text input focus\n            this._relocateInput(false);\n            // ensure this is the focused input\n            this.setFocus();\n        });\n    }\n}\nTextInput.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-input,ion-textarea',\n                template: '<input #textInput *ngIf=\"!_isTextarea\" class=\"text-input\" ' +\n                    '[ngClass]=\"\\'text-input-\\' + _mode\"' +\n                    '(input)=\"onInput($event)\" ' +\n                    '(blur)=\"onBlur($event)\" ' +\n                    '(focus)=\"onFocus($event)\" ' +\n                    '(keydown)=\"onKeydown($event)\" ' +\n                    '[type]=\"_type\" ' +\n                    'dir=\"auto\" ' +\n                    '[attr.aria-labelledby]=\"_labelId\" ' +\n                    '[attr.min]=\"min\" ' +\n                    '[attr.max]=\"max\" ' +\n                    '[attr.step]=\"step\" ' +\n                    '[attr.autocomplete]=\"autocomplete\" ' +\n                    '[attr.autocorrect]=\"autocorrect\" ' +\n                    '[placeholder]=\"placeholder\" ' +\n                    '[disabled]=\"_disabled\" ' +\n                    '[readonly]=\"_readonly\">' +\n                    '<textarea #textInput *ngIf=\"_isTextarea\" class=\"text-input\" ' +\n                    '[ngClass]=\"\\'text-input-\\' + _mode\"' +\n                    '(input)=\"onInput($event)\" ' +\n                    '(blur)=\"onBlur($event)\" ' +\n                    '(focus)=\"onFocus($event)\" ' +\n                    '(keydown)=\"onKeydown($event)\" ' +\n                    '[attr.aria-labelledby]=\"_labelId\" ' +\n                    '[attr.autocomplete]=\"autocomplete\" ' +\n                    '[attr.autocorrect]=\"autocorrect\" ' +\n                    '[placeholder]=\"placeholder\" ' +\n                    '[disabled]=\"_disabled\" ' +\n                    '[readonly]=\"_readonly\"></textarea>' +\n                    '<button ion-button *ngIf=\"_clearInput\" clear class=\"text-input-clear-icon\" ' +\n                    'type=\"button\" ' +\n                    '(click)=\"clearTextInput($event)\" ' +\n                    '(mousedown)=\"clearTextInput($event)\" ' +\n                    'tabindex=\"-1\"></button>' +\n                    '<div class=\"input-cover\" *ngIf=\"_useAssist\" ' +\n                    '(touchstart)=\"_pointerStart($event)\" ' +\n                    '(touchend)=\"_pointerEnd($event)\" ' +\n                    '(mousedown)=\"_pointerStart($event)\" ' +\n                    '(mouseup)=\"_pointerEnd($event)\"></div>',\n                encapsulation: ViewEncapsulation.None,\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                inputs: ['value']\n            },] },\n];\n/** @nocollapse */\nTextInput.ctorParameters = () => [\n    { type: Config, },\n    { type: Platform, },\n    { type: Form, },\n    { type: App, },\n    { type: ElementRef, },\n    { type: Renderer, },\n    { type: Content, decorators: [{ type: Optional },] },\n    { type: Item, decorators: [{ type: Optional },] },\n    { type: NgControl, decorators: [{ type: Optional },] },\n    { type: DomController, },\n];\nTextInput.propDecorators = {\n    'clearInput': [{ type: Input },],\n    'type': [{ type: Input },],\n    'readonly': [{ type: Input },],\n    'clearOnEdit': [{ type: Input },],\n    '_native': [{ type: ViewChild, args: ['textInput', { read: ElementRef },] },],\n    'autocomplete': [{ type: Input },],\n    'autocorrect': [{ type: Input },],\n    'placeholder': [{ type: Input },],\n    'min': [{ type: Input },],\n    'max': [{ type: Input },],\n    'step': [{ type: Input },],\n    'input': [{ type: Output },],\n    'blur': [{ type: Output },],\n    'focus': [{ type: Output },],\n};\n/**\n * @name TextArea\n * @description\n *\n * `ion-textarea` is used for multi-line text inputs. Ionic still\n * uses an actual `<textarea>` HTML element within the component;\n * however, with Ionic wrapping the native HTML text area element, Ionic\n * is able to better handle the user experience and interactivity.\n *\n * Note that `<ion-textarea>` must load its value from the `value` or\n * `[(ngModel)]` attribute. Unlike the native `<textarea>` element,\n * `<ion-textarea>` does not support loading its value from the\n * textarea's inner content.\n *\n * When requiring only a single-line text input, we recommend using\n * `<ion-input>` instead.\n *\n * @usage\n * ```html\n *  <ion-item>\n *    <ion-label>Comments</ion-label>\n *    <ion-textarea></ion-textarea>\n *  </ion-item>\n *\n *  <ion-item>\n *    <ion-label stacked>Message</ion-label>\n *    <ion-textarea [(ngModel)]=\"msg\"></ion-textarea>\n *  </ion-item>\n *\n *  <ion-item>\n *    <ion-label floating>Description</ion-label>\n *    <ion-textarea></ion-textarea>\n *  </ion-item>\n *\n * <ion-item>\n *    <ion-label>Long Description</ion-label>\n *    <ion-textarea rows=\"6\" placeholder=\"enter long description here...\"></ion-textarea>\n *  </ion-item>\n * ```\n *\n * @demo /docs/demos/src/textarea/\n */\nconst SCROLL_ASSIST_SPEED = 0.3;\nfunction newScrollData() {\n    return {\n        scrollAmount: 0,\n        scrollTo: 0,\n        scrollPadding: 0,\n        scrollDuration: 0,\n        inputSafeY: 0\n    };\n}\n/**\n * @hidden\n */\nexport function getScrollData(inputOffsetTop, inputOffsetHeight, scrollViewDimensions, keyboardHeight, plaformHeight) {\n    // compute input's Y values relative to the body\n    const inputTop = (inputOffsetTop + scrollViewDimensions.contentTop - scrollViewDimensions.scrollTop);\n    const inputBottom = (inputTop + inputOffsetHeight);\n    // compute the safe area which is the viewable content area when the soft keyboard is up\n    const safeAreaTop = scrollViewDimensions.contentTop;\n    const safeAreaHeight = (plaformHeight - keyboardHeight - safeAreaTop) / 2;\n    const safeAreaBottom = safeAreaTop + safeAreaHeight;\n    // figure out if each edge of teh input is within the safe area\n    const inputTopWithinSafeArea = (inputTop >= safeAreaTop && inputTop <= safeAreaBottom);\n    const inputTopAboveSafeArea = (inputTop < safeAreaTop);\n    const inputTopBelowSafeArea = (inputTop > safeAreaBottom);\n    const inputBottomWithinSafeArea = (inputBottom >= safeAreaTop && inputBottom <= safeAreaBottom);\n    const inputBottomBelowSafeArea = (inputBottom > safeAreaBottom);\n    /*\n    Text Input Scroll To Scenarios\n    ---------------------------------------\n    1) Input top within safe area, bottom within safe area\n    2) Input top within safe area, bottom below safe area, room to scroll\n    3) Input top above safe area, bottom within safe area, room to scroll\n    4) Input top below safe area, no room to scroll, input smaller than safe area\n    5) Input top within safe area, bottom below safe area, no room to scroll, input smaller than safe area\n    6) Input top within safe area, bottom below safe area, no room to scroll, input larger than safe area\n    7) Input top below safe area, no room to scroll, input larger than safe area\n    */\n    const scrollData = newScrollData();\n    // when auto-scrolling, there also needs to be enough\n    // content padding at the bottom of the scroll view\n    // always add scroll padding when a text input has focus\n    // this allows for the content to scroll above of the keyboard\n    // content behind the keyboard would be blank\n    // some cases may not need it, but when jumping around it's best\n    // to have the padding already rendered so there's no jank\n    scrollData.scrollPadding = keyboardHeight;\n    if (inputTopWithinSafeArea && inputBottomWithinSafeArea) {\n        // Input top within safe area, bottom within safe area\n        // no need to scroll to a position, it's good as-is\n        return scrollData;\n    }\n    // looks like we'll have to do some auto-scrolling\n    if (inputTopBelowSafeArea || inputBottomBelowSafeArea || inputTopAboveSafeArea) {\n        // Input top or bottom below safe area\n        // auto scroll the input up so at least the top of it shows\n        if (safeAreaHeight > inputOffsetHeight) {\n            // safe area height is taller than the input height, so we\n            // can bring up the input just enough to show the input bottom\n            scrollData.scrollAmount = Math.round(safeAreaBottom - inputBottom);\n        }\n        else {\n            // safe area height is smaller than the input height, so we can\n            // only scroll it up so the input top is at the top of the safe area\n            // however the input bottom will be below the safe area\n            scrollData.scrollAmount = Math.round(safeAreaTop - inputTop);\n        }\n        scrollData.inputSafeY = -(inputTop - safeAreaTop) + 4;\n        if (inputTopAboveSafeArea && scrollData.scrollAmount > inputOffsetHeight) {\n            // the input top is above the safe area and we're already scrolling it into place\n            // don't let it scroll more than the height of the input\n            scrollData.scrollAmount = inputOffsetHeight;\n        }\n    }\n    // figure out where it should scroll to for the best position to the input\n    scrollData.scrollTo = (scrollViewDimensions.scrollTop - scrollData.scrollAmount);\n    // calculate animation duration\n    const distance = Math.abs(scrollData.scrollAmount);\n    const duration = distance / SCROLL_ASSIST_SPEED;\n    scrollData.scrollDuration = Math.min(400, Math.max(150, duration));\n    return scrollData;\n}\nfunction cloneInputComponent(plt, srcComponentEle, srcNativeInputEle) {\n    // Make sure we kill all the clones before creating new ones\n    // It is a defensive, removeClone() should do nothing\n    // removeClone(plt, srcComponentEle, srcNativeInputEle);\n    (void 0) /* assert */;\n    // given a native <input> or <textarea> element\n    // find its parent wrapping component like <ion-input> or <ion-textarea>\n    // then clone the entire component\n    if (srcComponentEle) {\n        // DOM READ\n        var srcTop = srcComponentEle.offsetTop;\n        var srcLeft = srcComponentEle.offsetLeft;\n        var srcWidth = srcComponentEle.offsetWidth;\n        var srcHeight = srcComponentEle.offsetHeight;\n        // DOM WRITE\n        // not using deep clone so we don't pull in unnecessary nodes\n        var clonedComponentEle = srcComponentEle.cloneNode(false);\n        var clonedStyle = clonedComponentEle.style;\n        clonedComponentEle.classList.add('cloned-input');\n        clonedComponentEle.setAttribute('aria-hidden', 'true');\n        clonedStyle.pointerEvents = 'none';\n        clonedStyle.position = 'absolute';\n        clonedStyle.top = srcTop + 'px';\n        clonedStyle.left = srcLeft + 'px';\n        clonedStyle.width = srcWidth + 'px';\n        clonedStyle.height = srcHeight + 'px';\n        var clonedNativeInputEle = srcNativeInputEle.cloneNode(false);\n        clonedNativeInputEle.value = srcNativeInputEle.value;\n        clonedNativeInputEle.tabIndex = -1;\n        clonedComponentEle.appendChild(clonedNativeInputEle);\n        srcComponentEle.parentNode.appendChild(clonedComponentEle);\n        srcComponentEle.style.pointerEvents = 'none';\n    }\n    srcNativeInputEle.style[plt.Css.transform] = 'scale(0)';\n}\nfunction removeClone(plt, srcComponentEle, srcNativeInputEle) {\n    if (srcComponentEle && srcComponentEle.parentElement) {\n        var clonedInputEles = srcComponentEle.parentElement.querySelectorAll('.cloned-input');\n        for (var i = 0; i < clonedInputEles.length; i++) {\n            clonedInputEles[i].parentNode.removeChild(clonedInputEles[i]);\n        }\n        srcComponentEle.style.pointerEvents = '';\n    }\n    srcNativeInputEle.style[plt.Css.transform] = '';\n    srcNativeInputEle.style.opacity = '';\n}\n"]}