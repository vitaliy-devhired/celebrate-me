{"version":3,"file":"virtual-scroll.js","sources":["virtual-scroll.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;wbAKE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA","sourcesContent":["import { ChangeDetectorRef, ContentChild, Directive, ElementRef, Input, IterableDiffers, NgZone, Renderer } from '@angular/core';\nimport { adjustRendered, calcDimensions, estimateHeight, initReadNodes, populateNodeData, processRecords, updateDimensions, updateNodeContext, writeToNodes } from './virtual-util';\nimport { Config } from '../../config/config';\nimport { Content } from '../content/content';\nimport { DomController } from '../../platform/dom-controller';\nimport { isFunction, isPresent } from '../../util/util';\nimport { Platform } from '../../platform/platform';\nimport { ViewController } from '../../navigation/view-controller';\nimport { VirtualItem } from './virtual-item';\nimport { VirtualFooter } from './virtual-footer';\nimport { VirtualHeader } from './virtual-header';\n/**\n * @name VirtualScroll\n * @description\n * Virtual Scroll displays a virtual, \"infinite\" list. An array of records\n * is passed to the virtual scroll containing the data to create templates\n * for. The template created for each record, referred to as a cell, can\n * consist of items, headers, and footers.\n *\n * For performance reasons, not every record in the list is rendered at once;\n * instead a small subset of records (enough to fill the viewport) are rendered\n * and reused as the user scrolls.\n *\n * ### The Basics\n *\n * The array of records should be passed to the `virtualScroll` property.\n * The data given to the `virtualScroll` property must be an array. An item\n * template with the `*virtualItem` property is required in the `virtualScroll`.\n * The `virtualScroll` and `*virtualItem` properties can be added to any element.\n *\n * ```html\n * <ion-list [virtualScroll]=\"items\">\n *\n *   <ion-item *virtualItem=\"let item\">\n *     {% raw %}{{ item }}{% endraw %}\n *   </ion-item>\n *\n * </ion-list>\n * ```\n *\n *\n * ### Section Headers and Footers\n *\n * Section headers and footers are optional. They can be dynamically created\n * from developer-defined functions. For example, a large list of contacts\n * usually has a divider for each letter in the alphabet. Developers provide\n * their own custom function to be called on each record. The logic in the\n * custom function should determine whether to create the section template\n * and what data to provide to the template. The custom function should\n * return `null` if a template shouldn't be created.\n *\n * ```html\n * <ion-list [virtualScroll]=\"items\" [headerFn]=\"myHeaderFn\">\n *\n *   <ion-item-divider *virtualHeader=\"let header\">\n *     Header: {% raw %}{{ header }}{% endraw %}\n *   </ion-item-divider>\n *\n *   <ion-item *virtualItem=\"let item\">\n *     Item: {% raw %}{{ item }}{% endraw %}\n *   </ion-item>\n *\n * </ion-list>\n * ```\n *\n * Below is an example of a custom function called on every record. It\n * gets passed the individual record, the record's index number,\n * and the entire array of records. In this example, after every 20\n * records a header will be inserted. So between the 19th and 20th records,\n * between the 39th and 40th, and so on, a `<ion-item-divider>` will\n * be created and the template's data will come from the function's\n * returned data.\n *\n * ```ts\n * myHeaderFn(record, recordIndex, records) {\n *   if (recordIndex % 20 === 0) {\n *     return 'Header ' + recordIndex;\n *   }\n *   return null;\n * }\n * ```\n *\n *\n * ### Approximate Widths and Heights\n *\n * If the height of items in the virtual scroll are not close to the\n * default size of 40px, it is extremely important to provide a value for\n * approxItemHeight height. An exact pixel-perfect size is not necessary,\n * but without an estimate the virtual scroll will not render correctly.\n *\n * The approximate width and height of each template is used to help\n * determine how many cells should be created, and to help calculate\n * the height of the scrollable area. Note that the actual rendered size\n * of each cell comes from the app's CSS, whereas this approximation\n * is only used to help calculate initial dimensions.\n *\n * It's also important to know that Ionic's default item sizes have\n * slightly different heights between platforms, which is perfectly fine.\n *\n *\n * ### Images Within Virtual Scroll\n *\n * HTTP requests, image decoding, and image rendering can cause jank while\n * scrolling. In order to better control images, Ionic provides `<ion-img>`\n * to manage HTTP requests and image rendering. While scrolling through items\n * quickly, `<ion-img>` knows when and when not to make requests, when and\n * when not to render images, and only loads the images that are viewable\n * after scrolling. [Read more about `ion-img`.](../../img/Img/)\n *\n * It's also important for app developers to ensure image sizes are locked in,\n * and after images have fully loaded they do not change size and affect any\n * other element sizes. Simply put, to ensure rendering bugs are not introduced,\n * it's vital that elements within a virtual item does not dynamically change.\n *\n * For virtual scrolling, the natural effects of the `<img>` are not desirable\n * features. We recommend using the `<ion-img>` component over the native\n * `<img>` element because when an `<img>` element is added to the DOM, it\n * immediately makes a HTTP request for the image file. Additionally, `<img>`\n * renders whenever it wants which could be while the user is scrolling. However,\n * `<ion-img>` is governed by the containing `ion-content` and does not render\n * images while scrolling quickly.\n *\n * ```html\n * <ion-list [virtualScroll]=\"items\">\n *\n *   <ion-item *virtualItem=\"let item\">\n *     <ion-avatar item-start>\n *       <ion-img [src]=\"item.avatarUrl\"></ion-img>\n *     </ion-avatar>\n *    {% raw %} {{ item.firstName }} {{ item.lastName }}{% endraw %}\n *   </ion-item>\n *\n * </ion-list>\n * ```\n *\n *\n * ### Custom Components\n *\n * If a custom component is going to be used within Virtual Scroll, it's best\n * to wrap it with a good old `<div>` to ensure the component is rendered\n * correctly. Since each custom component's implementation and internals can be\n * quite different, wrapping within a `<div>` is a safe way to make sure\n * dimensions are measured correctly.\n *\n * ```html\n * <ion-list [virtualScroll]=\"items\">\n *\n *   <div *virtualItem=\"let item\">\n *     <my-custom-item [item]=\"item\">\n *       {% raw %} {{ item }}{% endraw %}\n *     </my-custom-item>\n *   </div>\n *\n * </ion-list>\n * ```\n *\n *\n * ## Virtual Scroll Performance Tips\n *\n * #### iOS Cordova WKWebView\n *\n * When deploying to iOS with Cordova, it's highly recommended to use the\n * [WKWebView plugin](http://blog.ionic.io/cordova-ios-performance-improvements-drop-in-speed-with-wkwebview/)\n * in order to take advantage of iOS's higher performimg webview. Additionally,\n * WKWebView is superior at scrolling efficiently in comparision to the older\n * UIWebView.\n *\n * #### Lock in element dimensions and locations\n *\n * In order for virtual scroll to efficiently size and locate every item, it's\n * very important every element within each virtual item does not dynamically\n * change its dimensions or location. The best way to ensure size and location\n * does not change, it's recommended each virtual item has locked in its size\n * via CSS.\n *\n * #### Use `ion-img` for images\n *\n * When including images within Virtual Scroll, be sure to use\n * [`ion-img`](../img/Img/) rather than the standard `<img>` HTML element.\n * With `ion-img`, images are lazy loaded so only the viewable ones are\n * rendered, and HTTP requests are efficiently controlled while scrolling.\n *\n * #### Set Approximate Widths and Heights\n *\n * As mentioned above, all elements should lock in their dimensions. However,\n * virtual scroll isn't aware of the dimensions until after they have been\n * rendered. For the initial render, virtual scroll still needs to set\n * how many items should be built. With \"approx\" property inputs, such as\n * `approxItemHeight`, we're able to give virtual scroll an approximate size,\n * therefore allowing virtual scroll to decide how many items should be\n * created.\n *\n * #### Changing dataset should use `virtualTrackBy`\n *\n * It is possible for the identities of elements in the iterator to change\n * while the data does not. This can happen, for example, if the iterator\n * produced from an RPC to the server, and that RPC is re-run. Even if the\n * \"data\" hasn't changed, the second response will produce objects with\n * different identities, and Ionic will tear down the entire DOM and rebuild\n * it. This is an expensive operation and should be avoided if possible.\n *\n * #### Efficient headers and footer functions\n *\n * Each virtual item must stay extremely efficient, but one way to really\n * kill its performance is to perform any DOM operations within section header\n * and footer functions. These functions are called for every record in the\n * dataset, so please make sure they're performant.\n *\n */\nexport class VirtualScroll {\n    constructor(_iterableDiffers, _elementRef, _renderer, _zone, _cd, _content, _plt, _ctrl, _config, _dom) {\n        this._iterableDiffers = _iterableDiffers;\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        this._zone = _zone;\n        this._cd = _cd;\n        this._content = _content;\n        this._plt = _plt;\n        this._ctrl = _ctrl;\n        this._config = _config;\n        this._dom = _dom;\n        this._init = false;\n        this._lastEle = false;\n        this._records = [];\n        this._cells = [];\n        this._nodes = [];\n        this._vHeight = 0;\n        this._lastCheck = 0;\n        this._recordSize = 0;\n        this._data = {\n            scrollTop: 0,\n        };\n        this._queue = 1 /* NoChanges */;\n        /**\n         * @input {number} The buffer ratio is used to decide how many cells\n         * should get created when initially rendered. The number is a\n         * multiplier against the viewable area's height. For example, if it\n         * takes `20` cells to fill up the height of the viewable area, then\n         * with a buffer ratio of `3` it will create `60` cells that are\n         * available for reuse while scrolling. For better performance, it's\n         * better to have more cells than what are required to fill the\n         * viewable area. Default is `3`.\n         * In case more than one items are rendered per row, bufferRatio\n         * has to account for that and a multiple number should be used.\n         * For example if a single item per row list used 3 as bufferRatio\n         * a 4 item per row list should use 3 * 4 = 12 as buffer ratio.\n         */\n        this.bufferRatio = 3;\n        /**\n         * @input {string} The approximate width of each item template's cell.\n         * This dimension is used to help determine how many cells should\n         * be created when initialized, and to help calculate the height of\n         * the scrollable area. This value can use either `px` or `%` units.\n         * Note that the actual rendered size of each cell comes from the\n         * app's CSS, whereas this approximation is used to help calculate\n         * initial dimensions before the item has been rendered. Default is\n         * `100%`.\n         */\n        this.approxItemWidth = '100%';\n        /**\n         * @input {string} The approximate width of each header template's cell.\n         * This dimension is used to help determine how many cells should\n         * be created when initialized, and to help calculate the height of\n         * the scrollable area. This value can use either `px` or `%` units.\n         * Note that the actual rendered size of each cell comes from the\n         * app's CSS, whereas this approximation is used to help calculate\n         * initial dimensions. Default is `100%`.\n         */\n        this.approxHeaderWidth = '100%';\n        /**\n         * @input {string} The approximate height of each header template's cell.\n         * This dimension is used to help determine how many cells should\n         * be created when initialized, and to help calculate the height of\n         * the scrollable area. This height value can only use `px` units.\n         * Note that the actual rendered size of each cell comes from the\n         * app's CSS, whereas this approximation is used to help calculate\n         * initial dimensions before the item has been rendered. Default is `40px`.\n         */\n        this.approxHeaderHeight = '40px';\n        /**\n         * @input {string} The approximate width of each footer template's cell.\n         * This dimension is used to help determine how many cells should\n         * be created when initialized, and to help calculate the height of\n         * the scrollable area. This value can use either `px` or `%` units.\n         * Note that the actual rendered size of each cell comes from the\n         * app's CSS, whereas this approximation is used to help calculate\n         * initial dimensions before the item has been rendered. Default is `100%`.\n         */\n        this.approxFooterWidth = '100%';\n        /**\n         * @input {string} The approximate height of each footer template's cell.\n         * This dimension is used to help determine how many cells should\n         * be created when initialized, and to help calculate the height of\n         * the scrollable area. This height value can only use `px` units.\n         * Note that the actual rendered size of each cell comes from the\n         * app's CSS, whereas this approximation is used to help calculate\n         * initial dimensions before the item has been rendered. Default is `40px`.\n         */\n        this.approxFooterHeight = '40px';\n        // hide the virtual scroll element with opacity so we don't\n        // see jank as it loads up, but we're still able to read\n        // dimensions because it's still rendered and only opacity hidden\n        this.setElementClass('virtual-loading', true);\n        // wait for the content to be rendered and has readable dimensions\n        const readSub = _ctrl.readReady.subscribe(() => {\n            readSub.unsubscribe();\n            this.readUpdate(true);\n        });\n        // wait for the content to be writable\n        const writeSub = _ctrl.writeReady.subscribe(() => {\n            writeSub.unsubscribe();\n            this._init = true;\n            this.writeUpdate(true);\n            this._listeners();\n        });\n    }\n    /**\n     * @input {array} The data that builds the templates within the virtual scroll.\n     * This is the same data that you'd pass to `*ngFor`. It's important to note\n     * that when this data has changed, then the entire virtual scroll is reset,\n     * which is an expensive operation and should be avoided if possible.\n     */\n    set virtualScroll(val) {\n        this._records = val;\n    }\n    get virtualScroll() {\n        return this._records;\n    }\n    /**\n     * @input {function} Section headers and the data used within its given\n     * template can be dynamically created by passing a function to `headerFn`.\n     * For example, a large list of contacts usually has dividers between each\n     * letter in the alphabet. App's can provide their own custom `headerFn`\n     * which is called with each record within the dataset. The logic within\n     * the header function can decide if the header template should be used,\n     * and what data to give to the header template. The function must return\n     * `null` if a header cell shouldn't be created.\n     */\n    set headerFn(val) {\n        if (isFunction(val)) {\n            this._hdrFn = val.bind((this._ctrl._cmp) || this);\n        }\n    }\n    /**\n     * @input {function} Section footers and the data used within its given\n     * template can be dynamically created by passing a function to `footerFn`.\n     * The logic within the footer function can decide if the footer template\n     * should be used, and what data to give to the footer template. The function\n     * must return `null` if a footer cell shouldn't be created.\n     */\n    set footerFn(val) {\n        if (isFunction(val)) {\n            this._ftrFn = val.bind((this._ctrl._cmp) || this);\n        }\n    }\n    /**\n     * @hidden\n     */\n    firstRecord() {\n        const cells = this._cells;\n        return (cells.length > 0) ? cells[0].record : 0;\n    }\n    /**\n     * @hidden\n     */\n    lastRecord() {\n        const cells = this._cells;\n        return (cells.length > 0) ? cells[cells.length - 1].record : 0;\n    }\n    /**\n    * @hidden\n    */\n    ngOnChanges(changes) {\n        if ('virtualScroll' in changes) {\n            // React on virtualScroll changes only once all inputs have been initialized\n            const value = changes['virtualScroll'].currentValue;\n            if (!isPresent(this._differ) && isPresent(value)) {\n                try {\n                    this._differ = this._iterableDiffers.find(value).create(this.virtualTrackBy);\n                }\n                catch (e) {\n                    throw new Error(`Cannot find a differ supporting object '${value}'. VirtualScroll only supports binding to Iterables such as Arrays.`);\n                }\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngDoCheck() {\n        // only continue if we've already initialized\n        if (!this._init) {\n            return;\n        }\n        // and if there actually are changes\n        const changes = isPresent(this._differ) ? this._differ.diff(this.virtualScroll) : null;\n        if (!isPresent(changes)) {\n            return;\n        }\n        let needClean = false;\n        var lastRecord = this._recordSize;\n        changes.forEachOperation((_, pindex, cindex) => {\n            // add new record after current position\n            if (pindex === null && (cindex < lastRecord)) {\n                (void 0) /* console.debug */;\n                needClean = true;\n                return;\n            }\n            // remove record after current position\n            if (pindex < lastRecord && cindex === null) {\n                (void 0) /* console.debug */;\n                needClean = true;\n                return;\n            }\n        });\n        this._recordSize = this._records ? this._records.length : 0;\n        this.readUpdate(needClean);\n        this.writeUpdate(needClean);\n    }\n    /**\n     * @hidden\n     */\n    readUpdate(needClean) {\n        if (needClean) {\n            // reset everything\n            (void 0) /* console.debug */;\n            this._cells.length = 0;\n            // this._nodes.length = 0;\n            // this._itmTmp.viewContainer.clear();\n            // ******** DOM READ ****************\n            this.calcDimensions();\n        }\n        else {\n            (void 0) /* console.debug */;\n        }\n    }\n    /**\n     * @hidden\n     */\n    writeUpdate(needClean) {\n        (void 0) /* console.debug */;\n        const data = this._data;\n        const stopAtHeight = (data.scrollTop + data.renderHeight);\n        data.scrollDiff = SCROLL_DIFFERENCE_MINIMUM + 1;\n        processRecords(stopAtHeight, this._records, this._cells, this._hdrFn, this._ftrFn, this._data);\n        // ******** DOM WRITE ****************\n        this.renderVirtual(needClean);\n    }\n    /**\n     * @hidden\n     */\n    calcDimensions() {\n        calcDimensions(this._data, this._elementRef.nativeElement, this.approxItemWidth, this.approxItemHeight, this.approxHeaderWidth, this.approxHeaderHeight, this.approxFooterWidth, this.approxFooterHeight, this.bufferRatio);\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    renderVirtual(needClean) {\n        this._plt.raf(() => {\n            const nodes = this._nodes;\n            const cells = this._cells;\n            const data = this._data;\n            const records = this._records;\n            if (needClean) {\n                // ******** DOM WRITE ****************\n                updateDimensions(this._plt, nodes, cells, data, true);\n                data.topCell = 0;\n                data.bottomCell = (cells.length - 1);\n            }\n            adjustRendered(cells, data);\n            this._zone.run(() => {\n                populateNodeData(data.topCell, data.bottomCell, true, cells, records, nodes, this._itmTmp.viewContainer, this._itmTmp.templateRef, this._hdrTmp && this._hdrTmp.templateRef, this._ftrTmp && this._ftrTmp.templateRef);\n            });\n            if (needClean) {\n                this._cd.detectChanges();\n            }\n            // at this point, this fn was called from within another\n            // requestAnimationFrame, so the next dom reads/writes within the next frame\n            // wait a frame before trying to read and calculate the dimensions\n            // ******** DOM READ ****************\n            this._dom.read(() => initReadNodes(this._plt, nodes, cells, data));\n            this._dom.write(() => {\n                // update the bound context for each node\n                updateNodeContext(nodes, cells, data);\n                // ******** DOM WRITE ****************\n                this._stepChangeDetection();\n                // ******** DOM WRITE ****************\n                this._stepDOMWrite();\n                // ******** DOM WRITE ****************\n                this._content.imgsUpdate();\n                // First time load\n                if (!this._lastEle) {\n                    // add an element at the end so :last-child css doesn't get messed up\n                    // ******** DOM WRITE ****************\n                    var ele = this._elementRef.nativeElement;\n                    var lastEle = this._renderer.createElement(ele, 'div');\n                    lastEle.className = 'virtual-last';\n                    this._lastEle = true;\n                    // ******** DOM WRITE ****************\n                    this.setElementClass('virtual-scroll', true);\n                    // ******** DOM WRITE ****************\n                    this.setElementClass('virtual-loading', false);\n                }\n                (void 0) /* assert */;\n            });\n        });\n    }\n    /**\n     * @hidden\n     */\n    resize() {\n        // only continue if we've already initialized\n        if (!this._init) {\n            return;\n        }\n        // check if component is rendered in the dom currently\n        if (this._elementRef.nativeElement.offsetParent === null) {\n            return;\n        }\n        (void 0) /* console.debug */;\n        this.calcDimensions();\n        this.writeUpdate(false);\n    }\n    /**\n     * @hidden\n     */\n    _stepDOMWrite() {\n        const cells = this._cells;\n        const nodes = this._nodes;\n        // ******** DOM WRITE ****************\n        writeToNodes(this._plt, nodes, cells, this._recordSize);\n        // ******** DOM WRITE ****************\n        this._setHeight(estimateHeight(this._recordSize, cells[cells.length - 1], this._vHeight, 0.25));\n        // we're done here, good work\n        this._queue = 1 /* NoChanges */;\n    }\n    /**\n     * @hidden\n     */\n    _stepChangeDetection() {\n        // we need to do some change detection in this frame\n        // we've got work painting do, let's throw it in the\n        // domWrite callback so everyone plays nice\n        // ******** DOM WRITE ****************\n        const nodes = this._nodes;\n        for (var i = 0; i < nodes.length; i++) {\n            if (nodes[i].hasChanges) {\n                nodes[i].view.detectChanges();\n            }\n        }\n        // on the next frame we need write to the dom nodes manually\n        this._queue = 3 /* DomWrite */;\n    }\n    /**\n     * @hidden\n     */\n    _stepNoChanges() {\n        const data = this._data;\n        // let's see if we've scroll far enough to require another check\n        const diff = data.scrollDiff = (data.scrollTop - this._lastCheck);\n        if (Math.abs(diff) < SCROLL_DIFFERENCE_MINIMUM) {\n            return;\n        }\n        const cells = this._cells;\n        const nodes = this._nodes;\n        const records = this._records;\n        // don't bother updating if the scrollTop hasn't changed much\n        this._lastCheck = data.scrollTop;\n        if (diff > 0) {\n            // load data we may not have processed yet\n            var stopAtHeight = (data.scrollTop + data.renderHeight);\n            processRecords(stopAtHeight, records, cells, this._hdrFn, this._ftrFn, data);\n        }\n        // ******** DOM READ ****************\n        updateDimensions(this._plt, nodes, cells, data, false);\n        adjustRendered(cells, data);\n        var hasChanges = populateNodeData(data.topCell, data.bottomCell, diff > 0, cells, records, nodes, this._itmTmp.viewContainer, this._itmTmp.templateRef, this._hdrTmp && this._hdrTmp.templateRef, this._ftrTmp && this._ftrTmp.templateRef);\n        if (hasChanges) {\n            // queue making updates in the next frame\n            this._queue = 2 /* ChangeDetection */;\n            // update the bound context for each node\n            updateNodeContext(nodes, cells, data);\n        }\n    }\n    /**\n     * @hidden\n     */\n    scrollUpdate(ev) {\n        // ensure no empty are processed\n        if (!ev) {\n            return;\n        }\n        // set the scroll top from the scroll event\n        this._data.scrollTop = ev.scrollTop;\n        // there is a queue system so that we can\n        // spread out the work over multiple frames\n        const queue = this._queue;\n        if (queue === 1 /* NoChanges */) {\n            // no dom writes or change detection to take care of\n            this._stepNoChanges();\n        }\n        else if (queue === 2 /* ChangeDetection */) {\n            this._dom.write(() => this._stepChangeDetection());\n        }\n        else {\n            (void 0) /* assert */;\n            // there are DOM writes we need to take care of in this frame\n            this._dom.write(() => this._stepDOMWrite());\n        }\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    scrollEnd() {\n        // ******** DOM READ ****************\n        updateDimensions(this._plt, this._nodes, this._cells, this._data, false);\n        adjustRendered(this._cells, this._data);\n        populateNodeData(this._data.topCell, this._data.bottomCell, true, this._cells, this._records, this._nodes, this._itmTmp.viewContainer, this._itmTmp.templateRef, this._hdrTmp && this._hdrTmp.templateRef, this._ftrTmp && this._ftrTmp.templateRef);\n        // ******** DOM WRITE ***************\n        this._dom.write(() => {\n            // update the bound context for each node\n            updateNodeContext(this._nodes, this._cells, this._data);\n            // ******** DOM WRITE ***************\n            this._stepChangeDetection();\n            // ******** DOM WRITE ****************\n            this._stepDOMWrite();\n        });\n    }\n    /**\n     * @hidden\n     * NO DOM\n     */\n    _listeners() {\n        (void 0) /* assert */;\n        if (!this._scrollSub) {\n            if (this._config.getBoolean('virtualScrollEventAssist')) {\n                // use JS scrolling for iOS UIWebView\n                // goal is to completely remove this when iOS\n                // fully supports scroll events\n                // listen to JS scroll events\n                this._content.enableJsScroll();\n            }\n            this._resizeSub = this._plt.resize.subscribe(this.resize.bind(this));\n            this._scrollSub = this._content.ionScroll.subscribe(this.scrollUpdate.bind(this));\n            this._scrollEndSub = this._content.ionScrollEnd.subscribe(this.scrollEnd.bind(this));\n        }\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    _setHeight(newVirtualHeight) {\n        if (newVirtualHeight !== this._vHeight) {\n            // ******** DOM WRITE ****************\n            this._renderer.setElementStyle(this._elementRef.nativeElement, 'height', newVirtualHeight > 0 ? newVirtualHeight + 'px' : '');\n            this._vHeight = newVirtualHeight;\n            (void 0) /* console.debug */;\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n        (void 0) /* assert */;\n        if (!this.approxItemHeight) {\n            this.approxItemHeight = '40px';\n            console.warn('Virtual Scroll: Please provide an \"approxItemHeight\" input to ensure proper virtual scroll rendering');\n        }\n    }\n    /**\n     * @hidden\n     */\n    setElementClass(className, add) {\n        this._renderer.setElementClass(this._elementRef.nativeElement, className, add);\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this._resizeSub && this._resizeSub.unsubscribe();\n        this._scrollSub && this._scrollSub.unsubscribe();\n        this._scrollEndSub && this._scrollEndSub.unsubscribe();\n        this._resizeSub = this._scrollEndSub = this._scrollSub = null;\n        this._hdrFn = this._ftrFn = this._records = this._cells = this._nodes = this._data = null;\n    }\n}\nVirtualScroll.decorators = [\n    { type: Directive, args: [{\n                selector: '[virtualScroll]'\n            },] },\n];\n/** @nocollapse */\nVirtualScroll.ctorParameters = () => [\n    { type: IterableDiffers, },\n    { type: ElementRef, },\n    { type: Renderer, },\n    { type: NgZone, },\n    { type: ChangeDetectorRef, },\n    { type: Content, },\n    { type: Platform, },\n    { type: ViewController, },\n    { type: Config, },\n    { type: DomController, },\n];\nVirtualScroll.propDecorators = {\n    '_itmTmp': [{ type: ContentChild, args: [VirtualItem,] },],\n    '_hdrTmp': [{ type: ContentChild, args: [VirtualHeader,] },],\n    '_ftrTmp': [{ type: ContentChild, args: [VirtualFooter,] },],\n    'virtualScroll': [{ type: Input },],\n    'bufferRatio': [{ type: Input },],\n    'approxItemWidth': [{ type: Input },],\n    'approxItemHeight': [{ type: Input },],\n    'approxHeaderWidth': [{ type: Input },],\n    'approxHeaderHeight': [{ type: Input },],\n    'approxFooterWidth': [{ type: Input },],\n    'approxFooterHeight': [{ type: Input },],\n    'headerFn': [{ type: Input },],\n    'footerFn': [{ type: Input },],\n    'virtualTrackBy': [{ type: Input },],\n};\nconst SCROLL_DIFFERENCE_MINIMUM = 40;\n"]}