{"version":3,"file":"content.js","sources":["content.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;iDAkBE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, NgZone, Optional, Output, Renderer, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { App } from '../app/app';\nimport { Config } from '../../config/config';\nimport { DomController } from '../../platform/dom-controller';\nimport { Ion } from '../ion';\nimport { isTabs } from '../../navigation/nav-util';\nimport { isTrueProperty, removeArrayItem } from '../../util/util';\nimport { Keyboard } from '../../platform/keyboard';\nimport { NavController } from '../../navigation/nav-controller';\nimport { Platform } from '../../platform/platform';\nimport { ScrollView } from '../../util/scroll-view';\nimport { ViewController } from '../../navigation/view-controller';\nexport class EventEmitterProxy extends EventEmitter {\n    subscribe(generatorOrNext, error, complete) {\n        this.onSubscribe();\n        return super.subscribe(generatorOrNext, error, complete);\n    }\n}\n/**\n * @name Content\n * @description\n * The Content component provides an easy to use content area with\n * some useful methods to control the scrollable area. There should\n * only be one content in a single view component. If additional scrollable\n * elements are needed, use [ionScroll](../../scroll/Scroll).\n *\n *\n * The content area can also implement pull-to-refresh with the\n * [Refresher](../../refresher/Refresher) component.\n *\n * @usage\n * ```html\n * <ion-content>\n *   Add your content here!\n * </ion-content>\n * ```\n *\n * To get a reference to the content component from a Page's logic,\n * you can use Angular's `@ViewChild` annotation:\n *\n * ```ts\n * import { Component, ViewChild } from '@angular/core';\n * import { Content } from 'ionic-angular';\n *\n * @Component({...})\n * export class MyPage{\n *   @ViewChild(Content) content: Content;\n *\n *   scrollToTop() {\n *     this.content.scrollToTop();\n *   }\n * }\n * ```\n *\n * @advanced\n *\n * ### Scroll Events\n *\n * Scroll events happen outside of Angular's Zones. This is for performance reasons. So\n * if you're trying to bind a value to any scroll event, it will need to be wrapped in\n * a `zone.run()`\n *\n * ```ts\n * import { Component, NgZone } from '@angular/core';\n * @Component({\n *   template: `\n *     <ion-header>\n *       <ion-navbar>\n *         <ion-title>{{scrollAmount}}</ion-title>\n *       </ion-navbar>\n *     </ion-header>\n *     <ion-content (ionScroll)=\"scrollHandler($event)\">\n *        <p> Some realllllllly long content </p>\n *     </ion-content>\n * `})\n * class E2EPage {\n *  public scrollAmount = 0;\n *  constructor( public zone: NgZone){}\n *  scrollHandler(event) {\n *    console.log(`ScrollEvent: ${event}`)\n *    this.zone.run(()=>{\n *      // since scrollAmount is data-binded,\n *      // the update needs to happen in zone\n *      this.scrollAmount++\n *    })\n *  }\n * }\n * ```\n *\n * This goes for any scroll event, not just `ionScroll`.\n *\n * ### Resizing the content\n *\n * If the height of `ion-header`, `ion-footer` or `ion-tabbar`\n * changes dynamically, `content.resize()` has to be called in order to update the\n * layout of `Content`.\n *\n *\n * ```ts\n * @Component({\n *   template: `\n *     <ion-header>\n *       <ion-navbar>\n *         <ion-title>Main Navbar</ion-title>\n *       </ion-navbar>\n *       <ion-toolbar *ngIf=\"showToolbar\">\n *         <ion-title>Dynamic Toolbar</ion-title>\n *       </ion-toolbar>\n *     </ion-header>\n *     <ion-content>\n *       <button ion-button (click)=\"toggleToolbar()\">Toggle Toolbar</button>\n *     </ion-content>\n * `})\n *\n * class E2EPage {\n *   @ViewChild(Content) content: Content;\n *   showToolbar: boolean = false;\n *\n *   toggleToolbar() {\n *     this.showToolbar = !this.showToolbar;\n *     this.content.resize();\n *   }\n * }\n * ```\n *\n *\n * Scroll to a specific position\n *\n * ```ts\n * import { Component, ViewChild } from '@angular/core';\n * import { Content } from 'ionic-angular';\n *\n * @Component({\n *   template: `<ion-content>\n *                <button ion-button (click)=\"scrollTo()\">Down 500px</button>\n *              </ion-content>`\n * )}\n * export class MyPage{\n *   @ViewChild(Content) content: Content;\n *\n *   scrollTo() {\n *     // set the scrollLeft to 0px, and scrollTop to 500px\n *     // the scroll duration should take 200ms\n *     this.content.scrollTo(0, 500, 200);\n *   }\n * }\n * ```\n *\n */\nexport class Content extends Ion {\n    constructor(config, _plt, _dom, elementRef, renderer, _app, _keyboard, _zone, viewCtrl, navCtrl) {\n        super(config, elementRef, renderer, 'content');\n        this._plt = _plt;\n        this._dom = _dom;\n        this._app = _app;\n        this._keyboard = _keyboard;\n        this._zone = _zone;\n        /** @internal */\n        this._scrollPadding = 0;\n        /** @internal */\n        this._inputPolling = false;\n        /** @internal */\n        this._hasRefresher = false;\n        /** @internal */\n        this._imgs = [];\n        /** @internal */\n        this._scrollDownOnLoad = false;\n        /**\n         * @output {ScrollEvent} Emitted when the scrolling first starts.\n         */\n        this.ionScrollStart = new EventEmitterProxy();\n        /**\n         * @output {ScrollEvent} Emitted on every scroll event.\n         */\n        this.ionScroll = new EventEmitterProxy();\n        /**\n         * @output {ScrollEvent} Emitted when scrolling ends.\n         */\n        this.ionScrollEnd = new EventEmitterProxy();\n        const enableScrollListener = () => this._scroll.enableEvents();\n        this.ionScroll.onSubscribe = enableScrollListener;\n        this.ionScrollStart.onSubscribe = enableScrollListener;\n        this.ionScrollEnd.onSubscribe = enableScrollListener;\n        this.statusbarPadding = config.getBoolean('statusbarPadding', false);\n        this._imgReqBfr = config.getNumber('imgRequestBuffer', 1400);\n        this._imgRndBfr = config.getNumber('imgRenderBuffer', 400);\n        this._imgVelMax = config.getNumber('imgVelocityMax', 3);\n        this._scroll = new ScrollView(_app, _plt, _dom);\n        while (navCtrl) {\n            if (isTabs(navCtrl)) {\n                this._tabs = navCtrl;\n                break;\n            }\n            navCtrl = navCtrl.parent;\n        }\n        if (viewCtrl) {\n            this._viewCtrl = viewCtrl;\n            // content has a view controller\n            viewCtrl._setIONContent(this);\n            viewCtrl._setIONContentRef(elementRef);\n            this._viewCtrlReadSub = viewCtrl.readReady.subscribe(() => {\n                this._viewCtrlReadSub.unsubscribe();\n                this._readDimensions();\n            });\n            this._viewCtrlWriteSub = viewCtrl.writeReady.subscribe(() => {\n                this._viewCtrlWriteSub.unsubscribe();\n                this._writeDimensions();\n            });\n        }\n        else {\n            // content does not have a view controller\n            _dom.read(this._readDimensions.bind(this));\n            _dom.write(this._writeDimensions.bind(this));\n        }\n    }\n    /**\n     * Content height of the viewable area. This does not include content\n     * which is outside the overflow area, or content area which is under\n     * headers and footers. Read-only.\n     *\n     * @return {number}\n     */\n    get contentHeight() {\n        return this._scroll.ev.contentHeight;\n    }\n    /**\n     * Content width including content which is not visible on the screen\n     * due to overflow. Read-only.\n     *\n     * @return {number}\n     */\n    get contentWidth() {\n        return this._scroll.ev.contentWidth;\n    }\n    /**\n     * Content height including content which is not visible on the screen\n     * due to overflow. Read-only.\n     *\n     * @return {number}\n     */\n    get scrollHeight() {\n        return this._scroll.ev.scrollHeight;\n    }\n    /**\n     * Content width including content which is not visible due to\n     * overflow. Read-only.\n     *\n     * @return {number}\n     */\n    get scrollWidth() {\n        return this._scroll.ev.scrollWidth;\n    }\n    /**\n     * The distance of the content's top to its topmost visible content.\n     *\n     * @return {number}\n     */\n    get scrollTop() {\n        return this._scroll.ev.scrollTop;\n    }\n    /**\n     * @param {number} top\n     */\n    set scrollTop(top) {\n        this._scroll.setTop(top);\n    }\n    /**\n     * The distance of the content's left to its leftmost visible content.\n     *\n     * @return {number}\n     */\n    get scrollLeft() {\n        return this._scroll.ev.scrollLeft;\n    }\n    /**\n     * @param {number} top\n     */\n    set scrollLeft(top) {\n        this._scroll.setLeft(top);\n    }\n    /**\n     * If the content is actively scrolling or not.\n     *\n     * @return {boolean}\n     */\n    get isScrolling() {\n        return this._scroll.isScrolling;\n    }\n    /**\n     * The current, or last known, vertical scroll direction. Possible\n     * string values include `down` and `up`.\n     *\n     * @return {string}\n     */\n    get directionY() {\n        return this._scroll.ev.directionY;\n    }\n    /**\n     * The current, or last known, horizontal scroll direction. Possible\n     * string values include `right` and `left`.\n     *\n     * @return {string}\n     */\n    get directionX() {\n        return this._scroll.ev.directionX;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterViewInit() {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        const scroll = this._scroll;\n        scroll.ev.fixedElement = this.getFixedElement();\n        scroll.ev.scrollElement = this.getScrollElement();\n        // subscribe to the scroll start\n        scroll.onScrollStart = (ev) => {\n            this.ionScrollStart.emit(ev);\n        };\n        // subscribe to every scroll move\n        scroll.onScroll = (ev) => {\n            // emit to all of our other friends things be scrolling\n            this.ionScroll.emit(ev);\n            this.imgsUpdate();\n        };\n        // subscribe to the scroll end\n        scroll.onScrollEnd = (ev) => {\n            this.ionScrollEnd.emit(ev);\n            this.imgsUpdate();\n        };\n    }\n    /**\n     * @hidden\n     */\n    enableJsScroll() {\n        this._scroll.enableJsScroll(this._cTop, this._cBottom);\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this._scLsn && this._scLsn();\n        this._viewCtrlReadSub && this._viewCtrlReadSub.unsubscribe();\n        this._viewCtrlWriteSub && this._viewCtrlWriteSub.unsubscribe();\n        this._viewCtrlReadSub = this._viewCtrlWriteSub = null;\n        this._scroll && this._scroll.destroy();\n        this._footerEle = this._scLsn = this._scroll = null;\n    }\n    /**\n     * @hidden\n     */\n    getScrollElement() {\n        return this._scrollContent.nativeElement;\n    }\n    /**\n     * @private\n     */\n    getFixedElement() {\n        return this._fixedContent.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n    onScrollElementTransitionEnd(callback) {\n        this._plt.transitionEnd(this.getScrollElement(), callback);\n    }\n    /**\n     * Scroll to the specified position.\n     *\n     * @param {number} x  The x-value to scroll to.\n     * @param {number} y  The y-value to scroll to.\n     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.\n     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.\n     */\n    scrollTo(x, y, duration = 300, done) {\n        (void 0) /* console.debug */;\n        return this._scroll.scrollTo(x, y, duration, done);\n    }\n    /**\n     * Scroll to the top of the content component.\n     *\n     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.\n     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.\n     */\n    scrollToTop(duration = 300) {\n        (void 0) /* console.debug */;\n        return this._scroll.scrollToTop(duration);\n    }\n    /**\n     * Scroll to the bottom of the content component.\n     *\n     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.\n     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.\n     */\n    scrollToBottom(duration = 300) {\n        (void 0) /* console.debug */;\n        return this._scroll.scrollToBottom(duration);\n    }\n    /**\n     * @input {boolean} If true, the content will scroll behind the headers\n     * and footers. This effect can easily be seen by setting the toolbar\n     * to transparent.\n     */\n    get fullscreen() {\n        return this._fullscreen;\n    }\n    set fullscreen(val) {\n        this._fullscreen = isTrueProperty(val);\n    }\n    /**\n     * @input {boolean} If true, the content will scroll down on load.\n     */\n    get scrollDownOnLoad() {\n        return this._scrollDownOnLoad;\n    }\n    set scrollDownOnLoad(val) {\n        this._scrollDownOnLoad = isTrueProperty(val);\n    }\n    /**\n     * @private\n     */\n    addImg(img) {\n        this._imgs.push(img);\n    }\n    /**\n     * @hidden\n     */\n    removeImg(img) {\n        removeArrayItem(this._imgs, img);\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    setScrollElementStyle(prop, val) {\n        const scrollEle = this.getScrollElement();\n        if (scrollEle) {\n            this._dom.write(() => {\n                scrollEle.style[prop] = val;\n            });\n        }\n    }\n    /**\n     * Returns the content and scroll elements' dimensions.\n     * @returns {object} dimensions  The content and scroll elements' dimensions\n     * {number} dimensions.contentHeight  content offsetHeight\n     * {number} dimensions.contentTop  content offsetTop\n     * {number} dimensions.contentBottom  content offsetTop+offsetHeight\n     * {number} dimensions.contentWidth  content offsetWidth\n     * {number} dimensions.contentLeft  content offsetLeft\n     * {number} dimensions.contentRight  content offsetLeft + offsetWidth\n     * {number} dimensions.scrollHeight  scroll scrollHeight\n     * {number} dimensions.scrollTop  scroll scrollTop\n     * {number} dimensions.scrollBottom  scroll scrollTop + scrollHeight\n     * {number} dimensions.scrollWidth  scroll scrollWidth\n     * {number} dimensions.scrollLeft  scroll scrollLeft\n     * {number} dimensions.scrollRight  scroll scrollLeft + scrollWidth\n     */\n    getContentDimensions() {\n        const scrollEle = this.getScrollElement();\n        const parentElement = scrollEle.parentElement;\n        return {\n            contentHeight: parentElement.offsetHeight - this._cTop - this._cBottom,\n            contentTop: this._cTop,\n            contentBottom: this._cBottom,\n            contentWidth: parentElement.offsetWidth,\n            contentLeft: parentElement.offsetLeft,\n            scrollHeight: scrollEle.scrollHeight,\n            scrollTop: scrollEle.scrollTop,\n            scrollWidth: scrollEle.scrollWidth,\n            scrollLeft: scrollEle.scrollLeft,\n        };\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     * Adds padding to the bottom of the scroll element when the keyboard is open\n     * so content below the keyboard can be scrolled into view.\n     */\n    addScrollPadding(newPadding) {\n        (void 0) /* assert */;\n        if (newPadding === 0) {\n            this._inputPolling = false;\n            this._scrollPadding = -1;\n        }\n        if (newPadding > this._scrollPadding) {\n            (void 0) /* console.debug */;\n            this._scrollPadding = newPadding;\n            var scrollEle = this.getScrollElement();\n            if (scrollEle) {\n                this._dom.write(() => {\n                    scrollEle.style.paddingBottom = (newPadding > 0) ? newPadding + 'px' : '';\n                });\n            }\n        }\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    clearScrollPaddingFocusOut() {\n        if (!this._inputPolling) {\n            (void 0) /* console.debug */;\n            this._inputPolling = true;\n            this._keyboard.onClose(() => {\n                (void 0) /* console.debug */;\n                this.addScrollPadding(0);\n            }, 200, 3000);\n        }\n    }\n    /**\n     * Tell the content to recalculate its dimensions. This should be called\n     * after dynamically adding/removing headers, footers, or tabs.\n     */\n    resize() {\n        this._dom.read(this._readDimensions.bind(this));\n        this._dom.write(this._writeDimensions.bind(this));\n    }\n    /**\n     * @hidden\n     * DOM READ\n     */\n    _readDimensions() {\n        const cachePaddingTop = this._pTop;\n        const cachePaddingRight = this._pRight;\n        const cachePaddingBottom = this._pBottom;\n        const cachePaddingLeft = this._pLeft;\n        const cacheHeaderHeight = this._hdrHeight;\n        const cacheFooterHeight = this._ftrHeight;\n        const cacheTabsPlacement = this._tabsPlacement;\n        let tabsTop = 0;\n        let scrollEvent;\n        this._pTop = 0;\n        this._pRight = 0;\n        this._pBottom = 0;\n        this._pLeft = 0;\n        this._hdrHeight = 0;\n        this._ftrHeight = 0;\n        this._tabsPlacement = null;\n        this._tTop = 0;\n        this._fTop = 0;\n        this._fBottom = 0;\n        // In certain cases this._scroll is undefined\n        // if that is the case then we should just return\n        if (!this._scroll) {\n            return;\n        }\n        scrollEvent = this._scroll.ev;\n        let ele = this.getNativeElement();\n        if (!ele) {\n            (void 0) /* assert */;\n            return;\n        }\n        let computedStyle;\n        let tagName;\n        let parentEle = ele.parentElement;\n        let children = parentEle.children;\n        for (var i = children.length - 1; i >= 0; i--) {\n            ele = children[i];\n            tagName = ele.tagName;\n            if (tagName === 'ION-CONTENT') {\n                scrollEvent.contentElement = ele;\n                if (this._fullscreen) {\n                    // ******** DOM READ ****************\n                    computedStyle = getComputedStyle(ele);\n                    this._pTop = parsePxUnit(computedStyle.paddingTop);\n                    this._pBottom = parsePxUnit(computedStyle.paddingBottom);\n                    this._pRight = parsePxUnit(computedStyle.paddingRight);\n                    this._pLeft = parsePxUnit(computedStyle.paddingLeft);\n                }\n            }\n            else if (tagName === 'ION-HEADER') {\n                scrollEvent.headerElement = ele;\n                // ******** DOM READ ****************\n                this._hdrHeight = ele.clientHeight;\n            }\n            else if (tagName === 'ION-FOOTER') {\n                scrollEvent.footerElement = ele;\n                // ******** DOM READ ****************\n                this._ftrHeight = ele.clientHeight;\n                this._footerEle = ele;\n            }\n        }\n        ele = parentEle;\n        let tabbarEle;\n        while (ele && ele.tagName !== 'ION-MODAL' && !ele.classList.contains('tab-subpage')) {\n            if (ele.tagName === 'ION-TABS') {\n                tabbarEle = ele.firstElementChild;\n                // ******** DOM READ ****************\n                this._tabbarHeight = tabbarEle.clientHeight;\n                if (this._tabsPlacement === null) {\n                    // this is the first tabbar found, remember it's position\n                    this._tabsPlacement = ele.getAttribute('tabsplacement');\n                }\n            }\n            ele = ele.parentElement;\n        }\n        // Tabs top\n        if (this._tabs && this._tabsPlacement === 'top') {\n            this._tTop = this._hdrHeight;\n            tabsTop = this._tabs._top;\n        }\n        // Toolbar height\n        this._cTop = this._hdrHeight;\n        this._cBottom = this._ftrHeight;\n        // Tabs height\n        if (this._tabsPlacement === 'top') {\n            this._cTop += this._tabbarHeight;\n        }\n        else if (this._tabsPlacement === 'bottom') {\n            this._cBottom += this._tabbarHeight;\n        }\n        // Refresher uses a border which should be hidden unless pulled\n        if (this._hasRefresher) {\n            this._cTop -= 1;\n        }\n        // Fixed content shouldn't include content padding\n        this._fTop = this._cTop;\n        this._fBottom = this._cBottom;\n        // Handle fullscreen viewport (padding vs margin)\n        if (this._fullscreen) {\n            this._cTop += this._pTop;\n            this._cBottom += this._pBottom;\n        }\n        // ******** DOM READ ****************\n        const contentDimensions = this.getContentDimensions();\n        scrollEvent.scrollHeight = contentDimensions.scrollHeight;\n        scrollEvent.scrollWidth = contentDimensions.scrollWidth;\n        scrollEvent.contentHeight = contentDimensions.contentHeight;\n        scrollEvent.contentWidth = contentDimensions.contentWidth;\n        scrollEvent.contentTop = contentDimensions.contentTop;\n        scrollEvent.contentBottom = contentDimensions.contentBottom;\n        this._dirty = (cachePaddingTop !== this._pTop ||\n            cachePaddingBottom !== this._pBottom ||\n            cachePaddingLeft !== this._pLeft ||\n            cachePaddingRight !== this._pRight ||\n            cacheHeaderHeight !== this._hdrHeight ||\n            cacheFooterHeight !== this._ftrHeight ||\n            cacheTabsPlacement !== this._tabsPlacement ||\n            tabsTop !== this._tTop ||\n            this._cTop !== this.contentTop ||\n            this._cBottom !== this.contentBottom);\n        this._scroll.init(this.getScrollElement(), this._cTop, this._cBottom);\n        // initial imgs refresh\n        this.imgsUpdate();\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    _writeDimensions() {\n        if (!this._dirty) {\n            (void 0) /* console.debug */;\n            return;\n        }\n        const scrollEle = this.getScrollElement();\n        if (!scrollEle) {\n            (void 0) /* assert */;\n            return;\n        }\n        const fixedEle = this.getFixedElement();\n        if (!fixedEle) {\n            (void 0) /* assert */;\n            return;\n        }\n        // Tabs height\n        if (this._tabsPlacement === 'bottom' && this._cBottom > 0 && this._footerEle) {\n            var footerPos = this._cBottom - this._ftrHeight;\n            (void 0) /* assert */;\n            // ******** DOM WRITE ****************\n            this._footerEle.style.bottom = cssFormat(footerPos);\n        }\n        // Handle fullscreen viewport (padding vs margin)\n        let topProperty = 'marginTop';\n        let bottomProperty = 'marginBottom';\n        let fixedTop = this._fTop;\n        let fixedBottom = this._fBottom;\n        if (this._fullscreen) {\n            (void 0) /* assert */;\n            (void 0) /* assert */;\n            // adjust the content with padding, allowing content to scroll under headers/footers\n            // however, on iOS you cannot control the margins of the scrollbar (last tested iOS9.2)\n            // only add inline padding styles if the computed padding value, which would\n            // have come from the app's css, is different than the new padding value\n            topProperty = 'paddingTop';\n            bottomProperty = 'paddingBottom';\n        }\n        // Only update top margin if value changed\n        if (this._cTop !== this.contentTop) {\n            (void 0) /* assert */;\n            (void 0) /* assert */;\n            // ******** DOM WRITE ****************\n            scrollEle.style[topProperty] = cssFormat(this._cTop);\n            // ******** DOM WRITE ****************\n            fixedEle.style.marginTop = cssFormat(fixedTop);\n            this.contentTop = this._cTop;\n        }\n        // Only update bottom margin if value changed\n        if (this._cBottom !== this.contentBottom) {\n            (void 0) /* assert */;\n            (void 0) /* assert */;\n            // ******** DOM WRITE ****************\n            scrollEle.style[bottomProperty] = cssFormat(this._cBottom);\n            // ******** DOM WRITE ****************\n            fixedEle.style.marginBottom = cssFormat(fixedBottom);\n            this.contentBottom = this._cBottom;\n        }\n        if (this._tabsPlacement !== null && this._tabs) {\n            // set the position of the tabbar\n            if (this._tabsPlacement === 'top') {\n                // ******** DOM WRITE ****************\n                this._tabs.setTabbarPosition(this._tTop, -1);\n            }\n            else {\n                (void 0) /* assert */;\n                // ******** DOM WRITE ****************\n                this._tabs.setTabbarPosition(-1, 0);\n            }\n        }\n        // Scroll the page all the way down after setting dimensions\n        if (this._scrollDownOnLoad) {\n            this.scrollToBottom(0);\n            this._scrollDownOnLoad = false;\n        }\n    }\n    /**\n     * @hidden\n     */\n    imgsUpdate() {\n        if (this._scroll.initialized && this._imgs.length && this.isImgsUpdatable()) {\n            updateImgs(this._imgs, this.scrollTop, this.contentHeight, this.directionY, this._imgReqBfr, this._imgRndBfr);\n        }\n    }\n    /**\n     * @hidden\n     */\n    isImgsUpdatable() {\n        // an image is only \"updatable\" if the content isn't scrolling too fast\n        // if scroll speed is above the maximum velocity, then let current\n        // requests finish, but do not start new requets or render anything\n        // if scroll speed is below the maximum velocity, then it's ok\n        // to start new requests and render images\n        return Math.abs(this._scroll.ev.velocityY) < this._imgVelMax;\n    }\n}\nContent.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-content',\n                template: '<div class=\"fixed-content\" #fixedContent>' +\n                    '<ng-content select=\"[ion-fixed],ion-fab\"></ng-content>' +\n                    '</div>' +\n                    '<div class=\"scroll-content\" #scrollContent>' +\n                    '<ng-content></ng-content>' +\n                    '</div>' +\n                    '<ng-content select=\"ion-refresher\"></ng-content>',\n                host: {\n                    '[class.statusbar-padding]': 'statusbarPadding',\n                    '[class.has-refresher]': '_hasRefresher'\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None\n            },] },\n];\n/** @nocollapse */\nContent.ctorParameters = () => [\n    { type: Config, },\n    { type: Platform, },\n    { type: DomController, },\n    { type: ElementRef, },\n    { type: Renderer, },\n    { type: App, },\n    { type: Keyboard, },\n    { type: NgZone, },\n    { type: ViewController, decorators: [{ type: Optional },] },\n    { type: NavController, decorators: [{ type: Optional },] },\n];\nContent.propDecorators = {\n    '_fixedContent': [{ type: ViewChild, args: ['fixedContent', { read: ElementRef },] },],\n    '_scrollContent': [{ type: ViewChild, args: ['scrollContent', { read: ElementRef },] },],\n    'ionScrollStart': [{ type: Output },],\n    'ionScroll': [{ type: Output },],\n    'ionScrollEnd': [{ type: Output },],\n    'fullscreen': [{ type: Input },],\n    'scrollDownOnLoad': [{ type: Input },],\n};\nexport function updateImgs(imgs, viewableTop, contentHeight, scrollDirectionY, requestableBuffer, renderableBuffer) {\n    // ok, so it's time to see which images, if any, should be requested and rendered\n    // ultimately, if we're scrolling fast then don't bother requesting or rendering\n    // when scrolling is done, then it needs to do a check to see which images are\n    // important to request and render, and which image requests should be aborted.\n    // Additionally, images which are not near the viewable area should not be\n    // rendered at all in order to save browser resources.\n    const viewableBottom = (viewableTop + contentHeight);\n    const priority1 = [];\n    const priority2 = [];\n    let img;\n    // all images should be paused\n    for (var i = 0, ilen = imgs.length; i < ilen; i++) {\n        img = imgs[i];\n        if (scrollDirectionY === 'up') {\n            // scrolling up\n            if (img.top < viewableBottom && img.bottom > viewableTop - renderableBuffer) {\n                // scrolling up, img is within viewable area\n                // or about to be viewable area\n                img.canRequest = img.canRender = true;\n                priority1.push(img);\n                continue;\n            }\n            if (img.bottom <= viewableTop && img.bottom > viewableTop - requestableBuffer) {\n                // scrolling up, img is within requestable area\n                img.canRequest = true;\n                img.canRender = false;\n                priority2.push(img);\n                continue;\n            }\n            if (img.top >= viewableBottom && img.top < viewableBottom + renderableBuffer) {\n                // scrolling up, img below viewable area\n                // but it's still within renderable area\n                // don't allow a reset\n                img.canRequest = img.canRender = false;\n                continue;\n            }\n        }\n        else {\n            // scrolling down\n            if (img.bottom > viewableTop && img.top < viewableBottom + renderableBuffer) {\n                // scrolling down, img is within viewable area\n                // or about to be viewable area\n                img.canRequest = img.canRender = true;\n                priority1.push(img);\n                continue;\n            }\n            if (img.top >= viewableBottom && img.top < viewableBottom + requestableBuffer) {\n                // scrolling down, img is within requestable area\n                img.canRequest = true;\n                img.canRender = false;\n                priority2.push(img);\n                continue;\n            }\n            if (img.bottom <= viewableTop && img.bottom > viewableTop - renderableBuffer) {\n                // scrolling down, img above viewable area\n                // but it's still within renderable area\n                // don't allow a reset\n                img.canRequest = img.canRender = false;\n                continue;\n            }\n        }\n        img.canRequest = img.canRender = false;\n        img.reset();\n    }\n    // update all imgs which are viewable\n    priority1.sort(sortTopToBottom).forEach(i => i.update());\n    if (scrollDirectionY === 'up') {\n        // scrolling up\n        priority2.sort(sortTopToBottom).reverse().forEach(i => i.update());\n    }\n    else {\n        // scrolling down\n        priority2.sort(sortTopToBottom).forEach(i => i.update());\n    }\n}\nfunction sortTopToBottom(a, b) {\n    if (a.top < b.top) {\n        return -1;\n    }\n    if (a.top > b.top) {\n        return 1;\n    }\n    return 0;\n}\nfunction parsePxUnit(val) {\n    return (val.indexOf('px') > 0) ? parseInt(val, 10) : 0;\n}\nfunction cssFormat(val) {\n    return (val > 0 ? val + 'px' : '');\n}\n"]}