{"version":3,"file":"datetime.js","sources":["datetime.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;yEAoBE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { Component, ElementRef, EventEmitter, HostListener, Input, Optional, Output, Renderer, ViewEncapsulation } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Config } from '../../config/config';\nimport { PickerController } from '../picker/picker-controller';\nimport { Form } from '../../util/form';\nimport { BaseInput } from '../../util/base-input';\nimport { Item } from '../item/item';\nimport { clamp, isArray, isBlank, isObject, isPresent, isString } from '../../util/util';\nimport { compareDates, convertDataToISO, convertFormatToKey, dateDataSortValue, dateSortValue, dateValueRange, daysInMonth, getValueFromFormat, parseDate, parseTemplate, renderDateTime, renderTextFormat, updateDate, } from '../../util/datetime-util';\n/**\n * @name DateTime\n * @description\n * The DateTime component is used to present an interface which makes it easy for\n * users to select dates and times. Tapping on `<ion-datetime>` will display a picker\n * interface that slides up from the bottom of the page. The picker then displays\n * scrollable columns that can be used to individually select years, months, days,\n * hours and minute values. The DateTime component is similar to the native\n * `<input type=\"datetime-local\">` element, however, Ionic's DateTime component makes\n * it easy to display the date and time in a preferred format, and manage the datetime\n * values.\n *\n * ```html\n * <ion-item>\n *   <ion-label>Date</ion-label>\n *   <ion-datetime displayFormat=\"MM/DD/YYYY\" [(ngModel)]=\"myDate\"></ion-datetime>\n * </ion-item>\n * ```\n *\n *\n * ## Display and Picker Formats\n *\n * The DateTime component displays the values in two places: in the `<ion-datetime>`\n * component, and in the interface that is presented from the bottom of the screen.\n * The following chart lists all of the formats that can be used.\n *\n * | Format  | Description                    | Example                 |\n * |---------|--------------------------------|-------------------------|\n * | `YYYY`  | Year, 4 digits                 | `2018`                  |\n * | `YY`    | Year, 2 digits                 | `18`                    |\n * | `M`     | Month                          | `1` ... `12`            |\n * | `MM`    | Month, leading zero            | `01` ... `12`           |\n * | `MMM`   | Month, short name              | `Jan`                   |\n * | `MMMM`  | Month, full name               | `January`               |\n * | `D`     | Day                            | `1` ... `31`            |\n * | `DD`    | Day, leading zero              | `01` ... `31`           |\n * | `DDD`   | Day, short name                | `Fri`                   |\n * | `DDDD`  | Day, full name                 | `Friday`                |\n * | `H`     | Hour, 24-hour                  | `0` ... `23`            |\n * | `HH`    | Hour, 24-hour, leading zero    | `00` ... `23`           |\n * | `h`     | Hour, 12-hour                  | `1` ... `12`            |\n * | `hh`    | Hour, 12-hour, leading zero    | `01` ... `12`           |\n * | `a`     | 12-hour time period, lowercase | `am` `pm`               |\n * | `A`     | 12-hour time period, uppercase | `AM` `PM`               |\n * | `m`     | Minute                         | `1` ... `59`            |\n * | `mm`    | Minute, leading zero           | `01` ... `59`           |\n * | `s`     | Second                         | `1` ... `59`            |\n * | `ss`    | Second, leading zero           | `01` ... `59`           |\n * | `Z`     | UTC Timezone Offset            | `Z or +HH:mm or -HH:mm` |\n *\n * **Important**: See the [Month Names and Day of the Week Names](#month-names-and-day-of-the-week-names)\n * section below on how to use different names for the month and day.\n *\n * ### Display Format\n *\n * The `displayFormat` input property specifies how a datetime's value should be\n * printed, as formatted text, within the `ion-datetime` component.\n *\n * In the following example, the display in the `<ion-datetime>` will use the\n * month's short name, the numerical day with a leading zero, a comma and the\n * four-digit year. In addition to the date, it will display the time with the hours\n * in the 24-hour format and the minutes. Any character can be used as a separator.\n * An example display using this format is: `Jun 17, 2005 11:06`.\n *\n * ```html\n * <ion-item>\n *   <ion-label>Date</ion-label>\n *   <ion-datetime displayFormat=\"MMM DD, YYYY HH:mm\" [(ngModel)]=\"myDate\"></ion-datetime>\n * </ion-item>\n * ```\n *\n * ### Picker Format\n *\n * The `pickerFormat` input property determines which columns should be shown in the\n * interface, the order of the columns, and which format to use within each column.\n * If the `pickerFormat` input is not provided then it will default to the `displayFormat`.\n *\n * In the following example, the display in the `<ion-datetime>` will use the\n * `MM/YYYY` format, such as `06/2020`. However, the picker interface\n * will display two columns with the month's long name, and the four-digit year.\n *\n * ```html\n * <ion-item>\n *   <ion-label>Date</ion-label>\n *   <ion-datetime displayFormat=\"MM/YYYY\" pickerFormat=\"MMMM YYYY\" [(ngModel)]=\"myDate\"></ion-datetime>\n * </ion-item>\n * ```\n *\n * ### Datetime Data\n *\n * Historically, handling datetime values within JavaScript, or even within HTML\n * inputs, has always been a challenge. Specifically, JavaScript's `Date` object is\n * notoriously difficult to correctly parse apart datetime strings or to format\n * datetime values. Even worse is how different browsers and JavaScript versions\n * parse various datetime strings differently, especially per locale.\n *\n * But no worries, all is not lost! Ionic's datetime input has been designed so\n * developers can avoid the common pitfalls, allowing developers to easily format\n * datetime values within the input, and give the user a simple datetime picker for a\n * great user experience.\n *\n * ##### ISO 8601 Datetime Format: YYYY-MM-DDTHH:mmZ\n *\n * Ionic uses the [ISO 8601 datetime format](https://www.w3.org/TR/NOTE-datetime)\n * for its value. The value is simply a string, rather than using JavaScript's `Date`\n * object. Additionally, when using the ISO datetime format, it makes it easier\n * to serialize and pass within JSON objects, and sending databases a standardized\n * format which it can be easily parsed if need be.\n *\n * To create an ISO datetime string for the current date and time, e.g. use `const currentDate = (new Date()).toISOString();`.\n *\n * An ISO format can be used as a simple year, or just the hour and minute, or get more\n * detailed down to the millisecond and timezone. Any of the ISO formats below can be used,\n * and after a user selects a new value, Ionic will continue to use the same ISO format\n * which datetime value was originally given as.\n *\n * | Description          | Format                 | Datetime Value Example       |\n * |----------------------|------------------------|------------------------------|\n * | Year                 | YYYY                   | 1994                         |\n * | Year and Month       | YYYY-MM                | 1994-12                      |\n * | Complete Date        | YYYY-MM-DD             | 1994-12-15                   |\n * | Date and Time        | YYYY-MM-DDTHH:mm       | 1994-12-15T13:47             |\n * | UTC Timezone         | YYYY-MM-DDTHH:mm:ssTZD | 1994-12-15T13:47:20.789Z     |\n * | Timezone Offset      | YYYY-MM-DDTHH:mm:ssTZD | 1994-12-15T13:47:20.789+5:00 |\n * | Hour and Minute      | HH:mm                  | 13:47                        |\n * | Hour, Minute, Second | HH:mm:ss               | 13:47:20                     |\n *\n * Note that the year is always four-digits, milliseconds (if it's added) is always\n * three-digits, and all others are always two-digits. So the number representing\n * January always has a leading zero, such as `01`. Additionally, the hour is always\n * in the 24-hour format, so `00` is `12am` on a 12-hour clock, `13` means `1pm`,\n * and `23` means `11pm`.\n *\n * It's also important to note that neither the `displayFormat` or `pickerFormat` can\n * set the datetime value's output, which is the value that is set by the component's\n * `ngModel`. The format's are merely for displaying the value as text and the picker's\n * interface, but the datetime's value is always persisted as a valid ISO 8601 datetime\n * string.\n *\n *\n * ## Min and Max Datetimes\n *\n * Dates are infinite in either direction, so for a user's selection there should be at\n * least some form of restricting the dates that can be selected. By default, the maximum\n * date is to the end of the current year, and the minimum date is from the beginning\n * of the year that was 100 years ago.\n *\n * To customize the minimum and maximum datetime values, the `min` and `max` component\n * inputs can be provided which may make more sense for the app's use-case, rather\n * than the default of the last 100 years. Following the same IS0 8601 format listed\n * in the table above, each component can restrict which dates can be selected by the\n * user. Below is an example of restricting the date selection between the beginning\n * of 2016, and October 31st of 2020:\n *\n * ```html\n * <ion-item>\n *   <ion-label>Date</ion-label>\n *   <ion-datetime displayFormat=\"MMMM YYYY\" min=\"2016\" max=\"2020-10-31\" [(ngModel)]=\"myDate\">\n *   </ion-datetime>\n * </ion-item>\n * ```\n *\n *\n * ## Month Names and Day of the Week Names\n *\n * At this time, there is no one-size-fits-all standard to automatically choose the correct\n * language/spelling for a month name, or day of the week name, depending on the language\n * or locale. Good news is that there is an\n * [Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat)\n * standard which *most* browsers have adopted. However, at this time the standard has not\n * been fully implemented by all popular browsers so Ionic is unavailable to take advantage\n * of it *yet*. Additionally, Angular also provides an internationalization service, but it\n * is still under heavy development so Ionic does not depend on it at this time.\n *\n * All things considered, the by far easiest solution is to just provide an array of names\n * if the app needs to use names other than the default English version of month and day\n * names. The month names and day names can be either configured at the app level, or\n * individual `ion-datetime` level.\n *\n * ### App Config Level\n *\n * ```ts\n * //app.module.ts\n * @NgModule({\n * ...,\n * imports: [\n *   IonicModule.forRoot(MyApp, {\n *   monthNames: ['janeiro', 'fevereiro', 'mar\\u00e7o', ... ],\n *   monthShortNames: ['jan', 'fev', 'mar', ... ],\n *   dayNames: ['domingo', 'segunda-feira', 'ter\\u00e7a-feira', ... ],\n *   dayShortNames: ['dom', 'seg', 'ter', ... ],\n * })\n * ],\n * ...\n * })\n * ```\n *\n * ### Component Input Level\n *\n * ```html\n * <ion-item>\n *   <ion-label>Período</ion-label>\n *   <ion-datetime displayFormat=\"DDDD MMM D, YYYY\" [(ngModel)]=\"myDate\"\n *     monthNames=\"janeiro, fevereiro, mar\\u00e7o, ...\"\n *     monthShortNames=\"jan, fev, mar, ...\"\n *     dayNames=\"domingo, segunda-feira, ter\\u00e7a-feira, ...\"\n *     dayShortNames=\"dom, seg, ter, ...\"></ion-datetime>\n * </ion-item>\n * ```\n *\n *\n * ### Advanced Datetime Validation and Manipulation\n *\n * The datetime picker provides the simplicity of selecting an exact format, and persists\n * the datetime values as a string using the standardized\n * [ISO 8601 datetime format](https://www.w3.org/TR/NOTE-datetime).\n * However, it's important to note that `ion-datetime` does not attempt to solve all\n * situtations when validating and manipulating datetime values. If datetime values need\n * to be parsed from a certain format, or manipulated (such as adding 5 days to a date,\n * subtracting 30 minutes, etc.), or even formatting data to a specific locale, then we highly\n * recommend using [moment.js](http://momentjs.com/) to \"Parse, validate, manipulate, and\n * display dates in JavaScript\". [Moment.js](http://momentjs.com/) has quickly become\n * our goto standard when dealing with datetimes within JavaScript, but Ionic does not\n * prepackage this dependency since most apps will not require it, and its locale\n * configuration should be decided by the end-developer.\n *\n *\n * @usage\n * ```html\n * <ion-item>\n *   <ion-label>Date</ion-label>\n *   <ion-datetime displayFormat=\"MM/DD/YYYY\" [(ngModel)]=\"myDate\">\n *   </ion-datetime>\n * </ion-item>\n * ```\n *\n *\n * @demo /docs/demos/src/datetime/\n */\nexport class DateTime extends BaseInput {\n    constructor(form, config, elementRef, renderer, item, _pickerCtrl) {\n        super(config, elementRef, renderer, 'datetime', {}, form, item, null);\n        this._pickerCtrl = _pickerCtrl;\n        this._text = '';\n        this._locale = {};\n        /**\n         * @input {string} The text to display on the picker's cancel button. Default: `Cancel`.\n         */\n        this.cancelText = 'Cancel';\n        /**\n         * @input {string} The text to display on the picker's \"Done\" button. Default: `Done`.\n         */\n        this.doneText = 'Done';\n        /**\n         * @input {any} Any additional options that the picker interface can accept.\n         * See the [Picker API docs](../../picker/Picker) for the picker options.\n         */\n        this.pickerOptions = {};\n        /**\n         * @input {string} The text to display when there's no date selected yet.\n         * Using lowercase to match the input attribute\n         */\n        this.placeholder = '';\n        /**\n         * @output {any} Emitted when the datetime selection was cancelled.\n         */\n        this.ionCancel = new EventEmitter();\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n        // first see if locale names were provided in the inputs\n        // then check to see if they're in the config\n        // if neither were provided then it will use default English names\n        ['monthNames', 'monthShortNames', 'dayNames', 'dayShortNames'].forEach(type => {\n            this._locale[type] = convertToArrayOfStrings(isPresent(this[type]) ? this[type] : this._config.get(type), type);\n        });\n        this._initialize();\n    }\n    /**\n     * @hidden\n     */\n    _inputNormalize(val) {\n        updateDate(this._value, val);\n        return this._value;\n    }\n    /**\n     * @hidden\n     */\n    _inputUpdated() {\n        super._inputUpdated();\n        this.updateText();\n    }\n    /**\n     * @hidden\n     */\n    _inputShouldChange() {\n        return true;\n    }\n    /**\n     * TODO: REMOVE THIS\n     * @hidden\n     */\n    _inputChangeEvent() {\n        return this.value;\n    }\n    /**\n     * @hidden\n     */\n    _inputNgModelEvent() {\n        return convertDataToISO(this.value);\n    }\n    _click(ev) {\n        ev.preventDefault();\n        ev.stopPropagation();\n        this.open();\n    }\n    _keyup() {\n        this.open();\n    }\n    /**\n     * @hidden\n     */\n    open() {\n        if (this.isFocus() || this._disabled) {\n            return;\n        }\n        (void 0) /* console.debug */;\n        // the user may have assigned some options specifically for the picker\n        const pickerOptions = Object.assign({}, this.pickerOptions);\n        // Add a cancel and done button by default to the picker\n        const defaultButtons = [{\n                text: this.cancelText,\n                role: 'cancel',\n                handler: () => this.ionCancel.emit(this)\n            }, {\n                text: this.doneText,\n                handler: (data) => this.value = data,\n            }];\n        pickerOptions.buttons = (pickerOptions.buttons || []).concat(defaultButtons);\n        // Configure picker under the hood\n        const picker = this._picker = this._pickerCtrl.create(pickerOptions);\n        picker.ionChange.subscribe(() => {\n            this.validate();\n            picker.refresh();\n        });\n        // Update picker status before presenting\n        this.generate();\n        this.validate();\n        // Present picker\n        this._fireFocus();\n        picker.present(pickerOptions);\n        picker.onDidDismiss(() => {\n            this._fireBlur();\n        });\n    }\n    /**\n     * @hidden\n     */\n    generate() {\n        const picker = this._picker;\n        // if a picker format wasn't provided, then fallback\n        // to use the display format\n        let template = this.pickerFormat || this.displayFormat || DEFAULT_FORMAT;\n        if (isPresent(template)) {\n            // make sure we've got up to date sizing information\n            this.calcMinMax();\n            // does not support selecting by day name\n            // automaticallly remove any day name formats\n            template = template.replace('DDDD', '{~}').replace('DDD', '{~}');\n            if (template.indexOf('D') === -1) {\n                // there is not a day in the template\n                // replace the day name with a numeric one if it exists\n                template = template.replace('{~}', 'D');\n            }\n            // make sure no day name replacer is left in the string\n            template = template.replace(/{~}/g, '');\n            // parse apart the given template into an array of \"formats\"\n            parseTemplate(template).forEach(format => {\n                // loop through each format in the template\n                // create a new picker column to build up with data\n                let key = convertFormatToKey(format);\n                let values;\n                // first see if they have exact values to use for this input\n                if (isPresent(this[key + 'Values'])) {\n                    // user provide exact values for this date part\n                    values = convertToArrayOfNumbers(this[key + 'Values'], key);\n                }\n                else {\n                    // use the default date part values\n                    values = dateValueRange(format, this._min, this._max);\n                }\n                const column = {\n                    name: key,\n                    selectedIndex: 0,\n                    options: values.map(val => {\n                        return {\n                            value: val,\n                            text: renderTextFormat(format, val, null, this._locale),\n                        };\n                    })\n                };\n                // cool, we've loaded up the columns with options\n                // preselect the option for this column\n                const optValue = getValueFromFormat(this.getValueOrDefault(), format);\n                const selectedIndex = column.options.findIndex(opt => opt.value === optValue);\n                if (selectedIndex >= 0) {\n                    // set the select index for this column's options\n                    column.selectedIndex = selectedIndex;\n                }\n                // add our newly created column to the picker\n                picker.addColumn(column);\n            });\n            // Normalize min/max\n            const min = this._min;\n            const max = this._max;\n            const columns = this._picker.getColumns();\n            ['month', 'day', 'hour', 'minute']\n                .filter(name => !columns.find(column => column.name === name))\n                .forEach(name => {\n                min[name] = 0;\n                max[name] = 0;\n            });\n            this.divyColumns();\n        }\n    }\n    /**\n     * @hidden\n     */\n    validateColumn(name, index, min, max, lowerBounds, upperBounds) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        const column = this._picker.getColumn(name);\n        if (!column) {\n            return 0;\n        }\n        const lb = lowerBounds.slice();\n        const ub = upperBounds.slice();\n        const options = column.options;\n        let indexMin = options.length - 1;\n        let indexMax = 0;\n        for (var i = 0; i < options.length; i++) {\n            var opt = options[i];\n            var value = opt.value;\n            lb[index] = opt.value;\n            ub[index] = opt.value;\n            var disabled = opt.disabled = (value < lowerBounds[index] ||\n                value > upperBounds[index] ||\n                dateSortValue(ub[0], ub[1], ub[2], ub[3], ub[4]) < min ||\n                dateSortValue(lb[0], lb[1], lb[2], lb[3], lb[4]) > max);\n            if (!disabled) {\n                indexMin = Math.min(indexMin, i);\n                indexMax = Math.max(indexMax, i);\n            }\n        }\n        let selectedIndex = column.selectedIndex = clamp(indexMin, column.selectedIndex, indexMax);\n        opt = column.options[selectedIndex];\n        if (opt) {\n            return opt.value;\n        }\n        return 0;\n    }\n    /**\n     * @private\n     */\n    validate() {\n        const today = new Date();\n        const minCompareVal = dateDataSortValue(this._min);\n        const maxCompareVal = dateDataSortValue(this._max);\n        const yearCol = this._picker.getColumn('year');\n        (void 0) /* assert */;\n        let selectedYear = today.getFullYear();\n        if (yearCol) {\n            // default to the first value if the current year doesn't exist in the options\n            if (!yearCol.options.find(col => col.value === today.getFullYear())) {\n                selectedYear = yearCol.options[0].value;\n            }\n            var yearOpt = yearCol.options[yearCol.selectedIndex];\n            if (yearOpt) {\n                // they have a selected year value\n                selectedYear = yearOpt.value;\n            }\n        }\n        const selectedMonth = this.validateColumn('month', 1, minCompareVal, maxCompareVal, [selectedYear, 0, 0, 0, 0], [selectedYear, 12, 31, 23, 59]);\n        const numDaysInMonth = daysInMonth(selectedMonth, selectedYear);\n        const selectedDay = this.validateColumn('day', 2, minCompareVal, maxCompareVal, [selectedYear, selectedMonth, 0, 0, 0], [selectedYear, selectedMonth, numDaysInMonth, 23, 59]);\n        const selectedHour = this.validateColumn('hour', 3, minCompareVal, maxCompareVal, [selectedYear, selectedMonth, selectedDay, 0, 0], [selectedYear, selectedMonth, selectedDay, 23, 59]);\n        this.validateColumn('minute', 4, minCompareVal, maxCompareVal, [selectedYear, selectedMonth, selectedDay, selectedHour, 0], [selectedYear, selectedMonth, selectedDay, selectedHour, 59]);\n    }\n    /**\n     * @hidden\n     */\n    divyColumns() {\n        const pickerColumns = this._picker.getColumns();\n        let columnsWidth = [];\n        let col;\n        let width;\n        for (var i = 0; i < pickerColumns.length; i++) {\n            col = pickerColumns[i];\n            columnsWidth.push(0);\n            for (var j = 0; j < col.options.length; j++) {\n                width = col.options[j].text.length;\n                if (width > columnsWidth[i]) {\n                    columnsWidth[i] = width;\n                }\n            }\n        }\n        if (columnsWidth.length === 2) {\n            width = Math.max(columnsWidth[0], columnsWidth[1]);\n            pickerColumns[0].align = 'right';\n            pickerColumns[1].align = 'left';\n            pickerColumns[0].optionsWidth = pickerColumns[1].optionsWidth = `${width * 17}px`;\n        }\n        else if (columnsWidth.length === 3) {\n            width = Math.max(columnsWidth[0], columnsWidth[2]);\n            pickerColumns[0].align = 'right';\n            pickerColumns[1].columnWidth = `${columnsWidth[1] * 17}px`;\n            pickerColumns[0].optionsWidth = pickerColumns[2].optionsWidth = `${width * 17}px`;\n            pickerColumns[2].align = 'left';\n        }\n    }\n    /**\n     * @hidden\n     */\n    updateText() {\n        // create the text of the formatted data\n        const template = this.displayFormat || this.pickerFormat || DEFAULT_FORMAT;\n        this._text = renderDateTime(template, this.getValue(), this._locale);\n    }\n    /**\n     * @hidden\n     */\n    getValue() {\n        return this._value;\n    }\n    /**\n     * @hidden\n     */\n    getValueOrDefault() {\n        if (this.hasValue()) {\n            return this._value;\n        }\n        const initialDateString = this.getDefaultValueDateString();\n        const _default = {};\n        updateDate(_default, initialDateString);\n        return _default;\n    }\n    /**\n     * Get the default value as a date string\n     * @hidden\n     */\n    getDefaultValueDateString() {\n        if (this.initialValue) {\n            return this.initialValue;\n        }\n        const nowString = (new Date).toISOString();\n        if (this.max) {\n            const now = parseDate(nowString);\n            const max = parseDate(this.max);\n            let v;\n            for (let i in max) {\n                v = max[i];\n                if (v === null) {\n                    max[i] = now[i];\n                }\n            }\n            const diff = compareDates(now, max);\n            // If max is before current time, return max\n            if (diff > 0) {\n                return this.max;\n            }\n        }\n        return nowString;\n    }\n    /**\n     * @hidden\n     */\n    hasValue() {\n        const val = this._value;\n        return isPresent(val)\n            && isObject(val)\n            && Object.keys(val).length > 0;\n    }\n    /**\n     * @hidden\n     */\n    calcMinMax(now) {\n        const todaysYear = (now || new Date()).getFullYear();\n        if (isPresent(this.yearValues)) {\n            var years = convertToArrayOfNumbers(this.yearValues, 'year');\n            if (isBlank(this.min)) {\n                this.min = Math.min.apply(Math, years);\n            }\n            if (isBlank(this.max)) {\n                this.max = Math.max.apply(Math, years);\n            }\n        }\n        else {\n            if (isBlank(this.min)) {\n                this.min = (todaysYear - 100).toString();\n            }\n            if (isBlank(this.max)) {\n                this.max = todaysYear.toString();\n            }\n        }\n        const min = this._min = parseDate(this.min);\n        const max = this._max = parseDate(this.max);\n        min.year = min.year || todaysYear;\n        max.year = max.year || todaysYear;\n        min.month = min.month || 1;\n        max.month = max.month || 12;\n        min.day = min.day || 1;\n        max.day = max.day || 31;\n        min.hour = min.hour || 0;\n        max.hour = max.hour || 23;\n        min.minute = min.minute || 0;\n        max.minute = max.minute || 59;\n        min.second = min.second || 0;\n        max.second = max.second || 59;\n        // Ensure min/max constraits\n        if (min.year > max.year) {\n            console.error('min.year > max.year');\n            min.year = max.year - 100;\n        }\n        if (min.year === max.year) {\n            if (min.month > max.month) {\n                console.error('min.month > max.month');\n                min.month = 1;\n            }\n            else if (min.month === max.month && min.day > max.day) {\n                console.error('min.day > max.day');\n                min.day = 1;\n            }\n        }\n    }\n}\nDateTime.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-datetime',\n                template: '<div *ngIf=\"!_text\" class=\"datetime-text datetime-placeholder\">{{placeholder}}</div>' +\n                    '<div *ngIf=\"_text\" class=\"datetime-text\">{{_text}}</div>' +\n                    '<button aria-haspopup=\"true\" ' +\n                    'type=\"button\" ' +\n                    '[id]=\"id\" ' +\n                    'ion-button=\"item-cover\" ' +\n                    '[attr.aria-labelledby]=\"_labelId\" ' +\n                    '[attr.aria-disabled]=\"_disabled\" ' +\n                    'class=\"item-cover\">' +\n                    '</button>',\n                host: {\n                    '[class.datetime-disabled]': '_disabled'\n                },\n                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: DateTime, multi: true }],\n                encapsulation: ViewEncapsulation.None,\n            },] },\n];\n/** @nocollapse */\nDateTime.ctorParameters = () => [\n    { type: Form, },\n    { type: Config, },\n    { type: ElementRef, },\n    { type: Renderer, },\n    { type: Item, decorators: [{ type: Optional },] },\n    { type: PickerController, decorators: [{ type: Optional },] },\n];\nDateTime.propDecorators = {\n    'min': [{ type: Input },],\n    'max': [{ type: Input },],\n    'displayFormat': [{ type: Input },],\n    'initialValue': [{ type: Input },],\n    'pickerFormat': [{ type: Input },],\n    'cancelText': [{ type: Input },],\n    'doneText': [{ type: Input },],\n    'yearValues': [{ type: Input },],\n    'monthValues': [{ type: Input },],\n    'dayValues': [{ type: Input },],\n    'hourValues': [{ type: Input },],\n    'minuteValues': [{ type: Input },],\n    'monthNames': [{ type: Input },],\n    'monthShortNames': [{ type: Input },],\n    'dayNames': [{ type: Input },],\n    'dayShortNames': [{ type: Input },],\n    'pickerOptions': [{ type: Input },],\n    'placeholder': [{ type: Input },],\n    'ionCancel': [{ type: Output },],\n    '_click': [{ type: HostListener, args: ['click', ['$event'],] },],\n    '_keyup': [{ type: HostListener, args: ['keyup.space',] },],\n};\n/**\n * @hidden\n * Use to convert a string of comma separated numbers or\n * an array of numbers, and clean up any user input\n */\nfunction convertToArrayOfNumbers(input, type) {\n    if (isString(input)) {\n        // convert the string to an array of strings\n        // auto remove any whitespace and [] characters\n        input = input.replace(/\\[|\\]|\\s/g, '').split(',');\n    }\n    let values;\n    if (isArray(input)) {\n        // ensure each value is an actual number in the returned array\n        values = input\n            .map((num) => parseInt(num, 10))\n            .filter(isFinite);\n    }\n    if (!values || !values.length) {\n        console.warn(`Invalid \"${type}Values\". Must be an array of numbers, or a comma separated string of numbers.`);\n    }\n    return values;\n}\n/**\n * @hidden\n * Use to convert a string of comma separated strings or\n * an array of strings, and clean up any user input\n */\nfunction convertToArrayOfStrings(input, type) {\n    if (isPresent(input)) {\n        if (isString(input)) {\n            // convert the string to an array of strings\n            // auto remove any [] characters\n            input = input.replace(/\\[|\\]/g, '').split(',');\n        }\n        var values;\n        if (isArray(input)) {\n            // trim up each string value\n            values = input.map((val) => val.trim());\n        }\n        if (!values || !values.length) {\n            console.warn(`Invalid \"${type}Names\". Must be an array of strings, or a comma separated string.`);\n        }\n        return values;\n    }\n}\nconst DEFAULT_FORMAT = 'MMM D, YYYY';\n"]}