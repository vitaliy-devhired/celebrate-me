{"version":3,"file":"img.js","sources":["img.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;iDAQE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { ChangeDetectionStrategy, Component, ElementRef, Input, Optional, Renderer, ViewEncapsulation } from '@angular/core';\nimport { Content } from '../content/content';\nimport { DomController } from '../../platform/dom-controller';\nimport { isPresent, isTrueProperty } from '../../util/util';\nimport { Platform } from '../../platform/platform';\n/**\n * @name Img\n * @description\n * Two of the biggest cuprits of scroll jank is starting up a new HTTP\n * request, and rendering images. These two reasons is largely why\n * `ion-img` was created. The standard HTML `img` element is often a large\n * source of these problems, and what makes matters worse is that the app\n * does not have fine-grained control of requests and rendering for each\n * `img` element.\n *\n * The `ion-img` component is similar to the standard `img` element,\n * but it also adds features in order to provide improved performance.\n * Features include only loading images which are visible, using web workers\n * for HTTP requests, preventing jank while scrolling and in-memory caching.\n *\n * Note that `ion-img` also comes with a few more restrictions in comparison\n * to the standard `img` element. A good rule is, if there are only a few\n * images to be rendered on a page, then the standard `img` is probably\n * best. However, if a page has the potential for hundreds or even thousands\n * of images within a scrollable area, then `ion-img` would be better suited\n * for the job.\n *\n * > Note: `ion-img` is only meant to be used inside of [virtual-scroll](/docs/api/components/virtual-scroll/VirtualScroll/)\n *\n *\n * ### Lazy Loading\n *\n * Lazy loading images refers to only loading images which are actually\n * visible within the user's viewport. This also means that images which are\n * not viewable on the initial load would not be downloaded or rendered. Next,\n * as the user scrolls, each image which becomes visible is then requested\n * then rendered on-demand.\n *\n * The benefits of this approach is that unnecessary and resource intensive\n * HTTP requests are not started, valuable bandwidth isn't wasted, and this\n * allows the browser to free up resources which would be wasted on images\n * which are not even viewable. For example, animated GIFs are enourmous\n * performance drains, however, with `ion-img` the app is able to dedicate\n * resources to just the viewable images. But again, if the problems listed\n * above are not problems within your app, then the standard `img` element\n * may be best.\n *\n *\n * ### Image Dimensions\n *\n * By providing image dimensions up front, Ionic is able to accurately size\n * up the image's location within the viewport, which helps lazy load only\n * images which are viewable. Image dimensions can either by set as\n * properties, inline styles, or external stylesheets. It doesn't matter\n * which method of setting dimensions is used, but it's important that somehow\n * each `ion-img` has been given an exact size.\n *\n * For example, by default `<ion-avatar>` and `<ion-thumbnail>` already come\n * with exact sizes when placed within an `<ion-item>`. By giving each image\n * an exact size, this then further locks in the size of each `ion-item`,\n * which again helps improve scroll performance.\n *\n * ```html\n * <!-- dimensions set using attributes -->\n * <ion-img width=\"80\" height=\"80\" src=\"...\"></ion-img>\n *\n * <!-- dimensions set using input properties -->\n * <ion-img [width]=\"imgWidth\" [height]=\"imgHeight\" src=\"...\"></ion-img>\n *\n * <!-- dimensions set using inline styles -->\n * <ion-img style=\"width: 80px; height: 80px;\" src=\"...\"></ion-img>\n * ```\n *\n * Additionally, each `ion-img` uses the `object-fit: cover` CSS property.\n * What this means is that the actual rendered image will center itself within\n * it's container. Or to really get detailed: The image is sized to maintain\n * its aspect ratio while filling the containing element’s entire content box.\n * Its concrete object size is resolved as a cover constraint against the\n * element’s used width and height.\n *\n * ### Future Optimizations\n *\n * Future goals are to place image requests within web workers, and cache\n * images in-memory as datauris. This method has proven to be effective,\n * however there are some current limitations with Cordova which we are\n * currently working on.\n *\n */\nexport class Img {\n    constructor(_elementRef, _renderer, _plt, _content, _dom) {\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        this._plt = _plt;\n        this._content = _content;\n        this._dom = _dom;\n        /** @internal */\n        this._cache = true;\n        /** @internal */\n        this._w = '';\n        /** @internal */\n        this._h = '';\n        /** @internal */\n        this._wQ = '';\n        /** @internal */\n        this._hQ = '';\n        /**\n         * @input {string}  Set the `alt` attribute which gets assigned to\n         * the inner `img` element.\n         */\n        this.alt = '';\n        if (!this._content) {\n            console.warn(`ion-img can only be used within an ion-content`);\n        }\n        else {\n            this._content.addImg(this);\n        }\n        this._isLoaded(false);\n    }\n    /**\n     * @input {string} The source of the image.\n     */\n    get src() {\n        return this._src;\n    }\n    set src(newSrc) {\n        // if the source hasn't changed, then um, let's not change it\n        if (newSrc !== this._src) {\n            // we're changing the source\n            // so abort any active http requests\n            // and render the image empty\n            this.reset();\n            // update to the new src\n            this._src = newSrc;\n            // Are they using an actual datauri already,\n            // or reset any existing datauri we might be holding onto\n            this._hasLoaded = newSrc.indexOf('data:') === 0;\n            // run update to kick off requests or render if everything is good\n            this.update();\n        }\n    }\n    /**\n     * @hidden\n     */\n    reset() {\n        if (this._requestingSrc) {\n            // abort any active requests\n            (void 0) /* console.debug */;\n            this._srcAttr('');\n            this._requestingSrc = null;\n        }\n        if (this._renderedSrc) {\n            // clear out the currently rendered img\n            (void 0) /* console.debug */;\n            this._renderedSrc = null;\n            this._isLoaded(false);\n        }\n    }\n    /**\n     * @hidden\n     */\n    update() {\n        // only attempt an update if there is an active src\n        // and the content containing the image considers it updatable\n        if (this._src && this._content.isImgsUpdatable()) {\n            if (this.canRequest && (this._src !== this._renderedSrc && this._src !== this._requestingSrc) && !this._hasLoaded) {\n                // only begin the request if we \"can\" request\n                // begin the image request if the src is different from the rendered src\n                // and if we don't already has a tmpDataUri\n                (void 0) /* console.debug */;\n                this._requestingSrc = this._src;\n                this._isLoaded(false);\n                this._srcAttr(this._src);\n                // set the dimensions of the image if we do have different data\n                this._setDims();\n            }\n            if (this.canRender && this._hasLoaded && this._src !== this._renderedSrc) {\n                // we can render and we have a datauri to render\n                this._renderedSrc = this._src;\n                this._setDims();\n                this._dom.write(() => {\n                    if (this._hasLoaded) {\n                        (void 0) /* console.debug */;\n                        this._isLoaded(true);\n                        this._srcAttr(this._src);\n                    }\n                });\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    _isLoaded(isLoaded) {\n        const renderer = this._renderer;\n        const ele = this._elementRef.nativeElement;\n        renderer.setElementClass(ele, 'img-loaded', isLoaded);\n        renderer.setElementClass(ele, 'img-unloaded', !isLoaded);\n    }\n    /**\n     * @internal\n     */\n    _srcAttr(srcAttr) {\n        const imgEle = this._img;\n        const renderer = this._renderer;\n        if (imgEle && imgEle.src !== srcAttr) {\n            renderer.setElementAttribute(this._img, 'src', srcAttr);\n            renderer.setElementAttribute(this._img, 'alt', this.alt);\n        }\n    }\n    /**\n     * @hidden\n     */\n    get top() {\n        const bounds = this._getBounds();\n        return bounds && bounds.top || 0;\n    }\n    /**\n     * @hidden\n     */\n    get bottom() {\n        const bounds = this._getBounds();\n        return bounds && bounds.bottom || 0;\n    }\n    _getBounds() {\n        if (this._bounds) {\n            // we've been manually passed bounds data\n            // this is probably from Virtual Scroll items\n            return this._bounds;\n        }\n        if (!this._rect) {\n            // we don't have bounds from virtual scroll\n            // so let's do the raw DOM lookup w/ getBoundingClientRect\n            this._rect = this._elementRef.nativeElement.getBoundingClientRect();\n            (void 0) /* console.debug */;\n        }\n        return this._rect;\n    }\n    /**\n     * @input {any}  Sets the bounding rectangle of the element relative to the viewport.\n     * When using `VirtualScroll`, each virtual item should pass its bounds to each\n     * `ion-img`. The passed in data object should include `top` and `bottom` properties.\n     */\n    set bounds(b) {\n        if (isPresent(b)) {\n            this._bounds = b;\n        }\n    }\n    /**\n     * @input {boolean}  After an image has been successfully downloaded, it can be cached\n     * in-memory. This is useful for `VirtualScroll` by allowing image responses to be\n     * cached, and not rendered, until after scrolling has completed, which allows for\n     * smoother scrolling.\n     */\n    get cache() {\n        return this._cache;\n    }\n    set cache(val) {\n        this._cache = isTrueProperty(val);\n    }\n    /**\n     * @input {string}  Image width. If this property is not set it's important that\n     * the dimensions are still set using CSS. If the dimension is just a number it\n     * will assume the `px` unit.\n     */\n    set width(val) {\n        this._wQ = getUnitValue(val);\n        this._setDims();\n    }\n    /**\n     * @input {string}  Image height. If this property is not set it's important that\n     * the dimensions are still set using CSS. If the dimension is just a number it\n     * will assume the `px` unit.\n     */\n    set height(val) {\n        this._hQ = getUnitValue(val);\n        this._setDims();\n    }\n    _setDims() {\n        // only set the dimensions if we can render\n        // and only if the dimensions have changed from when we last set it\n        if (this.canRender && (this._w !== this._wQ || this._h !== this._hQ)) {\n            var wrapperEle = this._elementRef.nativeElement;\n            var renderer = this._renderer;\n            this._dom.write(() => {\n                if (this._w !== this._wQ) {\n                    this._w = this._wQ;\n                    renderer.setElementStyle(wrapperEle, 'width', this._w);\n                }\n                if (this._h !== this._hQ) {\n                    this._h = this._hQ;\n                    renderer.setElementStyle(wrapperEle, 'height', this._h);\n                }\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n        this._img = this._elementRef.nativeElement.firstChild;\n        this._unreg = this._plt.registerListener(this._img, 'load', () => {\n            this._hasLoaded = true;\n            this.update();\n        }, { passive: true });\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this._unreg && this._unreg();\n        this._content && this._content.removeImg(this);\n    }\n}\nImg.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-img',\n                template: '<img>',\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n            },] },\n];\n/** @nocollapse */\nImg.ctorParameters = () => [\n    { type: ElementRef, },\n    { type: Renderer, },\n    { type: Platform, },\n    { type: Content, decorators: [{ type: Optional },] },\n    { type: DomController, },\n];\nImg.propDecorators = {\n    'src': [{ type: Input },],\n    'bounds': [{ type: Input },],\n    'cache': [{ type: Input },],\n    'width': [{ type: Input },],\n    'height': [{ type: Input },],\n    'alt': [{ type: Input },],\n};\nfunction getUnitValue(val) {\n    if (isPresent(val)) {\n        if (typeof val === 'string') {\n            if (val.indexOf('%') > -1 || val.indexOf('px') > -1) {\n                return val;\n            }\n            if (val.length) {\n                return val + 'px';\n            }\n        }\n        else if (typeof val === 'number') {\n            return val + 'px';\n        }\n    }\n    return '';\n}\n"]}