{"version":3,"file":"range.js","sources":["range.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4FAqBE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF","sourcesContent":["import { ChangeDetectorRef, Component, ElementRef, Input, Optional, Renderer, ViewChild, ViewEncapsulation } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { clamp, isTrueProperty } from '../../util/util';\nimport { Config } from '../../config/config';\nimport { DomController } from '../../platform/dom-controller';\nimport { Form } from '../../util/form';\nimport { Haptic } from '../../tap-click/haptic';\nimport { BaseInput } from '../../util/base-input';\nimport { Item } from '../item/item';\nimport { Platform } from '../../platform/platform';\nimport { pointerCoord } from '../../util/dom';\nimport { UIEventManager } from '../../gestures/ui-event-manager';\n/**\n * @name Range\n * @description\n * The Range slider lets users select from a range of values by moving\n * the slider knob. It can accept dual knobs, but by default one knob\n * controls the value of the range.\n *\n * ### Range Labels\n * Labels can be placed on either side of the range by adding the\n * `range-left` or `range-right` property to the element. The element\n * doesn't have to be an `ion-label`, it can be added to any element\n * to place it to the left or right of the range. See [usage](#usage)\n * below for examples.\n *\n *\n * ### Minimum and Maximum Values\n * Minimum and maximum values can be passed to the range through the `min`\n * and `max` properties, respectively. By default, the range sets the `min`\n * to `0` and the `max` to `100`.\n *\n *\n * ### Steps and Snaps\n * The `step` property specifies the value granularity of the range's value.\n * It can be useful to set the `step` when the value isn't in increments of `1`.\n * Setting the `step` property will show tick marks on the range for each step.\n * The `snaps` property can be set to automatically move the knob to the nearest\n * tick mark based on the step property value.\n *\n *\n * ### Dual Knobs\n * Setting the `dualKnobs` property to `true` on the range component will\n * enable two knobs on the range. If the range has two knobs, the value will\n * be an object containing two properties: `lower` and `upper`.\n *\n *\n * @usage\n * ```html\n * <ion-list>\n *   <ion-item>\n *     <ion-range [(ngModel)]=\"singleValue\" color=\"danger\" pin=\"true\"></ion-range>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-range min=\"-200\" max=\"200\" [(ngModel)]=\"saturation\" color=\"secondary\">\n *       <ion-label range-left>-200</ion-label>\n *       <ion-label range-right>200</ion-label>\n *     </ion-range>\n *   </ion-item>\n *\n *  <ion-item>\n *    <ion-range min=\"20\" max=\"80\" step=\"2\" [(ngModel)]=\"brightness\">\n *      <ion-icon small range-left name=\"sunny\"></ion-icon>\n *      <ion-icon range-right name=\"sunny\"></ion-icon>\n *    </ion-range>\n *  </ion-item>\n *\n *   <ion-item>\n *     <ion-label>step=100, snaps, {{singleValue4}}</ion-label>\n *     <ion-range min=\"1000\" max=\"2000\" step=\"100\" snaps=\"true\" color=\"secondary\" [(ngModel)]=\"singleValue4\"></ion-range>\n *   </ion-item>\n *\n *   <ion-item>\n *     <ion-label>dual, step=3, snaps, {{dualValue2 | json}}</ion-label>\n *     <ion-range dualKnobs=\"true\" [(ngModel)]=\"dualValue2\" min=\"21\" max=\"72\" step=\"3\" snaps=\"true\"></ion-range>\n *   </ion-item>\n * </ion-list>\n * ```\n *\n *\n * @demo /docs/demos/src/range/\n */\nexport class Range extends BaseInput {\n    constructor(form, _haptic, item, config, _plt, elementRef, renderer, _dom, _cd) {\n        super(config, elementRef, renderer, 'range', 0, form, item, null);\n        this._haptic = _haptic;\n        this._plt = _plt;\n        this._dom = _dom;\n        this._cd = _cd;\n        this._min = 0;\n        this._max = 100;\n        this._step = 1;\n        this._valA = 0;\n        this._valB = 0;\n        this._ratioA = 0;\n        this._ratioB = 0;\n        this._events = new UIEventManager(_plt);\n    }\n    /**\n     * @input {number} Minimum integer value of the range. Defaults to `0`.\n     */\n    get min() {\n        return this._min;\n    }\n    set min(val) {\n        val = Math.round(val);\n        if (!isNaN(val)) {\n            this._min = val;\n            this._inputUpdated();\n        }\n    }\n    /**\n     * @input {number} Maximum integer value of the range. Defaults to `100`.\n     */\n    get max() {\n        return this._max;\n    }\n    set max(val) {\n        val = Math.round(val);\n        if (!isNaN(val)) {\n            this._max = val;\n            this._inputUpdated();\n        }\n    }\n    /**\n     * @input {number} Specifies the value granularity. Defaults to `1`.\n     */\n    get step() {\n        return this._step;\n    }\n    set step(val) {\n        val = Math.round(val);\n        if (!isNaN(val) && val > 0) {\n            this._step = val;\n        }\n    }\n    /**\n     * @input {boolean} If true, the knob snaps to tick marks evenly spaced based\n     * on the step property value. Defaults to `false`.\n     */\n    get snaps() {\n        return this._snaps;\n    }\n    set snaps(val) {\n        this._snaps = isTrueProperty(val);\n    }\n    /**\n     * @input {boolean} If true, a pin with integer value is shown when the knob\n     * is pressed. Defaults to `false`.\n     */\n    get pin() {\n        return this._pin;\n    }\n    set pin(val) {\n        this._pin = isTrueProperty(val);\n    }\n    /**\n     * @input {number} How long, in milliseconds, to wait to trigger the\n     * `ionChange` event after each change in the range value. Default `0`.\n     */\n    get debounce() {\n        return this._debouncer.wait;\n    }\n    set debounce(val) {\n        this._debouncer.wait = val;\n    }\n    /**\n     * @input {boolean} Show two knobs. Defaults to `false`.\n     */\n    get dualKnobs() {\n        return this._dual;\n    }\n    set dualKnobs(val) {\n        this._dual = isTrueProperty(val);\n    }\n    /**\n     * Returns the ratio of the knob's is current location, which is a number\n     * between `0` and `1`. If two knobs are used, this property represents\n     * the lower value.\n     */\n    get ratio() {\n        if (this._dual) {\n            return Math.min(this._ratioA, this._ratioB);\n        }\n        return this._ratioA;\n    }\n    /**\n     * Returns the ratio of the upper value's is current location, which is\n     * a number between `0` and `1`. If there is only one knob, then this\n     * will return `null`.\n     */\n    get ratioUpper() {\n        if (this._dual) {\n            return Math.max(this._ratioA, this._ratioB);\n        }\n        return null;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n        this._initialize();\n        // add touchstart/mousedown listeners\n        this._events.pointerEvents({\n            element: this._slider.nativeElement,\n            pointerDown: this._pointerDown.bind(this),\n            pointerMove: this._pointerMove.bind(this),\n            pointerUp: this._pointerUp.bind(this),\n            zone: true\n        });\n        // build all the ticks if there are any to show\n        this._createTicks();\n    }\n    /** @internal */\n    _pointerDown(ev) {\n        // TODO: we could stop listening for events instead of checking this._disabled.\n        // since there are a lot of events involved, this solution is\n        // enough for the moment\n        if (this._disabled) {\n            return false;\n        }\n        // trigger ionFocus event\n        this._fireFocus();\n        // prevent default so scrolling does not happen\n        ev.preventDefault();\n        ev.stopPropagation();\n        // get the start coordinates\n        const current = pointerCoord(ev);\n        // get the full dimensions of the slider element\n        const rect = this._rect = this._plt.getElementBoundingClientRect(this._slider.nativeElement);\n        // figure out which knob they started closer to\n        const ratio = clamp(0, (current.x - rect.left) / (rect.width), 1);\n        this._activeB = this._dual && (Math.abs(ratio - this._ratioA) > Math.abs(ratio - this._ratioB));\n        // update the active knob's position\n        this._update(current, rect, true);\n        // trigger a haptic start\n        this._haptic.gestureSelectionStart();\n        // return true so the pointer events\n        // know everything's still valid\n        return true;\n    }\n    /** @internal */\n    _pointerMove(ev) {\n        if (this._disabled) {\n            return;\n        }\n        // prevent default so scrolling does not happen\n        ev.preventDefault();\n        ev.stopPropagation();\n        // update the active knob's position\n        const hasChanged = this._update(pointerCoord(ev), this._rect, true);\n        if (hasChanged && this._snaps) {\n            // trigger a haptic selection changed event\n            // if this is a snap range\n            this._haptic.gestureSelectionChanged();\n        }\n    }\n    /** @internal */\n    _pointerUp(ev) {\n        if (this._disabled) {\n            return;\n        }\n        // prevent default so scrolling does not happen\n        ev.preventDefault();\n        ev.stopPropagation();\n        // update the active knob's position\n        this._update(pointerCoord(ev), this._rect, false);\n        // trigger a haptic end\n        this._haptic.gestureSelectionEnd();\n        // trigger ionBlur event\n        this._fireBlur();\n    }\n    /** @internal */\n    _update(current, rect, isPressed) {\n        // figure out where the pointer is currently at\n        // update the knob being interacted with\n        let ratio = clamp(0, (current.x - rect.left) / (rect.width), 1);\n        let val = this._ratioToValue(ratio);\n        if (this._snaps) {\n            // snaps the ratio to the current value\n            ratio = this._valueToRatio(val);\n        }\n        // update which knob is pressed\n        this._pressed = isPressed;\n        let valChanged = false;\n        if (this._activeB) {\n            // when the pointer down started it was determined\n            // that knob B was the one they were interacting with\n            this._pressedB = isPressed;\n            this._pressedA = false;\n            this._ratioB = ratio;\n            valChanged = val === this._valB;\n            this._valB = val;\n        }\n        else {\n            // interacting with knob A\n            this._pressedA = isPressed;\n            this._pressedB = false;\n            this._ratioA = ratio;\n            valChanged = val === this._valA;\n            this._valA = val;\n        }\n        this._updateBar();\n        if (valChanged) {\n            return false;\n        }\n        // value has been updated\n        let value;\n        if (this._dual) {\n            // dual knobs have an lower and upper value\n            value = {\n                lower: Math.min(this._valA, this._valB),\n                upper: Math.max(this._valA, this._valB)\n            };\n            (void 0) /* console.debug */;\n        }\n        else {\n            // single knob only has one value\n            value = this._valA;\n            (void 0) /* console.debug */;\n        }\n        // Update input value\n        this.value = value;\n        return true;\n    }\n    /** @internal */\n    _updateBar() {\n        const ratioA = this._ratioA;\n        const ratioB = this._ratioB;\n        if (this._dual) {\n            this._barL = `${(Math.min(ratioA, ratioB) * 100)}%`;\n            this._barR = `${100 - (Math.max(ratioA, ratioB) * 100)}%`;\n        }\n        else {\n            this._barL = '';\n            this._barR = `${100 - (ratioA * 100)}%`;\n        }\n        this._updateTicks();\n    }\n    /** @internal */\n    _createTicks() {\n        if (this._snaps) {\n            this._dom.write(() => {\n                // TODO: Fix to not use RAF\n                this._ticks = [];\n                for (var value = this._min; value <= this._max; value += this._step) {\n                    var ratio = this._valueToRatio(value);\n                    this._ticks.push({\n                        ratio: ratio,\n                        left: `${ratio * 100}%`,\n                    });\n                }\n                this._updateTicks();\n            });\n        }\n    }\n    /** @internal */\n    _updateTicks() {\n        const ticks = this._ticks;\n        const ratio = this.ratio;\n        if (this._snaps && ticks) {\n            if (this._dual) {\n                var upperRatio = this.ratioUpper;\n                ticks.forEach(t => {\n                    t.active = (t.ratio >= ratio && t.ratio <= upperRatio);\n                });\n            }\n            else {\n                ticks.forEach(t => {\n                    t.active = (t.ratio <= ratio);\n                });\n            }\n        }\n    }\n    /** @hidden */\n    _keyChg(isIncrease, isKnobB) {\n        const step = this._step;\n        if (isKnobB) {\n            if (isIncrease) {\n                this._valB += step;\n            }\n            else {\n                this._valB -= step;\n            }\n            this._valB = clamp(this._min, this._valB, this._max);\n            this._ratioB = this._valueToRatio(this._valB);\n        }\n        else {\n            if (isIncrease) {\n                this._valA += step;\n            }\n            else {\n                this._valA -= step;\n            }\n            this._valA = clamp(this._min, this._valA, this._max);\n            this._ratioA = this._valueToRatio(this._valA);\n        }\n        this._updateBar();\n    }\n    /** @internal */\n    _ratioToValue(ratio) {\n        ratio = Math.round(((this._max - this._min) * ratio));\n        ratio = Math.round(ratio / this._step) * this._step + this._min;\n        return clamp(this._min, ratio, this._max);\n    }\n    /** @internal */\n    _valueToRatio(value) {\n        value = Math.round((value - this._min) / this._step) * this._step;\n        value = value / (this._max - this._min);\n        return clamp(0, value, 1);\n    }\n    _inputNormalize(val) {\n        if (this._dual) {\n            return val;\n        }\n        else {\n            val = parseFloat(val);\n            return isNaN(val) ? undefined : val;\n        }\n    }\n    /**\n     * @hidden\n     */\n    _inputUpdated() {\n        const val = this.value;\n        if (this._dual) {\n            this._valA = val.lower;\n            this._valB = val.upper;\n            this._ratioA = this._valueToRatio(val.lower);\n            this._ratioB = this._valueToRatio(val.upper);\n        }\n        else {\n            this._valA = val;\n            this._ratioA = this._valueToRatio(val);\n        }\n        this._updateBar();\n        this._cd.detectChanges();\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this._events.destroy();\n    }\n}\nRange.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-range',\n                template: '<ng-content select=\"[range-left]\"></ng-content>' +\n                    '<div class=\"range-slider\" #slider>' +\n                    '<div class=\"range-tick\" *ngFor=\"let t of _ticks\" [style.left]=\"t.left\" [class.range-tick-active]=\"t.active\" role=\"presentation\"></div>' +\n                    '<div class=\"range-bar\" role=\"presentation\"></div>' +\n                    '<div class=\"range-bar range-bar-active\" [style.left]=\"_barL\" [style.right]=\"_barR\" #bar role=\"presentation\"></div>' +\n                    '<div class=\"range-knob-handle\" (ionIncrease)=\"_keyChg(true, false)\" (ionDecrease)=\"_keyChg(false, false)\" [ratio]=\"_ratioA\" [val]=\"_valA\" [pin]=\"_pin\" [pressed]=\"_pressedA\" [min]=\"_min\" [max]=\"_max\" [disabled]=\"_disabled\" [labelId]=\"_labelId\"></div>' +\n                    '<div class=\"range-knob-handle\" (ionIncrease)=\"_keyChg(true, true)\" (ionDecrease)=\"_keyChg(false, true)\" [ratio]=\"_ratioB\" [val]=\"_valB\" [pin]=\"_pin\" [pressed]=\"_pressedB\" [min]=\"_min\" [max]=\"_max\" [disabled]=\"_disabled\" [labelId]=\"_labelId\" *ngIf=\"_dual\"></div>' +\n                    '</div>' +\n                    '<ng-content select=\"[range-right]\"></ng-content>',\n                host: {\n                    '[class.range-disabled]': '_disabled',\n                    '[class.range-pressed]': '_pressed',\n                    '[class.range-has-pin]': '_pin'\n                },\n                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: Range, multi: true }],\n                encapsulation: ViewEncapsulation.None,\n            },] },\n];\n/** @nocollapse */\nRange.ctorParameters = () => [\n    { type: Form, },\n    { type: Haptic, },\n    { type: Item, decorators: [{ type: Optional },] },\n    { type: Config, },\n    { type: Platform, },\n    { type: ElementRef, },\n    { type: Renderer, },\n    { type: DomController, },\n    { type: ChangeDetectorRef, },\n];\nRange.propDecorators = {\n    '_slider': [{ type: ViewChild, args: ['slider',] },],\n    'min': [{ type: Input },],\n    'max': [{ type: Input },],\n    'step': [{ type: Input },],\n    'snaps': [{ type: Input },],\n    'pin': [{ type: Input },],\n    'debounce': [{ type: Input },],\n    'dualKnobs': [{ type: Input },],\n};\n"]}