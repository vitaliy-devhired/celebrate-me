import { Component, ElementRef, HostListener, Renderer, ViewEncapsulation } from '@angular/core';
import { Config } from '../../config/config';
import { NON_TEXT_INPUT_REGEX } from '../../util/dom';
import { BLOCK_ALL, GestureController } from '../../gestures/gesture-controller';
import { isPresent } from '../../util/util';
import { KEY_ENTER, KEY_ESCAPE } from '../../platform/key';
import { NavParams } from '../../navigation/nav-params';
import { Platform } from '../../platform/platform';
import { ViewController } from '../../navigation/view-controller';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../../navigation/view-controller';
import * as ɵngcc2 from '../../config/config';
import * as ɵngcc3 from '../../gestures/gesture-controller';
import * as ɵngcc4 from '../../navigation/nav-params';
import * as ɵngcc5 from '../../platform/platform';
import * as ɵngcc6 from '@angular/common';
import * as ɵngcc7 from '@angular/forms';
import * as ɵngcc8 from '../backdrop/backdrop';
import * as ɵngcc9 from '../button/button';

function AlertCmp_h2_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "h2", 9);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate("id", ctx_r0.hdrId);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r0.d.title, ɵngcc0.ɵɵsanitizeHtml);
} }
function AlertCmp_h3_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "h3", 10);
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵpropertyInterpolate("id", ctx_r1.subHdrId);
    ɵngcc0.ɵɵproperty("innerHTML", ctx_r1.d.subTitle, ɵngcc0.ɵɵsanitizeHtml);
} }
function AlertCmp_div_6_ng_template_1_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 17);
    ɵngcc0.ɵɵlistener("click", function AlertCmp_div_6_ng_template_1_button_1_Template_button_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r10); const i_r8 = restoredCtx.$implicit; const ctx_r9 = ɵngcc0.ɵɵnextContext(3); return ɵngcc0.ɵɵresetView(ctx_r9.rbClick(i_r8)); });
    ɵngcc0.ɵɵelementStart(1, "div", 18);
    ɵngcc0.ɵɵelement(2, "div", 19);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 20);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const i_r8 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("disabled", i_r8.disabled);
    ɵngcc0.ɵɵattribute("aria-checked", i_r8.checked)("id", i_r8.id);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(i_r8.label);
} }
function AlertCmp_div_6_ng_template_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 15);
    ɵngcc0.ɵɵtemplate(1, AlertCmp_div_6_ng_template_1_button_1_Template, 5, 4, "button", 16);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵattribute("aria-labelledby", ctx_r4.hdrId)("aria-activedescendant", ctx_r4.activeId);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r4.d.inputs);
} }
function AlertCmp_div_6_ng_template_2_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 23);
    ɵngcc0.ɵɵlistener("click", function AlertCmp_div_6_ng_template_2_button_1_Template_button_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r14); const i_r12 = restoredCtx.$implicit; const ctx_r13 = ɵngcc0.ɵɵnextContext(3); return ɵngcc0.ɵɵresetView(ctx_r13.cbClick(i_r12)); });
    ɵngcc0.ɵɵelementStart(1, "div", 24);
    ɵngcc0.ɵɵelement(2, "div", 25);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 26);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const i_r12 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("disabled", i_r12.disabled);
    ɵngcc0.ɵɵattribute("aria-checked", i_r12.checked)("id", i_r12.id);
    ɵngcc0.ɵɵadvance(4);
    ɵngcc0.ɵɵtextInterpolate(i_r12.label);
} }
function AlertCmp_div_6_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 21);
    ɵngcc0.ɵɵtemplate(1, AlertCmp_div_6_ng_template_2_button_1_Template, 5, 4, "button", 22);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.d.inputs);
} }
function AlertCmp_div_6_ng_template_3_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r18 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 29)(1, "input", 30);
    ɵngcc0.ɵɵlistener("ngModelChange", function AlertCmp_div_6_ng_template_3_div_1_Template_input_ngModelChange_1_listener($event) { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r18); const i_r16 = restoredCtx.$implicit; return ɵngcc0.ɵɵresetView(i_r16.value = $event); });
    ɵngcc0.ɵɵelementEnd()();
} if (rf & 2) {
    const i_r16 = ctx.$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("placeholder", i_r16.placeholder)("ngModel", i_r16.value)("type", i_r16.type)("min", i_r16.min)("max", i_r16.max)("disabled", i_r16.disabled);
    ɵngcc0.ɵɵattribute("id", i_r16.id);
} }
function AlertCmp_div_6_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 27);
    ɵngcc0.ɵɵtemplate(1, AlertCmp_div_6_ng_template_3_div_1_Template, 2, 7, "div", 28);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r6.d.inputs);
} }
function AlertCmp_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 11);
    ɵngcc0.ɵɵtemplate(1, AlertCmp_div_6_ng_template_1_Template, 2, 3, "ng-template", 12);
    ɵngcc0.ɵɵtemplate(2, AlertCmp_div_6_ng_template_2_Template, 2, 1, "ng-template", 13);
    ɵngcc0.ɵɵtemplate(3, AlertCmp_div_6_ng_template_3_Template, 2, 1, "ng-template", 14);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngSwitch", ctx_r2.inputType);
} }
function AlertCmp_button_8_Template(rf, ctx) { if (rf & 1) {
    const _r21 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 31);
    ɵngcc0.ɵɵlistener("click", function AlertCmp_button_8_Template_button_click_0_listener() { const restoredCtx = ɵngcc0.ɵɵrestoreView(_r21); const b_r19 = restoredCtx.$implicit; const ctx_r20 = ɵngcc0.ɵɵnextContext(); return ɵngcc0.ɵɵresetView(ctx_r20.btnClick(b_r19)); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const b_r19 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngClass", b_r19.cssClass);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(b_r19.text);
} }
const _c0 = function (a0) { return { "alert-button-group-vertical": a0 }; };
export class AlertCmp {
    constructor(_viewCtrl, _elementRef, config, gestureCtrl, params, _renderer, _plt) {
        this._viewCtrl = _viewCtrl;
        this._elementRef = _elementRef;
        this._renderer = _renderer;
        this._plt = _plt;
        // gesture blocker is used to disable gestures dynamically
        this.gestureBlocker = gestureCtrl.createBlocker(BLOCK_ALL);
        this.d = params.data;
        this.mode = this.d.mode || config.get('mode');
        this.keyboardResizes = config.getBoolean('keyboardResizes', false);
        _renderer.setElementClass(_elementRef.nativeElement, `alert-${this.mode}`, true);
        if (this.d.cssClass) {
            this.d.cssClass.split(' ').forEach(cssClass => {
                // Make sure the class isn't whitespace, otherwise it throws exceptions
                if (cssClass.trim() !== '')
                    _renderer.setElementClass(_elementRef.nativeElement, cssClass, true);
            });
        }
        this.id = (++alertIds);
        this.descId = '';
        this.hdrId = 'alert-hdr-' + this.id;
        this.subHdrId = 'alert-subhdr-' + this.id;
        this.msgId = 'alert-msg-' + this.id;
        this.activeId = '';
        this.lastClick = 0;
        if (this.d.message) {
            this.descId = this.msgId;
        }
        else if (this.d.subTitle) {
            this.descId = this.subHdrId;
        }
        if (!this.d.message) {
            this.d.message = '';
        }
    }
    ionViewDidLoad() {
        // normalize the data
        const data = this.d;
        data.buttons = data.buttons.map(button => {
            if (typeof button === 'string') {
                return { text: button };
            }
            return button;
        });
        data.inputs = data.inputs.map((input, index) => {
            let r = {
                type: input.type || 'text',
                name: isPresent(input.name) ? input.name : index + '',
                placeholder: isPresent(input.placeholder) ? input.placeholder : '',
                value: isPresent(input.value) ? input.value : '',
                label: input.label,
                checked: !!input.checked,
                disabled: !!input.disabled,
                id: isPresent(input.id) ? input.id : `alert-input-${this.id}-${index}`,
                handler: isPresent(input.handler) ? input.handler : null,
                min: isPresent(input.min) ? input.min : null,
                max: isPresent(input.max) ? input.max : null
            };
            return r;
        });
        // An alert can be created with several different inputs. Radios,
        // checkboxes and inputs are all accepted, but they cannot be mixed.
        const inputTypes = [];
        data.inputs.forEach(input => {
            if (inputTypes.indexOf(input.type) < 0) {
                inputTypes.push(input.type);
            }
        });
        if (inputTypes.length > 1 && (inputTypes.indexOf('checkbox') > -1 || inputTypes.indexOf('radio') > -1)) {
            console.warn(`Alert cannot mix input types: ${(inputTypes.join('/'))}. Please see alert docs for more info.`);
        }
        this.inputType = inputTypes.length ? inputTypes[0] : null;
        const checkedInput = this.d.inputs.find(input => input.checked);
        if (checkedInput) {
            this.activeId = checkedInput.id;
        }
        const hasTextInput = (this.d.inputs.length && this.d.inputs.some(i => !(NON_TEXT_INPUT_REGEX.test(i.type))));
        if (!this.keyboardResizes && hasTextInput && this._plt.is('mobile')) {
            // this alert has a text input and it's on a mobile device so we should align
            // the alert up high because we need to leave space for the virtual keboard
            // this also helps prevent the layout getting all messed up from
            // the browser trying to scroll the input into a safe area
            this._renderer.setElementClass(this._elementRef.nativeElement, 'alert-top', true);
        }
    }
    ionViewWillEnter() {
        this.gestureBlocker.block();
    }
    ionViewDidLeave() {
        this.gestureBlocker.unblock();
    }
    ionViewDidEnter() {
        // set focus on the first input or button in the alert
        // note that this does not always work and bring up the keyboard on
        // devices since the focus command must come from the user's touch event
        // and ionViewDidEnter is not in the same callstack as the touch event :(
        const focusableEle = this._elementRef.nativeElement.querySelector('input,button');
        if (focusableEle) {
            setTimeout(() => focusableEle.focus());
        }
        this.enabled = true;
    }
    keyUp(ev) {
        if (this.enabled && this._viewCtrl.isLast()) {
            if (ev.keyCode === KEY_ENTER) {
                if (this.lastClick + 1000 < Date.now()) {
                    // do not fire this click if there recently was already a click
                    // this can happen when the button has focus and used the enter
                    // key to click the button. However, both the click handler and
                    // this keyup event will fire, so only allow one of them to go.
                    (void 0) /* console.debug */;
                    let button = this.d.buttons[this.d.buttons.length - 1];
                    this.btnClick(button);
                }
            }
            else if (ev.keyCode === KEY_ESCAPE) {
                (void 0) /* console.debug */;
                this.bdClick();
            }
        }
    }
    btnClick(button) {
        if (!this.enabled) {
            return;
        }
        // keep the time of the most recent button click
        this.lastClick = Date.now();
        let shouldDismiss = true;
        if (button.handler) {
            // a handler has been provided, execute it
            // pass the handler the values from the inputs
            if (button.handler(this.getValues()) === false) {
                // if the return value of the handler is false then do not dismiss
                shouldDismiss = false;
            }
        }
        if (shouldDismiss) {
            this.dismiss(button.role);
        }
    }
    rbClick(checkedInput) {
        if (this.enabled) {
            this.d.inputs.forEach(input => {
                input.checked = (checkedInput === input);
            });
            this.activeId = checkedInput.id;
            if (checkedInput.handler) {
                checkedInput.handler(checkedInput);
            }
        }
    }
    cbClick(checkedInput) {
        if (this.enabled) {
            checkedInput.checked = !checkedInput.checked;
            if (checkedInput.handler) {
                checkedInput.handler(checkedInput);
            }
        }
    }
    bdClick() {
        if (this.enabled && this.d.enableBackdropDismiss) {
            var cancelBtn = this.d.buttons.find(b => b.role === 'cancel');
            if (cancelBtn) {
                this.btnClick(cancelBtn);
            }
            else {
                this.dismiss('backdrop');
            }
        }
    }
    dismiss(role) {
        const opts = {
            minClickBlockDuration: 400
        };
        return this._viewCtrl.dismiss(this.getValues(), role, opts);
    }
    getValues() {
        if (this.inputType === 'radio') {
            // this is an alert with radio buttons (single value select)
            // return the one value which is checked, otherwise undefined
            const checkedInput = this.d.inputs.find(i => i.checked);
            return checkedInput ? checkedInput.value : undefined;
        }
        if (this.inputType === 'checkbox') {
            // this is an alert with checkboxes (multiple value select)
            // return an array of all the checked values
            return this.d.inputs.filter(i => i.checked).map(i => i.value);
        }
        if (this.d.inputs.length === 0) {
            // this is an alert without any options/inputs at all
            return undefined;
        }
        // this is an alert with text inputs
        // return an object of all the values with the input name as the key
        const values = {};
        this.d.inputs.forEach(i => {
            values[i.name] = i.value;
        });
        return values;
    }
    ngOnDestroy() {
        (void 0) /* assert */;
        this.gestureBlocker.destroy();
    }
}
AlertCmp.ɵfac = function AlertCmp_Factory(t) { return new (t || AlertCmp)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ViewController), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Config), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.GestureController), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.NavParams), ɵngcc0.ɵɵdirectiveInject(Renderer), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Platform)); };
AlertCmp.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: AlertCmp, selectors: [["ion-alert"]], hostAttrs: ["role", "dialog"], hostVars: 2, hostBindings: function AlertCmp_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup", function AlertCmp_keyup_HostBindingHandler($event) { return ctx.keyUp($event); }, false, ɵngcc0.ɵɵresolveBody);
    } if (rf & 2) {
        ɵngcc0.ɵɵattribute("aria-labelledby", ctx.hdrId)("aria-describedby", ctx.descId);
    } }, decls: 9, vars: 11, consts: [[3, "click"], [1, "alert-wrapper"], [1, "alert-head"], ["class", "alert-title", 3, "id", "innerHTML", 4, "ngIf"], ["class", "alert-sub-title", 3, "id", "innerHTML", 4, "ngIf"], [1, "alert-message", 3, "id", "innerHTML"], [3, "ngSwitch", 4, "ngIf"], [1, "alert-button-group", 3, "ngClass"], ["ion-button", "alert-button", 3, "ngClass", "click", 4, "ngFor", "ngForOf"], [1, "alert-title", 3, "id", "innerHTML"], [1, "alert-sub-title", 3, "id", "innerHTML"], [3, "ngSwitch"], ["ngSwitchCase", "radio"], ["ngSwitchCase", "checkbox"], ["ngSwitchDefault", ""], ["role", "radiogroup", 1, "alert-radio-group"], ["ion-button", "alert-radio-button", "class", "alert-tappable alert-radio", "role", "radio", 3, "disabled", "click", 4, "ngFor", "ngForOf"], ["ion-button", "alert-radio-button", "role", "radio", 1, "alert-tappable", "alert-radio", 3, "disabled", "click"], [1, "alert-radio-icon"], [1, "alert-radio-inner"], [1, "alert-radio-label"], [1, "alert-checkbox-group"], ["ion-button", "alert-checkbox-button", "class", "alert-tappable alert-checkbox", "role", "checkbox", 3, "disabled", "click", 4, "ngFor", "ngForOf"], ["ion-button", "alert-checkbox-button", "role", "checkbox", 1, "alert-tappable", "alert-checkbox", 3, "disabled", "click"], [1, "alert-checkbox-icon"], [1, "alert-checkbox-inner"], [1, "alert-checkbox-label"], [1, "alert-input-group"], ["class", "alert-input-wrapper", 4, "ngFor", "ngForOf"], [1, "alert-input-wrapper"], ["dir", "auto", 1, "alert-input", 3, "placeholder", "ngModel", "type", "min", "max", "disabled", "ngModelChange"], ["ion-button", "alert-button", 3, "ngClass", "click"]], template: function AlertCmp_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "ion-backdrop", 0);
        ɵngcc0.ɵɵlistener("click", function AlertCmp_Template_ion_backdrop_click_0_listener() { return ctx.bdClick(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(1, "div", 1)(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, AlertCmp_h2_3_Template, 1, 2, "h2", 3);
        ɵngcc0.ɵɵtemplate(4, AlertCmp_h3_4_Template, 1, 2, "h3", 4);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(5, "div", 5);
        ɵngcc0.ɵɵtemplate(6, AlertCmp_div_6_Template, 4, 1, "div", 6);
        ɵngcc0.ɵɵelementStart(7, "div", 7);
        ɵngcc0.ɵɵtemplate(8, AlertCmp_button_8_Template, 2, 2, "button", 8);
        ɵngcc0.ɵɵelementEnd()();
    } if (rf & 2) {
        ɵngcc0.ɵɵclassProp("backdrop-no-tappable", !ctx.d.enableBackdropDismiss);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngIf", ctx.d.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.d.subTitle);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵpropertyInterpolate("id", ctx.msgId);
        ɵngcc0.ɵɵproperty("innerHTML", ctx.d.message, ɵngcc0.ɵɵsanitizeHtml);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.d.inputs.length);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngClass", ɵngcc0.ɵɵpureFunction1(9, _c0, ctx.d.buttons.length > 2));
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.d.buttons);
    } }, dependencies: [ɵngcc6.NgClass, ɵngcc6.NgForOf, ɵngcc6.NgIf, ɵngcc6.NgSwitch, ɵngcc6.NgSwitchCase, ɵngcc6.NgSwitchDefault, ɵngcc7.DefaultValueAccessor, ɵngcc7.NgControlStatus, ɵngcc7.NgModel, ɵngcc8.Backdrop, ɵngcc9.Button], encapsulation: 2 });
/** @nocollapse */
AlertCmp.ctorParameters = () => [
    { type: ViewController, },
    { type: ElementRef, },
    { type: Config, },
    { type: GestureController, },
    { type: NavParams, },
    { type: Renderer, },
    { type: Platform, },
];
AlertCmp.propDecorators = {
    'keyUp': [{ type: HostListener, args: ['body:keyup', ['$event'],] },],
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AlertCmp, [{
        type: Component,
        args: [{
                selector: 'ion-alert',
                template: '<ion-backdrop (click)="bdClick()" [class.backdrop-no-tappable]="!d.enableBackdropDismiss"></ion-backdrop>' +
                    '<div class="alert-wrapper">' +
                    '<div class="alert-head">' +
                    '<h2 id="{{hdrId}}" class="alert-title" *ngIf="d.title" [innerHTML]="d.title"></h2>' +
                    '<h3 id="{{subHdrId}}" class="alert-sub-title" *ngIf="d.subTitle" [innerHTML]="d.subTitle"></h3>' +
                    '</div>' +
                    '<div id="{{msgId}}" class="alert-message" [innerHTML]="d.message"></div>' +
                    '<div *ngIf="d.inputs.length" [ngSwitch]="inputType">' +
                    '<ng-template ngSwitchCase="radio">' +
                    '<div class="alert-radio-group" role="radiogroup" [attr.aria-labelledby]="hdrId" [attr.aria-activedescendant]="activeId">' +
                    '<button ion-button="alert-radio-button" *ngFor="let i of d.inputs" (click)="rbClick(i)" [attr.aria-checked]="i.checked" [disabled]="i.disabled" [attr.id]="i.id" class="alert-tappable alert-radio" role="radio">' +
                    '<div class="alert-radio-icon"><div class="alert-radio-inner"></div></div>' +
                    '<div class="alert-radio-label">' +
                    '{{i.label}}' +
                    '</div>' +
                    '</button>' +
                    '</div>' +
                    '</ng-template>' +
                    '<ng-template ngSwitchCase="checkbox">' +
                    '<div class="alert-checkbox-group">' +
                    '<button ion-button="alert-checkbox-button" *ngFor="let i of d.inputs" (click)="cbClick(i)" [attr.aria-checked]="i.checked" [attr.id]="i.id" [disabled]="i.disabled" class="alert-tappable alert-checkbox" role="checkbox">' +
                    '<div class="alert-checkbox-icon"><div class="alert-checkbox-inner"></div></div>' +
                    '<div class="alert-checkbox-label">' +
                    '{{i.label}}' +
                    '</div>' +
                    '</button>' +
                    '</div>' +
                    '</ng-template>' +
                    '<ng-template ngSwitchDefault>' +
                    '<div class="alert-input-group">' +
                    '<div *ngFor="let i of d.inputs" class="alert-input-wrapper">' +
                    '<input [placeholder]="i.placeholder" [(ngModel)]="i.value" [type]="i.type" dir="auto" [min]="i.min" [max]="i.max" [attr.id]="i.id" [disabled]="i.disabled" class="alert-input">' +
                    '</div>' +
                    '</div>' +
                    '</ng-template>' +
                    '</div>' +
                    '<div class="alert-button-group" [ngClass]="{\'alert-button-group-vertical\':d.buttons.length>2}">' +
                    '<button ion-button="alert-button" *ngFor="let b of d.buttons" (click)="btnClick(b)" [ngClass]="b.cssClass">' +
                    '{{b.text}}' +
                    '</button>' +
                    '</div>' +
                    '</div>',
                host: {
                    'role': 'dialog',
                    '[attr.aria-labelledby]': 'hdrId',
                    '[attr.aria-describedby]': 'descId'
                },
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: ɵngcc1.ViewController }, { type: ɵngcc0.ElementRef }, { type: ɵngcc2.Config }, { type: ɵngcc3.GestureController }, { type: ɵngcc4.NavParams }, { type: Renderer }, { type: ɵngcc5.Platform }]; }, { keyUp: [{
            type: HostListener,
            args: ['body:keyup', ['$event']]
        }] }); })();
let alertIds = -1;

//# sourceMappingURL=alert-component.js.map