{"version":3,"file":"alert-component.js","sources":["alert-component.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6PAqDE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF;AACA","sourcesContent":["import { Component, ElementRef, HostListener, Renderer, ViewEncapsulation } from '@angular/core';\nimport { Config } from '../../config/config';\nimport { NON_TEXT_INPUT_REGEX } from '../../util/dom';\nimport { BLOCK_ALL, GestureController } from '../../gestures/gesture-controller';\nimport { isPresent } from '../../util/util';\nimport { KEY_ENTER, KEY_ESCAPE } from '../../platform/key';\nimport { NavParams } from '../../navigation/nav-params';\nimport { Platform } from '../../platform/platform';\nimport { ViewController } from '../../navigation/view-controller';\n/**\n * @hidden\n */\nexport class AlertCmp {\n    constructor(_viewCtrl, _elementRef, config, gestureCtrl, params, _renderer, _plt) {\n        this._viewCtrl = _viewCtrl;\n        this._elementRef = _elementRef;\n        this._renderer = _renderer;\n        this._plt = _plt;\n        // gesture blocker is used to disable gestures dynamically\n        this.gestureBlocker = gestureCtrl.createBlocker(BLOCK_ALL);\n        this.d = params.data;\n        this.mode = this.d.mode || config.get('mode');\n        this.keyboardResizes = config.getBoolean('keyboardResizes', false);\n        _renderer.setElementClass(_elementRef.nativeElement, `alert-${this.mode}`, true);\n        if (this.d.cssClass) {\n            this.d.cssClass.split(' ').forEach(cssClass => {\n                // Make sure the class isn't whitespace, otherwise it throws exceptions\n                if (cssClass.trim() !== '')\n                    _renderer.setElementClass(_elementRef.nativeElement, cssClass, true);\n            });\n        }\n        this.id = (++alertIds);\n        this.descId = '';\n        this.hdrId = 'alert-hdr-' + this.id;\n        this.subHdrId = 'alert-subhdr-' + this.id;\n        this.msgId = 'alert-msg-' + this.id;\n        this.activeId = '';\n        this.lastClick = 0;\n        if (this.d.message) {\n            this.descId = this.msgId;\n        }\n        else if (this.d.subTitle) {\n            this.descId = this.subHdrId;\n        }\n        if (!this.d.message) {\n            this.d.message = '';\n        }\n    }\n    ionViewDidLoad() {\n        // normalize the data\n        const data = this.d;\n        data.buttons = data.buttons.map(button => {\n            if (typeof button === 'string') {\n                return { text: button };\n            }\n            return button;\n        });\n        data.inputs = data.inputs.map((input, index) => {\n            let r = {\n                type: input.type || 'text',\n                name: isPresent(input.name) ? input.name : index + '',\n                placeholder: isPresent(input.placeholder) ? input.placeholder : '',\n                value: isPresent(input.value) ? input.value : '',\n                label: input.label,\n                checked: !!input.checked,\n                disabled: !!input.disabled,\n                id: isPresent(input.id) ? input.id : `alert-input-${this.id}-${index}`,\n                handler: isPresent(input.handler) ? input.handler : null,\n                min: isPresent(input.min) ? input.min : null,\n                max: isPresent(input.max) ? input.max : null\n            };\n            return r;\n        });\n        // An alert can be created with several different inputs. Radios,\n        // checkboxes and inputs are all accepted, but they cannot be mixed.\n        const inputTypes = [];\n        data.inputs.forEach(input => {\n            if (inputTypes.indexOf(input.type) < 0) {\n                inputTypes.push(input.type);\n            }\n        });\n        if (inputTypes.length > 1 && (inputTypes.indexOf('checkbox') > -1 || inputTypes.indexOf('radio') > -1)) {\n            console.warn(`Alert cannot mix input types: ${(inputTypes.join('/'))}. Please see alert docs for more info.`);\n        }\n        this.inputType = inputTypes.length ? inputTypes[0] : null;\n        const checkedInput = this.d.inputs.find(input => input.checked);\n        if (checkedInput) {\n            this.activeId = checkedInput.id;\n        }\n        const hasTextInput = (this.d.inputs.length && this.d.inputs.some(i => !(NON_TEXT_INPUT_REGEX.test(i.type))));\n        if (!this.keyboardResizes && hasTextInput && this._plt.is('mobile')) {\n            // this alert has a text input and it's on a mobile device so we should align\n            // the alert up high because we need to leave space for the virtual keboard\n            // this also helps prevent the layout getting all messed up from\n            // the browser trying to scroll the input into a safe area\n            this._renderer.setElementClass(this._elementRef.nativeElement, 'alert-top', true);\n        }\n    }\n    ionViewWillEnter() {\n        this.gestureBlocker.block();\n    }\n    ionViewDidLeave() {\n        this.gestureBlocker.unblock();\n    }\n    ionViewDidEnter() {\n        // set focus on the first input or button in the alert\n        // note that this does not always work and bring up the keyboard on\n        // devices since the focus command must come from the user's touch event\n        // and ionViewDidEnter is not in the same callstack as the touch event :(\n        const focusableEle = this._elementRef.nativeElement.querySelector('input,button');\n        if (focusableEle) {\n            setTimeout(() => focusableEle.focus());\n        }\n        this.enabled = true;\n    }\n    keyUp(ev) {\n        if (this.enabled && this._viewCtrl.isLast()) {\n            if (ev.keyCode === KEY_ENTER) {\n                if (this.lastClick + 1000 < Date.now()) {\n                    // do not fire this click if there recently was already a click\n                    // this can happen when the button has focus and used the enter\n                    // key to click the button. However, both the click handler and\n                    // this keyup event will fire, so only allow one of them to go.\n                    (void 0) /* console.debug */;\n                    let button = this.d.buttons[this.d.buttons.length - 1];\n                    this.btnClick(button);\n                }\n            }\n            else if (ev.keyCode === KEY_ESCAPE) {\n                (void 0) /* console.debug */;\n                this.bdClick();\n            }\n        }\n    }\n    btnClick(button) {\n        if (!this.enabled) {\n            return;\n        }\n        // keep the time of the most recent button click\n        this.lastClick = Date.now();\n        let shouldDismiss = true;\n        if (button.handler) {\n            // a handler has been provided, execute it\n            // pass the handler the values from the inputs\n            if (button.handler(this.getValues()) === false) {\n                // if the return value of the handler is false then do not dismiss\n                shouldDismiss = false;\n            }\n        }\n        if (shouldDismiss) {\n            this.dismiss(button.role);\n        }\n    }\n    rbClick(checkedInput) {\n        if (this.enabled) {\n            this.d.inputs.forEach(input => {\n                input.checked = (checkedInput === input);\n            });\n            this.activeId = checkedInput.id;\n            if (checkedInput.handler) {\n                checkedInput.handler(checkedInput);\n            }\n        }\n    }\n    cbClick(checkedInput) {\n        if (this.enabled) {\n            checkedInput.checked = !checkedInput.checked;\n            if (checkedInput.handler) {\n                checkedInput.handler(checkedInput);\n            }\n        }\n    }\n    bdClick() {\n        if (this.enabled && this.d.enableBackdropDismiss) {\n            var cancelBtn = this.d.buttons.find(b => b.role === 'cancel');\n            if (cancelBtn) {\n                this.btnClick(cancelBtn);\n            }\n            else {\n                this.dismiss('backdrop');\n            }\n        }\n    }\n    dismiss(role) {\n        const opts = {\n            minClickBlockDuration: 400\n        };\n        return this._viewCtrl.dismiss(this.getValues(), role, opts);\n    }\n    getValues() {\n        if (this.inputType === 'radio') {\n            // this is an alert with radio buttons (single value select)\n            // return the one value which is checked, otherwise undefined\n            const checkedInput = this.d.inputs.find(i => i.checked);\n            return checkedInput ? checkedInput.value : undefined;\n        }\n        if (this.inputType === 'checkbox') {\n            // this is an alert with checkboxes (multiple value select)\n            // return an array of all the checked values\n            return this.d.inputs.filter(i => i.checked).map(i => i.value);\n        }\n        if (this.d.inputs.length === 0) {\n            // this is an alert without any options/inputs at all\n            return undefined;\n        }\n        // this is an alert with text inputs\n        // return an object of all the values with the input name as the key\n        const values = {};\n        this.d.inputs.forEach(i => {\n            values[i.name] = i.value;\n        });\n        return values;\n    }\n    ngOnDestroy() {\n        (void 0) /* assert */;\n        this.gestureBlocker.destroy();\n    }\n}\nAlertCmp.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-alert',\n                template: '<ion-backdrop (click)=\"bdClick()\" [class.backdrop-no-tappable]=\"!d.enableBackdropDismiss\"></ion-backdrop>' +\n                    '<div class=\"alert-wrapper\">' +\n                    '<div class=\"alert-head\">' +\n                    '<h2 id=\"{{hdrId}}\" class=\"alert-title\" *ngIf=\"d.title\" [innerHTML]=\"d.title\"></h2>' +\n                    '<h3 id=\"{{subHdrId}}\" class=\"alert-sub-title\" *ngIf=\"d.subTitle\" [innerHTML]=\"d.subTitle\"></h3>' +\n                    '</div>' +\n                    '<div id=\"{{msgId}}\" class=\"alert-message\" [innerHTML]=\"d.message\"></div>' +\n                    '<div *ngIf=\"d.inputs.length\" [ngSwitch]=\"inputType\">' +\n                    '<ng-template ngSwitchCase=\"radio\">' +\n                    '<div class=\"alert-radio-group\" role=\"radiogroup\" [attr.aria-labelledby]=\"hdrId\" [attr.aria-activedescendant]=\"activeId\">' +\n                    '<button ion-button=\"alert-radio-button\" *ngFor=\"let i of d.inputs\" (click)=\"rbClick(i)\" [attr.aria-checked]=\"i.checked\" [disabled]=\"i.disabled\" [attr.id]=\"i.id\" class=\"alert-tappable alert-radio\" role=\"radio\">' +\n                    '<div class=\"alert-radio-icon\"><div class=\"alert-radio-inner\"></div></div>' +\n                    '<div class=\"alert-radio-label\">' +\n                    '{{i.label}}' +\n                    '</div>' +\n                    '</button>' +\n                    '</div>' +\n                    '</ng-template>' +\n                    '<ng-template ngSwitchCase=\"checkbox\">' +\n                    '<div class=\"alert-checkbox-group\">' +\n                    '<button ion-button=\"alert-checkbox-button\" *ngFor=\"let i of d.inputs\" (click)=\"cbClick(i)\" [attr.aria-checked]=\"i.checked\" [attr.id]=\"i.id\" [disabled]=\"i.disabled\" class=\"alert-tappable alert-checkbox\" role=\"checkbox\">' +\n                    '<div class=\"alert-checkbox-icon\"><div class=\"alert-checkbox-inner\"></div></div>' +\n                    '<div class=\"alert-checkbox-label\">' +\n                    '{{i.label}}' +\n                    '</div>' +\n                    '</button>' +\n                    '</div>' +\n                    '</ng-template>' +\n                    '<ng-template ngSwitchDefault>' +\n                    '<div class=\"alert-input-group\">' +\n                    '<div *ngFor=\"let i of d.inputs\" class=\"alert-input-wrapper\">' +\n                    '<input [placeholder]=\"i.placeholder\" [(ngModel)]=\"i.value\" [type]=\"i.type\" dir=\"auto\" [min]=\"i.min\" [max]=\"i.max\" [attr.id]=\"i.id\" [disabled]=\"i.disabled\" class=\"alert-input\">' +\n                    '</div>' +\n                    '</div>' +\n                    '</ng-template>' +\n                    '</div>' +\n                    '<div class=\"alert-button-group\" [ngClass]=\"{\\'alert-button-group-vertical\\':d.buttons.length>2}\">' +\n                    '<button ion-button=\"alert-button\" *ngFor=\"let b of d.buttons\" (click)=\"btnClick(b)\" [ngClass]=\"b.cssClass\">' +\n                    '{{b.text}}' +\n                    '</button>' +\n                    '</div>' +\n                    '</div>',\n                host: {\n                    'role': 'dialog',\n                    '[attr.aria-labelledby]': 'hdrId',\n                    '[attr.aria-describedby]': 'descId'\n                },\n                encapsulation: ViewEncapsulation.None,\n            },] },\n];\n/** @nocollapse */\nAlertCmp.ctorParameters = () => [\n    { type: ViewController, },\n    { type: ElementRef, },\n    { type: Config, },\n    { type: GestureController, },\n    { type: NavParams, },\n    { type: Renderer, },\n    { type: Platform, },\n];\nAlertCmp.propDecorators = {\n    'keyUp': [{ type: HostListener, args: ['body:keyup', ['$event'],] },],\n};\nlet alertIds = -1;\n"]}