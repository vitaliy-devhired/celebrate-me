import { Component, ElementRef, EventEmitter, Input, Optional, Output, Renderer, ViewChild, ViewEncapsulation } from '@angular/core';
import { NgControl } from '@angular/forms';
import { Config } from '../../config/config';
import { BaseInput } from '../../util/base-input';
import { isPresent, isTrueProperty } from '../../util/util';
import { TimeoutDebouncer } from '../../util/debouncer';
import { Platform } from '../../platform/platform';
/**
 * @name Searchbar
 * @module ionic
 * @description
 * Manages the display of a Searchbar which can be used to search or filter items.
 *
 * @usage
 * ```html
 * <ion-searchbar
 *   [(ngModel)]="myInput"
 *   [showCancelButton]="shouldShowCancel"
 *   (ionInput)="onInput($event)"
 *   (ionCancel)="onCancel($event)">
 * </ion-searchbar>
 * ```
 *
 * @demo /docs/demos/src/searchbar/
 * @see {@link /docs/components#searchbar Searchbar Component Docs}
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../../config/config';
import * as ɵngcc2 from '../../platform/platform';
import * as ɵngcc3 from '@angular/forms';
import * as ɵngcc4 from '../button/button';
import * as ɵngcc5 from '../icon/icon';

const _c0 = ["searchbarInput"];
const _c1 = ["searchbarIcon"];
const _c2 = ["cancelButton"];
export class Searchbar extends BaseInput {
    constructor(config, _plt, elementRef, renderer, ngControl) {
        super(config, elementRef, renderer, 'searchbar', '', null, null, ngControl);
        this._plt = _plt;
        this._shouldBlur = true;
        this._shouldAlignLeft = true;
        this._isCancelVisible = false;
        this._spellcheck = false;
        this._autocomplete = 'off';
        this._autocorrect = 'off';
        this._isActive = false;
        this._showCancelButton = false;
        this._animated = false;
        this._inputDebouncer = new TimeoutDebouncer(0);
        /**
         * @input {string} Set the the cancel button text. Default: `"Cancel"`.
         */
        this.cancelButtonText = 'Cancel';
        /**
         * @input {string} Set the input's placeholder. Default `"Search"`.
         */
        this.placeholder = 'Search';
        /**
         * @input {string} Set the type of the input. Values: `"text"`, `"password"`, `"email"`, `"number"`, `"search"`, `"tel"`, `"url"`. Default `"search"`.
         */
        this.type = 'search';
        /**
         * @output {event} Emitted when the Searchbar input has changed, including when it's cleared.
         */
        this.ionInput = new EventEmitter();
        /**
         * @output {event} Emitted when the cancel button is clicked.
         */
        this.ionCancel = new EventEmitter();
        /**
         * @output {event} Emitted when the clear input button is clicked.
         */
        this.ionClear = new EventEmitter();
        this.debounce = 250;
    }
    /**
     * @input {boolean} If true, show the cancel button. Default `false`.
     */
    get showCancelButton() {
        return this._showCancelButton;
    }
    set showCancelButton(val) {
        this._showCancelButton = isTrueProperty(val);
    }
    /**
     * @input {number} How long, in milliseconds, to wait to trigger the `ionInput` event after each keystroke. Default `250`.
     */
    get debounce() {
        return this._debouncer.wait;
    }
    set debounce(val) {
        this._debouncer.wait = val;
        this._inputDebouncer.wait = val;
    }
    /**
     * @input {string} Set the input's autocomplete property. Values: `"on"`, `"off"`. Default `"off"`.
     */
    set autocomplete(val) {
        this._autocomplete = (val === '' || val === 'on') ? 'on' : this._config.get('autocomplete', 'off');
    }
    /**
     * @input {string} Set the input's autocorrect property. Values: `"on"`, `"off"`. Default `"off"`.
     */
    set autocorrect(val) {
        this._autocorrect = (val === '' || val === 'on') ? 'on' : this._config.get('autocorrect', 'off');
    }
    /**
     * @input {string|boolean} Set the input's spellcheck property. Values: `true`, `false`. Default `false`.
     */
    set spellcheck(val) {
        this._spellcheck = (val === '' || val === 'true' || val === true) ? true : this._config.getBoolean('spellcheck', false);
    }
    /**
     * @input {boolean} If true, enable searchbar animation. Default `false`.
     */
    get animated() {
        return this._animated;
    }
    set animated(val) {
        this._animated = isTrueProperty(val);
    }
    /**
     * @hidden
     * On Initialization check for attributes
     */
    ngOnInit() {
        const showCancelButton = this.showCancelButton;
        if (typeof showCancelButton === 'string') {
            this.showCancelButton = (showCancelButton === '' || showCancelButton === 'true');
        }
    }
    /**
     * @hidden
     */
    _inputUpdated() {
        const ele = this._searchbarInput.nativeElement;
        const value = this._value;
        // It is important not to re-assign the value if it is the same, because,
        // otherwise, the caret is moved to the end of the input
        if (ele.value !== value) {
            ele.value = value;
        }
        this.positionElements();
    }
    /**
     * @hidden
     * Positions the input search icon, placeholder, and the cancel button
     * based on the input value and if it is focused. (ios only)
     */
    positionElements() {
        const isAnimated = this._animated;
        const prevAlignLeft = this._shouldAlignLeft;
        const shouldAlignLeft = (!isAnimated || (this._value && this._value.toString().trim() !== '') || this._isFocus === true);
        this._shouldAlignLeft = shouldAlignLeft;
        if (this._mode !== 'ios') {
            return;
        }
        if (prevAlignLeft !== shouldAlignLeft) {
            this.positionPlaceholder();
        }
        if (isAnimated) {
            this.positionCancelButton();
        }
    }
    positionPlaceholder() {
        const inputEle = this._searchbarInput.nativeElement;
        const iconEle = this._searchbarIcon.nativeElement;
        if (this._shouldAlignLeft) {
            inputEle.removeAttribute('style');
            iconEle.removeAttribute('style');
        }
        else {
            // Create a dummy span to get the placeholder width
            var doc = this._plt.doc();
            var tempSpan = doc.createElement('span');
            tempSpan.innerHTML = this.placeholder;
            doc.body.appendChild(tempSpan);
            // Get the width of the span then remove it
            var textWidth = tempSpan.offsetWidth;
            doc.body.removeChild(tempSpan);
            // Set the input padding start
            var inputLeft = 'calc(50% - ' + (textWidth / 2) + 'px)';
            if (this._plt.isRTL) {
                inputEle.style.paddingRight = inputLeft;
            }
            else {
                inputEle.style.paddingLeft = inputLeft;
            }
            // Set the icon margin start
            var iconLeft = 'calc(50% - ' + ((textWidth / 2) + 30) + 'px)';
            if (this._plt.isRTL) {
                iconEle.style.marginRight = iconLeft;
            }
            else {
                iconEle.style.marginLeft = iconLeft;
            }
        }
    }
    /**
     * @hidden
     * Show the iOS Cancel button on focus, hide it offscreen otherwise
     */
    positionCancelButton() {
        const showShowCancel = this._isFocus;
        if (showShowCancel !== this._isCancelVisible) {
            var cancelStyleEle = this._cancelButton.nativeElement;
            var cancelStyle = cancelStyleEle.style;
            this._isCancelVisible = showShowCancel;
            if (showShowCancel) {
                if (this._plt.isRTL) {
                    cancelStyle.marginLeft = '0';
                }
                else {
                    cancelStyle.marginRight = '0';
                }
            }
            else {
                var offset = cancelStyleEle.offsetWidth;
                if (offset > 0) {
                    if (this._plt.isRTL) {
                        cancelStyle.marginLeft = -offset + 'px';
                    }
                    else {
                        cancelStyle.marginRight = -offset + 'px';
                    }
                }
            }
        }
    }
    /**
     * @hidden
     * Update the Searchbar input value when the input changes
     */
    inputChanged(ev) {
        this.value = ev.target.value;
        this._inputDebouncer.debounce(() => {
            this.ionInput.emit(ev);
        });
    }
    /**
     * @hidden
     * Sets the Searchbar to focused and active on input focus.
     */
    inputFocused() {
        this._isActive = true;
        this._fireFocus();
        this.positionElements();
    }
    /**
     * @hidden
     * Sets the Searchbar to not focused and checks if it should align left
     * based on whether there is a value in the searchbar or not.
     */
    inputBlurred() {
        // _shouldBlur determines if it should blur
        // if we are clearing the input we still want to stay focused in the input
        if (this._shouldBlur === false) {
            this._searchbarInput.nativeElement.focus();
            this._shouldBlur = true;
            return;
        }
        this._fireBlur();
        this.positionElements();
    }
    /**
     * @hidden
     * Clears the input field and triggers the control change.
     */
    clearInput(ev) {
        this.ionClear.emit(ev);
        // setTimeout() fixes https://github.com/ionic-team/ionic/issues/7527
        // wait for 4 frames
        setTimeout(() => {
            let value = this._value;
            if (isPresent(value) && value !== '') {
                this.value = ''; // DOM WRITE
                this.ionInput.emit(ev);
            }
        }, 16 * 4);
        this._shouldBlur = false;
    }
    /**
     * @hidden
     * Clears the input field and tells the input to blur since
     * the clearInput function doesn't want the input to blur
     * then calls the custom cancel function if the user passed one in.
     */
    cancelSearchbar(ev) {
        this.ionCancel.emit(ev);
        this.clearInput(ev);
        this._shouldBlur = true;
        this._isActive = false;
    }
    setFocus() {
        this._renderer.invokeElementMethod(this._searchbarInput.nativeElement, 'focus');
    }
}
Searchbar.ɵfac = function Searchbar_Factory(t) { return new (t || Searchbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Config), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.NgControl, 8)); };
Searchbar.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: Searchbar, selectors: [["ion-searchbar"]], viewQuery: function Searchbar_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 5);
        ɵngcc0.ɵɵviewQuery(_c1, 5);
        ɵngcc0.ɵɵviewQuery(_c2, 5, ElementRef);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._searchbarInput = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._searchbarIcon = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._cancelButton = _t.first);
    } }, hostVars: 12, hostBindings: function Searchbar_HostBindings(rf, ctx) { if (rf & 2) {
        ɵngcc0.ɵɵclassProp("searchbar-animated", ctx._animated)("searchbar-has-value", ctx._value)("searchbar-active", ctx._isActive)("searchbar-show-cancel", ctx._showCancelButton)("searchbar-left-aligned", ctx._shouldAlignLeft)("searchbar-has-focus", ctx._isFocus);
    } }, inputs: { cancelButtonText: "cancelButtonText", placeholder: "placeholder", type: "type", debounce: "debounce", showCancelButton: "showCancelButton", autocomplete: "autocomplete", autocorrect: "autocorrect", spellcheck: "spellcheck", animated: "animated" }, outputs: { ionInput: "ionInput", ionCancel: "ionCancel", ionClear: "ionClear" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 11, vars: 8, consts: [[1, "searchbar-input-container"], ["ion-button", "", "mode", "md", "clear", "", "color", "dark", "type", "button", 1, "searchbar-md-cancel", 3, "click", "mousedown"], ["name", "md-arrow-back"], [1, "searchbar-search-icon"], ["searchbarIcon", ""], ["dir", "auto", 1, "searchbar-input", 3, "input", "blur", "focus"], ["searchbarInput", ""], ["ion-button", "", "clear", "", "type", "button", "aria-label", "clear", 1, "searchbar-clear-icon", 3, "mode", "click", "mousedown"], ["ion-button", "", "mode", "ios", "clear", "", "type", "button", 1, "searchbar-ios-cancel", 3, "tabindex", "click", "mousedown"], ["cancelButton", ""]], template: function Searchbar_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0)(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function Searchbar_Template_button_click_1_listener($event) { return ctx.cancelSearchbar($event); })("mousedown", function Searchbar_Template_button_mousedown_1_listener($event) { return ctx.cancelSearchbar($event); });
        ɵngcc0.ɵɵelement(2, "ion-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(3, "div", 3, 4);
        ɵngcc0.ɵɵelementStart(5, "input", 5, 6);
        ɵngcc0.ɵɵlistener("input", function Searchbar_Template_input_input_5_listener($event) { return ctx.inputChanged($event); })("blur", function Searchbar_Template_input_blur_5_listener() { return ctx.inputBlurred(); })("focus", function Searchbar_Template_input_focus_5_listener() { return ctx.inputFocused(); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(7, "button", 7);
        ɵngcc0.ɵɵlistener("click", function Searchbar_Template_button_click_7_listener($event) { return ctx.clearInput($event); })("mousedown", function Searchbar_Template_button_mousedown_7_listener($event) { return ctx.clearInput($event); });
        ɵngcc0.ɵɵelementEnd()();
        ɵngcc0.ɵɵelementStart(8, "button", 8, 9);
        ɵngcc0.ɵɵlistener("click", function Searchbar_Template_button_click_8_listener($event) { return ctx.cancelSearchbar($event); })("mousedown", function Searchbar_Template_button_mousedown_8_listener($event) { return ctx.cancelSearchbar($event); });
        ɵngcc0.ɵɵtext(10);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵattribute("placeholder", ctx.placeholder)("type", ctx.type)("autocomplete", ctx._autocomplete)("autocorrect", ctx._autocorrect)("spellcheck", ctx._spellcheck);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("mode", ctx._mode);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("tabindex", ctx._isActive ? 1 : -1);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.cancelButtonText);
    } }, dependencies: [ɵngcc4.Button, ɵngcc5.Icon], encapsulation: 2 });
/** @nocollapse */
Searchbar.ctorParameters = () => [
    { type: Config, },
    { type: Platform, },
    { type: ElementRef, },
    { type: Renderer, },
    { type: NgControl, decorators: [{ type: Optional },] },
];
Searchbar.propDecorators = {
    'cancelButtonText': [{ type: Input },],
    'showCancelButton': [{ type: Input },],
    'debounce': [{ type: Input },],
    'placeholder': [{ type: Input },],
    'autocomplete': [{ type: Input },],
    'autocorrect': [{ type: Input },],
    'spellcheck': [{ type: Input },],
    'type': [{ type: Input },],
    'animated': [{ type: Input },],
    'ionInput': [{ type: Output },],
    'ionCancel': [{ type: Output },],
    'ionClear': [{ type: Output },],
    '_searchbarInput': [{ type: ViewChild, args: ['searchbarInput',] },],
    '_searchbarIcon': [{ type: ViewChild, args: ['searchbarIcon',] },],
    '_cancelButton': [{ type: ViewChild, args: ['cancelButton', { read: ElementRef },] },],
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(Searchbar, [{
        type: Component,
        args: [{
                selector: 'ion-searchbar',
                template: '<div class="searchbar-input-container">' +
                    '<button ion-button mode="md" (click)="cancelSearchbar($event)" (mousedown)="cancelSearchbar($event)" clear color="dark" class="searchbar-md-cancel" type="button">' +
                    '<ion-icon name="md-arrow-back"></ion-icon>' +
                    '</button>' +
                    '<div #searchbarIcon class="searchbar-search-icon"></div>' +
                    '<input #searchbarInput class="searchbar-input" (input)="inputChanged($event)" (blur)="inputBlurred()" (focus)="inputFocused()" ' +
                    'dir="auto" ' +
                    '[attr.placeholder]="placeholder" ' +
                    '[attr.type]="type" ' +
                    '[attr.autocomplete]="_autocomplete" ' +
                    '[attr.autocorrect]="_autocorrect" ' +
                    '[attr.spellcheck]="_spellcheck">' +
                    '<button ion-button clear class="searchbar-clear-icon" [mode]="_mode" (click)="clearInput($event)" (mousedown)="clearInput($event)" type="button" aria-label="clear"></button>' +
                    '</div>' +
                    '<button ion-button #cancelButton mode="ios" [tabindex]="_isActive ? 1 : -1" clear (click)="cancelSearchbar($event)" (mousedown)="cancelSearchbar($event)" class="searchbar-ios-cancel" type="button">{{cancelButtonText}}</button>',
                host: {
                    '[class.searchbar-animated]': '_animated',
                    '[class.searchbar-has-value]': '_value',
                    '[class.searchbar-active]': '_isActive',
                    '[class.searchbar-show-cancel]': '_showCancelButton',
                    '[class.searchbar-left-aligned]': '_shouldAlignLeft',
                    '[class.searchbar-has-focus]': '_isFocus'
                },
                encapsulation: ViewEncapsulation.None
            }]
    }], function () { return [{ type: ɵngcc1.Config }, { type: ɵngcc2.Platform }, { type: ɵngcc0.ElementRef }, { type: Renderer }, { type: ɵngcc3.NgControl, decorators: [{
                type: Optional
            }] }]; }, { cancelButtonText: [{
            type: Input
        }], placeholder: [{
            type: Input
        }], type: [{
            type: Input
        }], ionInput: [{
            type: Output
        }], ionCancel: [{
            type: Output
        }], ionClear: [{
            type: Output
        }], debounce: [{
            type: Input
        }], showCancelButton: [{
            type: Input
        }], autocomplete: [{
            type: Input
        }], autocorrect: [{
            type: Input
        }], spellcheck: [{
            type: Input
        }], animated: [{
            type: Input
        }], _searchbarInput: [{
            type: ViewChild,
            args: ['searchbarInput']
        }], _searchbarIcon: [{
            type: ViewChild,
            args: ['searchbarIcon']
        }], _cancelButton: [{
            type: ViewChild,
            args: ['cancelButton', { read: ElementRef }]
        }] }); })();

//# sourceMappingURL=searchbar.js.map