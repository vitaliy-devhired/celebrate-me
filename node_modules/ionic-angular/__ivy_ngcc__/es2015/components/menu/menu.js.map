{"version":3,"file":"menu.js","sources":["menu.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;kFAaE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF","sourcesContent":["import { ChangeDetectionStrategy, Component, ContentChild, ElementRef, EventEmitter, Input, Output, Renderer, ViewChild, ViewEncapsulation, forwardRef } from '@angular/core';\nimport { App } from '../app/app';\nimport { Backdrop } from '../backdrop/backdrop';\nimport { Config } from '../../config/config';\nimport { Content } from '../content/content';\nimport { DomController } from '../../platform/dom-controller';\nimport { GESTURE_GO_BACK_SWIPE, GestureController, } from '../../gestures/gesture-controller';\nimport { isRightSide, isTrueProperty } from '../../util/util';\nimport { Keyboard } from '../../platform/keyboard';\nimport { MenuContentGesture } from './menu-gestures';\nimport { MenuController } from '../app/menu-controller';\nimport { Nav } from '../nav/nav';\nimport { Platform } from '../../platform/platform';\nimport { UIEventManager } from '../../gestures/ui-event-manager';\nimport { RootNode } from '../split-pane/split-pane';\n/**\n * @name Menu\n * @description\n * The Menu component is a navigation drawer that slides in from the side of the current\n * view. By default, it slides in from the left, but the side can be overridden. The menu\n * will be displayed differently based on the mode, however the display type can be changed\n * to any of the available [menu types](#menu-types). The menu element should be a sibling\n * to the app's content element. There can be any number of menus attached to the content.\n * These can be controlled from the templates, or programmatically using the [MenuController](../../app/MenuController).\n *\n * @usage\n *\n * ```html\n * <ion-menu [content]=\"mycontent\">\n *   <ion-content>\n *     <ion-list>\n *       <p>some menu content, could be list items</p>\n *     </ion-list>\n *   </ion-content>\n * </ion-menu>\n *\n * <ion-nav #mycontent [root]=\"rootPage\"></ion-nav>\n * ```\n *\n * To add a menu to an app, the `<ion-menu>` element should be added as a sibling to the `ion-nav` it will belong\n * to. A [local variable](https://angular.io/docs/ts/latest/guide/user-input.html#local-variables)\n * should be added to the `ion-nav` and passed to the `ion-menu`s `content` property.\n *\n * This tells the menu what it is bound to and what element to watch for gestures.\n * In the below example, `content` is using [property binding](https://angular.io/docs/ts/latest/guide/template-syntax.html#!#property-binding)\n * because `mycontent` is a reference to the `<ion-nav>` element, and not a string.\n *\n *\n * ### Opening/Closing Menus\n *\n * There are several ways to open or close a menu. The menu can be **toggled** open or closed\n * from the template using the [MenuToggle](../MenuToggle) directive. It can also be\n * **closed** from the template using the [MenuClose](../MenuClose) directive. To display a menu\n * programmatically, inject the [MenuController](../MenuController) provider and call any of the\n * `MenuController` methods.\n *\n *\n * ### Menu Types\n *\n * The menu supports several display types: `overlay`, `reveal` and `push`. By default,\n * it will use the correct type based on the mode, but this can be changed. The default\n * type for both Material Design and Windows mode is `overlay`, and `reveal` is the default\n * type for iOS mode. The menu type can be changed in the app's [config](../../config/Config)\n * via the `menuType` property, or passed in the `type` property on the `<ion-menu>` element.\n * See [usage](#usage) below for examples of changing the menu type.\n *\n *\n * ### Navigation Bar Behavior\n *\n * If a [MenuToggle](../MenuToggle) button is added to the [Navbar](../../navbar/Navbar) of\n * a page, the button will only appear when the page it's in is currently a root page. The\n * root page is the initial page loaded in the app, or a page that has been set as the root\n * using the [setRoot](../../nav/NavController/#setRoot) method on the [NavController](../../nav/NavController).\n *\n * For example, say the application has two pages, `Page1` and `Page2`, and both have a\n * `MenuToggle` button in their navigation bars. Assume the initial page loaded into the app\n * is `Page1`, making it the root page. `Page1` will display the `MenuToggle` button, but once\n * `Page2` is pushed onto the navigation stack, the `MenuToggle` will not be displayed.\n *\n *\n * ### Persistent Menus\n *\n * Persistent menus display the [MenuToggle](../MenuToggle) button in the [Navbar](../../navbar/Navbar)\n * on all pages in the navigation stack. To make a menu persistent set `persistent` to `true` on the\n * `<ion-menu>` element. Note that this will only affect the `MenuToggle` button in the `Navbar` attached\n * to the `Menu` with `persistent` set to true, any other `MenuToggle` buttons will not be affected.\n * ### Menu Side\n *\n * By default, menus slide in from the left, but this can be overridden by passing `right`\n * to the `side` property:\n *\n * ```html\n * <ion-menu side=\"right\" [content]=\"mycontent\">...</ion-menu>\n * ```\n *\n *\n * ### Menu Type\n *\n * The menu type can be changed by passing the value to `type` on the `<ion-menu>`:\n *\n * ```html\n * <ion-menu type=\"overlay\" [content]=\"mycontent\">...</ion-menu>\n * ```\n *\n * It can also be set in the app's config. The below will set the menu type to\n * `push` for all modes, and then set the type to `overlay` for the `ios` mode.\n *\n * ```ts\n * // in NgModules\n *\n * imports: [\n *   IonicModule.forRoot(MyApp,{\n *     menuType: 'push',\n *     platforms: {\n *       ios: {\n *         menuType: 'overlay',\n *       }\n *     }\n *   })\n * ],\n * ```\n *\n *\n * ### Displaying the Menu\n *\n * To toggle a menu from the template, add a button with the `menuToggle`\n * directive anywhere in the page's template:\n *\n * ```html\n * <button ion-button menuToggle>Toggle Menu</button>\n * ```\n *\n * To close a menu, add the `menuClose` button. It can be added anywhere\n * in the content, or even the menu itself. Below it is added to the menu's\n * content:\n *\n * ```html\n * <ion-menu [content]=\"mycontent\">\n *   <ion-content>\n *     <ion-list>\n *       <ion-item menuClose detail-none>Close Menu</ion-item>\n *     </ion-list>\n *   </ion-content>\n * </ion-menu>\n * ```\n *\n * See the [MenuToggle](../MenuToggle) and [MenuClose](../MenuClose) docs\n * for more information on these directives.\n *\n * The menu can also be controlled from the Page by using the `MenuController`.\n * Inject the `MenuController` provider into the page and then call any of its\n * methods. In the below example, the `openMenu` method will open the menu\n * when it is called.\n *\n * ```ts\n * import { Component } from '@angular/core';\n * import { MenuController } from 'ionic-angular';\n *\n * @Component({...})\n * export class MyPage {\n *  constructor(public menuCtrl: MenuController) {}\n *\n *  openMenu() {\n *    this.menuCtrl.open();\n *  }\n * }\n * ```\n *\n * See the [MenuController](../../app/MenuController) API docs for all of the methods\n * and usage information.\n *\n *\n * @demo /docs/demos/src/menu/\n *\n * @see {@link /docs/components#menus Menu Component Docs}\n * @see {@link ../../app/MenuController MenuController API Docs}\n * @see {@link ../../nav/Nav Nav API Docs}\n * @see {@link ../../nav/NavController NavController API Docs}\n */\nexport class Menu {\n    constructor(_menuCtrl, _elementRef, _config, _plt, _renderer, _keyboard, _gestureCtrl, _domCtrl, _app) {\n        this._menuCtrl = _menuCtrl;\n        this._elementRef = _elementRef;\n        this._config = _config;\n        this._plt = _plt;\n        this._renderer = _renderer;\n        this._keyboard = _keyboard;\n        this._gestureCtrl = _gestureCtrl;\n        this._domCtrl = _domCtrl;\n        this._app = _app;\n        this._isSwipeEnabled = true;\n        this._isAnimating = false;\n        this._isPersistent = false;\n        this._init = false;\n        this._isPane = false;\n        /**\n         * @hidden\n         */\n        this.isOpen = false;\n        /**\n         * @hidden\n         */\n        this.isRightSide = false;\n        /**\n         * @output {event} Emitted when the menu is being dragged open.\n         */\n        this.ionDrag = new EventEmitter();\n        /**\n         * @output {event} Emitted when the menu has been opened.\n         */\n        this.ionOpen = new EventEmitter();\n        /**\n         * @output {event} Emitted when the menu has been closed.\n         */\n        this.ionClose = new EventEmitter();\n        this._events = new UIEventManager(_plt);\n        this._gestureBlocker = _gestureCtrl.createBlocker({\n            disable: [GESTURE_GO_BACK_SWIPE]\n        });\n        this.side = 'start';\n    }\n    /**\n     * @input {boolean} If true, the menu is enabled. Default `true`.\n     */\n    get enabled() {\n        return this._isEnabled;\n    }\n    set enabled(val) {\n        const isEnabled = isTrueProperty(val);\n        this.enable(isEnabled);\n    }\n    /**\n     * @input {string} Which side of the view the menu should be placed. Default `\"left\"`.\n     */\n    get side() {\n        return this._side;\n    }\n    set side(val) {\n        this.isRightSide = isRightSide(val, this._plt.isRTL);\n        if (this.isRightSide) {\n            this._side = 'right';\n        }\n        else {\n            this._side = 'left';\n        }\n    }\n    /**\n     * @input {boolean} If true, swiping the menu is enabled. Default `true`.\n     */\n    get swipeEnabled() {\n        return this._isSwipeEnabled;\n    }\n    set swipeEnabled(val) {\n        const isEnabled = isTrueProperty(val);\n        this.swipeEnable(isEnabled);\n    }\n    /**\n     * @input {boolean} If true, the menu will persist on child pages.\n     */\n    get persistent() {\n        return this._isPersistent;\n    }\n    set persistent(val) {\n        this._isPersistent = isTrueProperty(val);\n    }\n    /**\n     * @hidden\n     */\n    ngOnInit() {\n        this._init = true;\n        let content = this.content;\n        this._cntEle = (content instanceof Node) ? content : content && content.getNativeElement && content.getNativeElement();\n        // requires content element\n        if (!this._cntEle) {\n            return console.error('Menu: must have a [content] element to listen for drag events on. Example:\\n\\n<ion-menu [content]=\"content\"></ion-menu>\\n\\n<ion-nav #content></ion-nav>');\n        }\n        this.setElementAttribute('side', this._side);\n        // normalize the \"type\"\n        if (!this.type) {\n            this.type = this._config.get('menuType');\n        }\n        this.setElementAttribute('type', this.type);\n        // add the gestures\n        this._gesture = new MenuContentGesture(this._plt, this, this._gestureCtrl, this._domCtrl);\n        // add menu's content classes\n        this._cntEle.classList.add('menu-content');\n        this._cntEle.classList.add('menu-content-' + this.type);\n        let isEnabled = this._isEnabled;\n        if (isEnabled === true || typeof isEnabled === 'undefined') {\n            // check if more than one menu is on the same side\n            isEnabled = !this._menuCtrl.getMenus().some(m => {\n                return m.side === this.side && m.enabled;\n            });\n        }\n        // register this menu with the app's menu controller\n        this._menuCtrl._register(this);\n        // mask it as enabled / disabled\n        this.enable(isEnabled);\n    }\n    /**\n     * @hidden\n     */\n    onBackdropClick(ev) {\n        ev.preventDefault();\n        ev.stopPropagation();\n        this._menuCtrl.close();\n    }\n    /**\n     * @hidden\n     */\n    _getType() {\n        if (!this._type) {\n            this._type = MenuController.create(this.type, this, this._plt);\n            if (this._config.get('animate') === false) {\n                this._type.ani.duration(0);\n            }\n        }\n        return this._type;\n    }\n    /**\n     * @hidden\n     */\n    setOpen(shouldOpen, animated = true) {\n        // If the menu is disabled or it is currenly being animated, let's do nothing\n        if ((shouldOpen === this.isOpen) || !this._canOpen() || this._isAnimating) {\n            return Promise.resolve(this.isOpen);\n        }\n        return new Promise(resolve => {\n            this._before();\n            this._getType().setOpen(shouldOpen, animated, () => {\n                this._after(shouldOpen);\n                resolve(this.isOpen);\n            });\n        });\n    }\n    _forceClosing() {\n        (void 0) /* assert */;\n        this._isAnimating = true;\n        this._getType().setOpen(false, false, () => {\n            this._after(false);\n        });\n    }\n    /**\n     * @hidden\n     */\n    canSwipe() {\n        return this._isSwipeEnabled &&\n            !this._isAnimating &&\n            this._canOpen() &&\n            this._app.isEnabled();\n    }\n    /**\n     * @hidden\n     */\n    isAnimating() {\n        return this._isAnimating;\n    }\n    _swipeBeforeStart() {\n        if (!this.canSwipe()) {\n            (void 0) /* assert */;\n            return;\n        }\n        this._before();\n    }\n    _swipeStart() {\n        if (!this._isAnimating) {\n            (void 0) /* assert */;\n            return;\n        }\n        this._getType().setProgressStart(this.isOpen);\n    }\n    _swipeProgress(stepValue) {\n        if (!this._isAnimating) {\n            (void 0) /* assert */;\n            return;\n        }\n        this._getType().setProgessStep(stepValue);\n        const ionDrag = this.ionDrag;\n        if (ionDrag.observers.length > 0) {\n            ionDrag.emit(stepValue);\n        }\n    }\n    _swipeEnd(shouldCompleteLeft, shouldCompleteRight, stepValue, velocity) {\n        if (!this._isAnimating) {\n            (void 0) /* assert */;\n            return;\n        }\n        // user has finished dragging the menu\n        const isRightSide = this.isRightSide;\n        const isRTL = this._plt.isRTL;\n        const opening = !this.isOpen;\n        const shouldComplete = (opening)\n            ? (isRightSide !== isRTL) ? shouldCompleteLeft : shouldCompleteRight\n            : (isRightSide !== isRTL) ? shouldCompleteRight : shouldCompleteLeft;\n        this._getType().setProgressEnd(shouldComplete, stepValue, velocity, (isOpen) => {\n            (void 0) /* console.debug */;\n            this._after(isOpen);\n        });\n    }\n    _before() {\n        (void 0) /* assert */;\n        // this places the menu into the correct location before it animates in\n        // this css class doesn't actually kick off any animations\n        this.setElementClass('show-menu', true);\n        this.backdrop.setElementClass('show-backdrop', true);\n        this.resize();\n        this._keyboard.close();\n        this._isAnimating = true;\n    }\n    _after(isOpen) {\n        (void 0) /* assert */;\n        this._app.setEnabled(false, 100);\n        // keep opening/closing the menu disabled for a touch more yet\n        // only add listeners/css if it's enabled and isOpen\n        // and only remove listeners/css if it's not open\n        // emit opened/closed events\n        this.isOpen = isOpen;\n        this._isAnimating = false;\n        this._events.unlistenAll();\n        if (isOpen) {\n            // Disable swipe to go back gesture\n            this._gestureBlocker.block();\n            this._cntEle.classList.add('menu-content-open');\n            let callback = this.onBackdropClick.bind(this);\n            this._events.listen(this._cntEle, 'click', callback, { capture: true });\n            this._events.listen(this.backdrop.getNativeElement(), 'click', callback, { capture: true });\n            this.ionOpen.emit(true);\n        }\n        else {\n            // Enable swipe to go back gesture\n            this._gestureBlocker.unblock();\n            this._cntEle.classList.remove('menu-content-open');\n            this.setElementClass('show-menu', false);\n            this.backdrop.setElementClass('show-menu', false);\n            this.ionClose.emit(true);\n        }\n    }\n    /**\n     * @hidden\n     */\n    open() {\n        return this.setOpen(true);\n    }\n    /**\n     * @hidden\n     */\n    close() {\n        return this.setOpen(false);\n    }\n    /**\n     * @hidden\n     */\n    resize() {\n        const content = this.menuContent\n            ? this.menuContent\n            : this.menuNav;\n        content && content.resize();\n    }\n    /**\n     * @hidden\n     */\n    toggle() {\n        return this.setOpen(!this.isOpen);\n    }\n    _canOpen() {\n        return this._isEnabled && !this._isPane;\n    }\n    /**\n     * @hidden\n     */\n    _updateState() {\n        const canOpen = this._canOpen();\n        // Close menu inmediately\n        if (!canOpen && this.isOpen) {\n            (void 0) /* assert */;\n            // close if this menu is open, and should not be enabled\n            this._forceClosing();\n        }\n        if (this._isEnabled && this._menuCtrl) {\n            this._menuCtrl._setActiveMenu(this);\n        }\n        if (!this._init) {\n            return;\n        }\n        const gesture = this._gesture;\n        // only listen/unlisten if the menu has initialized\n        if (canOpen && this._isSwipeEnabled && !gesture.isListening) {\n            // should listen, but is not currently listening\n            (void 0) /* console.debug */;\n            gesture.listen();\n        }\n        else if (gesture.isListening && (!canOpen || !this._isSwipeEnabled)) {\n            // should not listen, but is currently listening\n            (void 0) /* console.debug */;\n            gesture.unlisten();\n        }\n        if (this.isOpen || (this._isPane && this._isEnabled)) {\n            this.resize();\n        }\n        (void 0) /* assert */;\n    }\n    /**\n     * @hidden\n     */\n    enable(shouldEnable) {\n        this._isEnabled = shouldEnable;\n        this.setElementClass('menu-enabled', shouldEnable);\n        this._updateState();\n        return this;\n    }\n    /**\n     * @internal\n     */\n    initPane() {\n        return false;\n    }\n    /**\n     * @internal\n     */\n    paneChanged(isPane) {\n        this._isPane = isPane;\n        this._updateState();\n    }\n    /**\n     * @hidden\n     */\n    swipeEnable(shouldEnable) {\n        this._isSwipeEnabled = shouldEnable;\n        this._updateState();\n        return this;\n    }\n    /**\n     * @hidden\n     */\n    getNativeElement() {\n        return this._elementRef.nativeElement;\n    }\n    /**\n     * @hidden\n     */\n    getMenuElement() {\n        return this.getNativeElement().querySelector('.menu-inner');\n    }\n    /**\n     * @hidden\n     */\n    getContentElement() {\n        return this._cntEle;\n    }\n    /**\n     * @hidden\n     */\n    getBackdropElement() {\n        return this.backdrop.getNativeElement();\n    }\n    /**\n     * @hidden\n     */\n    width() {\n        return this.getMenuElement().offsetWidth;\n    }\n    /**\n     * @hidden\n     */\n    getMenuController() {\n        return this._menuCtrl;\n    }\n    /**\n     * @hidden\n     */\n    setElementClass(className, add) {\n        this._renderer.setElementClass(this._elementRef.nativeElement, className, add);\n    }\n    /**\n     * @hidden\n     */\n    setElementAttribute(attributeName, value) {\n        this._renderer.setElementAttribute(this._elementRef.nativeElement, attributeName, value);\n    }\n    /**\n     * @hidden\n     */\n    getElementRef() {\n        return this._elementRef;\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this._menuCtrl._unregister(this);\n        this._events.destroy();\n        this._gesture && this._gesture.destroy();\n        this._type && this._type.destroy();\n        this._gesture = null;\n        this._type = null;\n        this._cntEle = null;\n    }\n}\nMenu.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-menu',\n                template: '<div class=\"menu-inner\"><ng-content></ng-content></div>' +\n                    '<ion-backdrop></ion-backdrop>',\n                host: {\n                    'role': 'navigation'\n                },\n                changeDetection: ChangeDetectionStrategy.OnPush,\n                encapsulation: ViewEncapsulation.None,\n                providers: [{ provide: RootNode, useExisting: forwardRef(() => Menu) }]\n            },] },\n];\n/** @nocollapse */\nMenu.ctorParameters = () => [\n    { type: MenuController, },\n    { type: ElementRef, },\n    { type: Config, },\n    { type: Platform, },\n    { type: Renderer, },\n    { type: Keyboard, },\n    { type: GestureController, },\n    { type: DomController, },\n    { type: App, },\n];\nMenu.propDecorators = {\n    'backdrop': [{ type: ViewChild, args: [Backdrop,] },],\n    'menuContent': [{ type: ContentChild, args: [Content,] },],\n    'menuNav': [{ type: ContentChild, args: [Nav,] },],\n    'content': [{ type: Input },],\n    'id': [{ type: Input },],\n    'type': [{ type: Input },],\n    'enabled': [{ type: Input },],\n    'side': [{ type: Input },],\n    'swipeEnabled': [{ type: Input },],\n    'persistent': [{ type: Input },],\n    'maxEdgeStart': [{ type: Input },],\n    'ionDrag': [{ type: Output },],\n    'ionOpen': [{ type: Output },],\n    'ionClose': [{ type: Output },],\n};\n"]}