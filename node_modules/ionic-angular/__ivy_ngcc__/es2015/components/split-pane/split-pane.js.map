{"version":3,"file":"split-pane.js","sources":["split-pane.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;2OAME;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;oBAAE;AACF","sourcesContent":["import { ContentChildren, Directive, ElementRef, EventEmitter, Input, NgZone, Output, Renderer, forwardRef } from '@angular/core';\nimport { Ion } from '../ion';\nimport { isTrueProperty } from '../../util/util';\nimport { Config } from '../../config/config';\nimport { Platform } from '../../platform/platform';\nconst QUERY = {\n    xs: '(min-width: 0px)',\n    sm: '(min-width: 576px)',\n    md: '(min-width: 768px)',\n    lg: '(min-width: 992px)',\n    xl: '(min-width: 1200px)',\n    never: ''\n};\n/**\n * @hidden\n */\nexport class RootNode {\n}\n/**\n * @name SplitPane\n *\n * @description\n * SplitPane is a component that makes it possible to create multi-view layout.\n * Similar to iPad apps, SplitPane allows UI elements, like Menus, to be\n * displayed as the viewport increases.\n *\n * If the devices screen size is below a certain size, the SplitPane will\n * collapse and the menu will become hidden again. This is especially useful when\n * creating an app that will be served over a browser or deployed through the app\n * store to phones and tablets.\n *\n * @usage\n * To use SplitPane, simply add the component around your root component.\n * In this example, we'll be using a sidemenu layout, similar to what is\n * provided from the sidemenu starter template.\n *\n *  ```html\n *  <ion-split-pane>\n *    <!--  our side menu  -->\n *    <ion-menu [content]=\"content\">\n *      <ion-header>\n *        <ion-toolbar>\n *          <ion-title>Menu</ion-title>\n *        </ion-toolbar>\n *      </ion-header>\n *    </ion-menu>\n *\n *    <!-- the main content -->\n *    <ion-nav [root]=\"root\" main #content></ion-nav>\n *  </ion-split-pane>\n *  ```\n *\n *  Here, SplitPane will look for the element with the `main` attribute and make\n *  that the central component on larger screens. The `main` component can be any\n *  Ionic component (`ion-nav` or `ion-tabs`) except `ion-menu`.\n *\n *  ### Setting breakpoints\n *\n *  By default, SplitPane will expand when the screen is larger than 768px.\n *  If you want to customize this, use the `when` input. The `when` input can\n *  accept any valid media query, as it uses `matchMedia()` underneath.\n *\n *  ```\n *  <ion-split-pane when=\"(min-width: 475px)\">\n *\n *    <!--  our side menu  -->\n *    <ion-menu [content]=\"content\">\n *    ....\n *    </ion-menu>\n *\n *    <!-- the main content -->\n *    <ion-nav [root]=\"root\" main #content></ion-nav>\n *  </ion-split-pane>\n *  ```\n *\n *  SplitPane also provides some predefined media queries that can be used.\n *\n *  ```html\n *  <!-- could be \"xs\", \"sm\", \"md\", \"lg\", or \"xl\" -->\n *  <ion-split-pane when=\"lg\">\n *  ...\n *  </ion-split-pane>\n *  ```\n *\n *\n *  | Size | Value                 | Description                                                           |\n *  |------|-----------------------|-----------------------------------------------------------------------|\n *  | `xs` | `(min-width: 0px)`    | Show the split-pane when the min-width is 0px (meaning, always)       |\n *  | `sm` | `(min-width: 576px)`  | Show the split-pane when the min-width is 576px                       |\n *  | `md` | `(min-width: 768px)`  | Show the split-pane when the min-width is 768px (default break point) |\n *  | `lg` | `(min-width: 992px)`  | Show the split-pane when the min-width is 992px                       |\n *  | `xl` | `(min-width: 1200px)` | Show the split-pane when the min-width is 1200px                      |\n *\n *  You can also pass in boolean values that will trigger SplitPane when the value\n *  or expression evaluates to true.\n *\n *\n *  ```html\n *  <ion-split-pane [when]=\"isLarge\">\n *  ...\n *  </ion-split-pane>\n *  ```\n *\n *  ```ts\n *  class MyClass {\n *    public isLarge = false;\n *    constructor(){}\n *  }\n *  ```\n *\n *  Or\n *\n *  ```html\n *  <ion-split-pane [when]=\"shouldShow()\">\n *  ...\n *  </ion-split-pane>\n *  ```\n *\n *  ```ts\n *  class MyClass {\n *    constructor(){}\n *    shouldShow(){\n *      if(conditionA){\n *        return true\n *      } else {\n *        return false\n *      }\n *    }\n *  }\n *  ```\n *\n */\nexport class SplitPane extends Ion {\n    constructor(_zone, _plt, config, elementRef, renderer) {\n        super(config, elementRef, renderer, 'split-pane');\n        this._zone = _zone;\n        this._plt = _plt;\n        this._init = false;\n        this._visible = false;\n        this._isEnabled = true;\n        this._mediaQuery = QUERY['md'];\n        /**\n         * @hidden\n         */\n        this.sideContent = null;\n        /**\n         * @hidden\n         */\n        this.mainContent = null;\n        /**\n         * @output {any} Expression to be called when the split-pane visibility has changed\n         */\n        this.ionChange = new EventEmitter();\n    }\n    /**\n     * @hidden\n     */\n    set _setchildren(query) {\n        const children = this._children = query.filter((child => child !== this));\n        children.forEach(child => {\n            var isMain = child.initPane();\n            this._setPaneCSSClass(child.getElementRef(), isMain);\n        });\n    }\n    /**\n     * @input {string | boolean} When the split-pane should be shown.\n     * Can be a CSS media query expression, or a shortcut expression.\n     * Can also be a boolean expression.\n     */\n    set when(query) {\n        if (typeof query === 'boolean') {\n            this._mediaQuery = query;\n        }\n        else {\n            const defaultQuery = QUERY[query];\n            this._mediaQuery = (defaultQuery)\n                ? defaultQuery\n                : query;\n        }\n        this._update();\n    }\n    get when() {\n        return this._mediaQuery;\n    }\n    /**\n     * @input {boolean} If `false`, the split-pane is disabled, ie. the side pane will\n     * never be displayed. Default `true`.\n     */\n    set enabled(val) {\n        this._isEnabled = isTrueProperty(val);\n        this._update();\n    }\n    get enabled() {\n        return this._isEnabled;\n    }\n    /**\n     * @hidden\n     */\n    _register(node, isMain, callback) {\n        if (this.getElementRef().nativeElement !== node.getElementRef().nativeElement.parentNode) {\n            return false;\n        }\n        this._setPaneCSSClass(node.getElementRef(), isMain);\n        if (callback) {\n            this.ionChange.subscribe(callback);\n        }\n        if (isMain) {\n            if (this.mainContent) {\n                console.error('split pane: main content was already set');\n            }\n            this.mainContent = node;\n        }\n        return true;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterViewInit() {\n        this._init = true;\n        this._update();\n    }\n    /**\n     * @hidden\n     */\n    _update() {\n        if (!this._init) {\n            return;\n        }\n        // Unlisten\n        this._rmListener && this._rmListener();\n        this._rmListener = null;\n        // Check if the split-pane is disabled\n        if (!this._isEnabled) {\n            this._setVisible(false);\n            return;\n        }\n        const query = this._mediaQuery;\n        if (typeof query === 'boolean') {\n            this._setVisible(query);\n            return;\n        }\n        if (query && query.length > 0) {\n            // Listen\n            const callback = (query) => this._setVisible(query.matches);\n            const mediaList = this._plt.win().matchMedia(query);\n            mediaList.addListener(callback);\n            this._setVisible(mediaList.matches);\n            this._rmListener = function () {\n                mediaList.removeListener(callback);\n            };\n        }\n        else {\n            this._setVisible(false);\n        }\n    }\n    /**\n     * @hidden\n     */\n    _updateChildren() {\n        this.mainContent = null;\n        this.sideContent = null;\n        const visible = this._visible;\n        this._children.forEach(child => child.paneChanged && child.paneChanged(visible));\n    }\n    /**\n     * @hidden\n     */\n    _setVisible(visible) {\n        if (this._visible === visible) {\n            return;\n        }\n        this._visible = visible;\n        this.setElementClass('split-pane-visible', visible);\n        this._updateChildren();\n        this._zone.run(() => {\n            this.ionChange.emit(this);\n        });\n    }\n    /**\n     * @hidden\n     */\n    isVisible() {\n        return this._visible;\n    }\n    /**\n     * @hidden\n     */\n    setElementClass(className, add) {\n        this._renderer.setElementClass(this._elementRef.nativeElement, className, add);\n    }\n    /**\n     * @hidden\n     */\n    _setPaneCSSClass(elementRef, isMain) {\n        const ele = elementRef.nativeElement;\n        this._renderer.setElementClass(ele, 'split-pane-main', isMain);\n        this._renderer.setElementClass(ele, 'split-pane-side', !isMain);\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        (void 0) /* assert */;\n        this._rmListener && this._rmListener();\n        this._rmListener = null;\n    }\n    /**\n     * @hidden\n     */\n    initPane() {\n        return true;\n    }\n}\nSplitPane.decorators = [\n    { type: Directive, args: [{\n                selector: 'ion-split-pane',\n                providers: [{ provide: RootNode, useExisting: forwardRef(() => SplitPane) }]\n            },] },\n];\n/** @nocollapse */\nSplitPane.ctorParameters = () => [\n    { type: NgZone, },\n    { type: Platform, },\n    { type: Config, },\n    { type: ElementRef, },\n    { type: Renderer, },\n];\nSplitPane.propDecorators = {\n    '_setchildren': [{ type: ContentChildren, args: [RootNode, { descendants: false },] },],\n    'when': [{ type: Input },],\n    'enabled': [{ type: Input },],\n    'ionChange': [{ type: Output },],\n};\n"]}