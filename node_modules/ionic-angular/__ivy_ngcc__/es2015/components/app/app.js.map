{"version":3,"file":"app.js","sources":["app.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;uFAGE;AACF;AACA;AACA;AACA;AACA;AACA;;;;;kCAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { EventEmitter, Injectable, Optional } from '@angular/core';\nimport { DOCUMENT, Title } from '@angular/platform-browser';\nimport * as Constants from './app-constants';\nimport { Config } from '../../config/config';\nimport { DIRECTION_BACK, DIRECTION_FORWARD, isTabs } from '../../navigation/nav-util';\nimport { MenuController } from './menu-controller';\nimport { Platform } from '../../platform/platform';\nimport { IOSTransition } from '../../transitions/transition-ios';\nimport { MDTransition } from '../../transitions/transition-md';\nimport { WPTransition } from '../../transitions/transition-wp';\n/**\n * @name App\n * @description\n * App is a utility class used in Ionic to get information about various aspects of an app\n */\nexport class App {\n    constructor(_config, _plt, _menuCtrl) {\n        this._config = _config;\n        this._plt = _plt;\n        this._menuCtrl = _menuCtrl;\n        this._disTime = 0;\n        this._scrollTime = 0;\n        this._title = '';\n        this._titleSrv = new Title(DOCUMENT);\n        this._rootNavs = new Map();\n        this._didScroll = false;\n        /**\n         * Observable that emits whenever a view loads in the app.\n         * @returns {Observable} Returns an observable\n         */\n        this.viewDidLoad = new EventEmitter();\n        /**\n         * Observable that emits before any view is entered in the app.\n         * @returns {Observable} Returns an observable\n         */\n        this.viewWillEnter = new EventEmitter();\n        /**\n         * Observable that emits after any view is entered in the app.\n         * @returns {Observable} Returns an observable\n         */\n        this.viewDidEnter = new EventEmitter();\n        /**\n         * Observable that emits before any view is exited in the app.\n         * @returns {Observable} Returns an observable\n         */\n        this.viewWillLeave = new EventEmitter();\n        /**\n         * Observable that emits after any view is exited in the app.\n         * @returns {Observable} Returns an observable\n         */\n        this.viewDidLeave = new EventEmitter();\n        /**\n         * Observable that emits before any view unloads in the app.\n         * @returns {Observable} Returns an observable\n         */\n        this.viewWillUnload = new EventEmitter();\n        // listen for hardware back button events\n        // register this back button action with a default priority\n        _plt.registerBackButtonAction(this.goBack.bind(this));\n        this._disableScrollAssist = _config.getBoolean('disableScrollAssist', false);\n        const blurring = _config.getBoolean('inputBlurring', false);\n        if (blurring) {\n            this._enableInputBlurring();\n        }\n        (void 0) /* runInDev */;\n        _config.setTransition('ios-transition', IOSTransition);\n        _config.setTransition('md-transition', MDTransition);\n        _config.setTransition('wp-transition', WPTransition);\n    }\n    /**\n     * Sets the document title.\n     * @param {string} val  Value to set the document title to.\n     */\n    setTitle(val) {\n        if (val !== this._title) {\n            this._title = val;\n            this._titleSrv.setTitle(val);\n        }\n    }\n    /**\n     * @hidden\n     */\n    setElementClass(className, isAdd) {\n        this._appRoot.setElementClass(className, isAdd);\n    }\n    /**\n     * @hidden\n     * Sets if the app is currently enabled or not, meaning if it's\n     * available to accept new user commands. For example, this is set to `false`\n     * while views transition, a modal slides up, an action-sheet\n     * slides up, etc. After the transition completes it is set back to `true`.\n     * @param {boolean} isEnabled `true` for enabled, `false` for disabled\n     * @param {number} duration  When `isEnabled` is set to `false`, this argument\n     * is used to set the maximum number of milliseconds that app will wait until\n     * it will automatically enable the app again. It's basically a fallback incase\n     * something goes wrong during a transition and the app wasn't re-enabled correctly.\n     */\n    setEnabled(isEnabled, duration = 700, minDuration = 0) {\n        this._disTime = (isEnabled ? 0 : Date.now() + duration);\n        if (this._clickBlock) {\n            if (isEnabled) {\n                // disable the click block if it's enabled, or the duration is tiny\n                this._clickBlock.activate(false, CLICK_BLOCK_BUFFER_IN_MILLIS, minDuration);\n            }\n            else {\n                // show the click block for duration + some number\n                this._clickBlock.activate(true, duration + CLICK_BLOCK_BUFFER_IN_MILLIS, minDuration);\n            }\n        }\n    }\n    /**\n     * @hidden\n     * Toggles whether an application can be scrolled\n     * @param {boolean} disableScroll when set to `false`, the application's\n     * scrolling is enabled. When set to `true`, scrolling is disabled.\n     */\n    _setDisableScroll(disableScroll) {\n        if (this._disableScrollAssist) {\n            this._appRoot._disableScroll(disableScroll);\n        }\n    }\n    /**\n     * @hidden\n     * Boolean if the app is actively enabled or not.\n     * @return {boolean}\n     */\n    isEnabled() {\n        const disTime = this._disTime;\n        if (disTime === 0) {\n            return true;\n        }\n        return (disTime < Date.now());\n    }\n    /**\n     * @hidden\n     */\n    setScrolling() {\n        this._scrollTime = Date.now() + ACTIVE_SCROLLING_TIME;\n        this._didScroll = true;\n    }\n    /**\n     * Boolean if the app is actively scrolling or not.\n     * @return {boolean} returns true or false\n     */\n    isScrolling() {\n        const scrollTime = this._scrollTime;\n        if (scrollTime === 0) {\n            return false;\n        }\n        if (scrollTime < Date.now()) {\n            this._scrollTime = 0;\n            return false;\n        }\n        return true;\n    }\n    /**\n     * @return {NavController} Returns the first Active Nav Controller from the list. This method is deprecated\n     */\n    getActiveNav() {\n        console.warn('(getActiveNav) is deprecated and will be removed in the next major release. Use getActiveNavs instead.');\n        const navs = this.getActiveNavs();\n        if (navs && navs.length) {\n            return navs[0];\n        }\n        return null;\n    }\n    /**\n     * @return {NavController[]} Returns the active NavControllers. Using this method is preferred when we need access to the top-level navigation controller while on the outside views and handlers like `registerBackButtonAction()`\n     */\n    getActiveNavs(rootNavId) {\n        const portal = this._appRoot._getPortal(Constants.PORTAL_MODAL);\n        if (portal.length() > 0) {\n            return findTopNavs(portal);\n        }\n        if (!this._rootNavs || !this._rootNavs.size) {\n            return [];\n        }\n        if (this._rootNavs.size === 1) {\n            return findTopNavs(this._rootNavs.values().next().value);\n        }\n        if (rootNavId) {\n            return findTopNavs(this._rootNavs.get(rootNavId));\n        }\n        // fallback to just using all root names\n        let activeNavs = [];\n        this._rootNavs.forEach(nav => {\n            const topNavs = findTopNavs(nav);\n            activeNavs = activeNavs.concat(topNavs);\n        });\n        return activeNavs;\n    }\n    getRootNav() {\n        console.warn('(getRootNav) is deprecated and will be removed in the next major release. Use getRootNavById instead.');\n        const rootNavs = this.getRootNavs();\n        if (rootNavs.length === 0) {\n            return null;\n        }\n        else if (rootNavs.length > 1) {\n            console.warn('(getRootNav) there are multiple root navs, use getRootNavs instead');\n        }\n        return rootNavs[0];\n    }\n    getRootNavs() {\n        const navs = [];\n        this._rootNavs.forEach(nav => navs.push(nav));\n        return navs;\n    }\n    /**\n     * @return {NavController} Returns the root NavController\n     */\n    getRootNavById(navId) {\n        return this._rootNavs.get(navId);\n    }\n    /**\n     * @hidden\n     */\n    registerRootNav(nav) {\n        this._rootNavs.set(nav.id, nav);\n    }\n    /**\n     * @hidden\n     */\n    unregisterRootNav(nav) {\n        this._rootNavs.delete(nav.id);\n    }\n    getActiveNavContainers() {\n        // for each root nav container, get it's active nav\n        let list = [];\n        this._rootNavs.forEach((container) => {\n            list = list.concat(findTopNavs(container));\n        });\n        return list;\n    }\n    /**\n     * @hidden\n     */\n    present(enteringView, opts, appPortal) {\n        (void 0) /* assert */;\n        const portal = this._appRoot._getPortal(appPortal);\n        // Set Nav must be set here in order to dimiss() work synchnously.\n        // TODO: move _setNav() to the earlier stages of NavController. _queueTrns()\n        enteringView._setNav(portal);\n        opts.direction = DIRECTION_FORWARD;\n        if (!opts.animation) {\n            opts.animation = enteringView.getTransitionName(DIRECTION_FORWARD);\n        }\n        enteringView.setLeavingOpts({\n            keyboardClose: opts.keyboardClose,\n            direction: DIRECTION_BACK,\n            animation: enteringView.getTransitionName(DIRECTION_BACK),\n            ev: opts.ev\n        });\n        return portal.insertPages(-1, [enteringView], opts);\n    }\n    /**\n     * @hidden\n     */\n    goBack() {\n        if (this._menuCtrl && this._menuCtrl.isOpen()) {\n            return this._menuCtrl.close();\n        }\n        const navPromise = this.navPop();\n        if (!navPromise) {\n            // no views to go back to\n            // let's exit the app\n            if (this._config.getBoolean('navExitApp', true)) {\n                (void 0) /* console.debug */;\n                this._plt.exitApp();\n            }\n        }\n        return navPromise;\n    }\n    /**\n     * @hidden\n     */\n    navPop() {\n        if (!this._rootNavs || this._rootNavs.size === 0 || !this.isEnabled()) {\n            return Promise.resolve();\n        }\n        // If there are any alert/actionsheet open, let's do nothing\n        const portal = this._appRoot._getPortal(Constants.PORTAL_DEFAULT);\n        if (portal.length() > 0) {\n            return Promise.resolve();\n        }\n        let navToPop = null;\n        let mostRecentVC = null;\n        this._rootNavs.forEach((navContainer) => {\n            const activeNavs = this.getActiveNavs(navContainer.id);\n            const poppableNavs = activeNavs.map(activeNav => getPoppableNav(activeNav)).filter(nav => !!nav);\n            poppableNavs.forEach(poppable => {\n                const topViewController = poppable.last();\n                if (poppable._isPortal || (topViewController && poppable.length() > 1 && (!mostRecentVC || topViewController._ts >= mostRecentVC._ts))) {\n                    mostRecentVC = topViewController;\n                    navToPop = poppable;\n                }\n            });\n        });\n        if (navToPop) {\n            return navToPop.pop();\n        }\n    }\n    /**\n     * @hidden\n     */\n    _enableInputBlurring() {\n        (void 0) /* console.debug */;\n        let focused = true;\n        const self = this;\n        const platform = this._plt;\n        platform.registerListener(platform.doc(), 'focusin', onFocusin, { capture: true, zone: false, passive: true });\n        platform.registerListener(platform.doc(), 'touchend', onTouchend, { capture: false, zone: false, passive: true });\n        function onFocusin() {\n            focused = true;\n        }\n        function onTouchend(ev) {\n            // if app did scroll return early\n            if (self._didScroll) {\n                self._didScroll = false;\n                return;\n            }\n            const active = self._plt.getActiveElement();\n            if (!active) {\n                return;\n            }\n            // only blur if the active element is a text-input or a textarea\n            if (SKIP_BLURRING.indexOf(active.tagName) === -1) {\n                return;\n            }\n            // if the selected target is the active element, do not blur\n            const tapped = ev.target;\n            if (tapped === active) {\n                return;\n            }\n            if (SKIP_BLURRING.indexOf(tapped.tagName) >= 0) {\n                return;\n            }\n            // skip if div is a cover\n            if (tapped.classList.contains('input-cover')) {\n                return;\n            }\n            focused = false;\n            // TODO: find a better way, why 50ms?\n            platform.timeout(() => {\n                if (!focused) {\n                    active.blur();\n                }\n            }, 50);\n        }\n    }\n    getNavByIdOrName(id) {\n        const navs = Array.from(this._rootNavs.values());\n        for (const navContainer of navs) {\n            const match = getNavByIdOrName(navContainer, id);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    }\n}\nApp.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nApp.ctorParameters = () => [\n    { type: Config, },\n    { type: Platform, },\n    { type: MenuController, decorators: [{ type: Optional },] },\n];\nexport function getNavByIdOrName(nav, id) {\n    if (nav.id === id || nav.name === id) {\n        return nav;\n    }\n    for (const child of nav.getAllChildNavs()) {\n        const tmp = getNavByIdOrName(child, id);\n        if (tmp) {\n            return tmp;\n        }\n    }\n    return null;\n}\nfunction getPoppableNav(nav) {\n    if (!nav) {\n        return null;\n    }\n    if (isTabs(nav)) {\n        // tabs aren't a nav, so just call this function again immediately on the parent on tabs\n        return getPoppableNav(nav.parent);\n    }\n    const len = nav.length();\n    if (len > 1 || (nav._isPortal && len > 0)) {\n        // this nav controller has more than one view\n        // use this nav!\n        return nav;\n    }\n    // try again using the parent nav (if there is one)\n    return getPoppableNav(nav.parent);\n}\nexport function findTopNavs(nav) {\n    let containers = [];\n    const childNavs = nav.getActiveChildNavs();\n    if (!childNavs || !childNavs.length) {\n        containers.push(nav);\n    }\n    else {\n        childNavs.forEach(childNav => {\n            const topNavs = findTopNavs(childNav);\n            containers = containers.concat(topNavs);\n        });\n    }\n    return containers;\n}\nconst SKIP_BLURRING = ['INPUT', 'TEXTAREA', 'ION-INPUT', 'ION-TEXTAREA'];\nconst ACTIVE_SCROLLING_TIME = 100;\nconst CLICK_BLOCK_BUFFER_IN_MILLIS = 64;\n"]}