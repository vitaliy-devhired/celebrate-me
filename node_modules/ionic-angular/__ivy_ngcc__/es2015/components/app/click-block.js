import { Directive, ElementRef, Inject, Renderer, forwardRef } from '@angular/core';
import { App } from '../app/app';
import { Config } from '../../config/config';
import { Platform } from '../../platform/platform';
/**
 * @hidden
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../../config/config';
import * as ɵngcc2 from '../../platform/platform';
import * as ɵngcc3 from '../app/app';
export class ClickBlock {
    constructor(app, config, plt, elementRef, renderer) {
        this.plt = plt;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this._showing = false;
        app._clickBlock = this;
        const enabled = this.isEnabled = config.getBoolean('clickBlock', true);
        if (enabled) {
            this._setElementClass('click-block-enabled', true);
        }
    }
    activate(shouldShow, expire = 100, minDuration = 0) {
        if (this.isEnabled) {
            this.plt.cancelTimeout(this._tmr);
            if (shouldShow) {
                // remember when we started the click block
                this._start = Date.now();
                // figure out the minimum time it should be showing until
                // this is useful for transitions that are less than 300ms
                this._minEnd = this._start + (minDuration || 0);
                this._activate(true);
            }
            this._tmr = this.plt.timeout(this._activate.bind(this, false), expire);
        }
    }
    /** @internal */
    _activate(shouldShow) {
        if (this._showing !== shouldShow) {
            if (!shouldShow) {
                // check if it was enabled before the minimum duration
                // this is useful for transitions that are less than 300ms
                var now = Date.now();
                if (now < this._minEnd) {
                    this._tmr = this.plt.timeout(this._activate.bind(this, false), this._minEnd - now);
                    return;
                }
            }
            this._setElementClass('click-block-active', shouldShow);
            this._showing = shouldShow;
        }
    }
    _setElementClass(className, add) {
        this.renderer.setElementClass(this.elementRef.nativeElement, className, add);
    }
}
ClickBlock.ɵfac = function ClickBlock_Factory(t) { return new (t || ClickBlock)(ɵngcc0.ɵɵdirectiveInject(forwardRef(() => App)), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Config), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(Renderer)); };
ClickBlock.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: ClickBlock, selectors: [["", 8, "click-block"]] });
/** @nocollapse */
ClickBlock.ctorParameters = () => [
    { type: App, decorators: [{ type: Inject, args: [forwardRef(() => App),] },] },
    { type: Config, },
    { type: Platform, },
    { type: ElementRef, },
    { type: Renderer, },
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClickBlock, [{
        type: Directive,
        args: [{
                selector: '.click-block'
            }]
    }], function () { return [{ type: ɵngcc3.App, decorators: [{
                type: Inject,
                args: [forwardRef(() => App)]
            }] }, { type: ɵngcc1.Config }, { type: ɵngcc2.Platform }, { type: ɵngcc0.ElementRef }, { type: Renderer }]; }, null); })();

//# sourceMappingURL=click-block.js.map