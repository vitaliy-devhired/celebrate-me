{"version":3,"file":"app-root.js","sources":["app-root.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;sFAWE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAAE;AACF","sourcesContent":["import { Component, ComponentFactoryResolver, ElementRef, Inject, InjectionToken, Renderer, ViewChild, ViewContainerRef } from '@angular/core';\nimport { App } from './app';\nimport { Config } from '../../config/config';\nimport { Ion } from '../ion';\nimport { OverlayPortal } from './overlay-portal';\nimport { Platform } from '../../platform/platform';\nimport * as Constants from './app-constants';\nexport const AppRootToken = new InjectionToken('USERROOT');\n/**\n * @hidden\n */\nexport class IonicApp extends Ion {\n    constructor(_userCmp, _cfr, elementRef, renderer, config, _plt, app) {\n        super(config, elementRef, renderer, 'app-root');\n        this._userCmp = _userCmp;\n        this._cfr = _cfr;\n        this._plt = _plt;\n        // register with App that this is Ionic's appRoot component. tada!\n        app._appRoot = this;\n        this._stopScrollPlugin = window['IonicStopScroll'];\n    }\n    ngOnInit() {\n        // load the user root component\n        // into Ionic's root component\n        const factory = this._cfr.resolveComponentFactory(this._userCmp);\n        const componentRef = this._viewport.createComponent(factory);\n        this._renderer.setElementClass(componentRef.location.nativeElement, 'app-root', true);\n        componentRef.changeDetectorRef.detectChanges();\n        // set the mode class name\n        // ios/md/wp\n        this.setElementClass(this._config.get('mode'), true);\n        const versions = this._plt.versions();\n        this._plt.platforms().forEach(platformName => {\n            // platform-ios\n            let platformClass = 'platform-' + platformName;\n            this.setElementClass(platformClass, true);\n            let platformVersion = versions[platformName];\n            if (platformVersion) {\n                // platform-ios9\n                platformClass += platformVersion.major;\n                this.setElementClass(platformClass, true);\n                // platform-ios9_3\n                this.setElementClass(platformClass + '_' + platformVersion.minor, true);\n            }\n        });\n        // touch devices should not use :hover CSS pseudo\n        // enable :hover CSS when the \"hoverCSS\" setting is not false\n        if (this._config.getBoolean('hoverCSS', true)) {\n            this.setElementClass('enable-hover', true);\n        }\n        // sweet, the app root has loaded!\n        // which means angular and ionic has fully loaded!\n        // fire off the platform prepare ready, which could\n        // have been switched out by any of the platform engines\n        this._plt.prepareReady();\n    }\n    /**\n     * @hidden\n     */\n    _getPortal(portal) {\n        if (portal === Constants.PORTAL_LOADING) {\n            return this._loadingPortal;\n        }\n        if (portal === Constants.PORTAL_TOAST) {\n            return this._toastPortal;\n        }\n        // Modals need their own overlay becuase we don't want an ActionSheet\n        // or Alert to trigger lifecycle events inside a modal\n        if (portal === Constants.PORTAL_MODAL) {\n            return this._modalPortal;\n        }\n        return this._overlayPortal;\n    }\n    _getActivePortal() {\n        const defaultPortal = this._overlayPortal;\n        const modalPortal = this._modalPortal;\n        const hasModal = modalPortal.length() > 0;\n        const hasDefault = defaultPortal.length() > 0;\n        if (!hasModal && !hasDefault) {\n            return null;\n        }\n        else if (hasModal && hasDefault) {\n            var defaultIndex = defaultPortal.getActive().getZIndex();\n            var modalIndex = modalPortal.getActive().getZIndex();\n            if (defaultIndex > modalIndex) {\n                return defaultPortal;\n            }\n            else {\n                (void 0) /* assert */;\n                return modalPortal;\n            }\n        }\n        if (hasModal) {\n            return modalPortal;\n        }\n        else if (hasDefault) {\n            return defaultPortal;\n        }\n    }\n    _disableScroll(shouldDisableScroll) {\n        if (shouldDisableScroll) {\n            this.stopScroll().then(() => {\n                this._tmr = this._plt.timeout(() => {\n                    (void 0) /* console.debug */;\n                    this.setElementClass('disable-scroll', true);\n                }, 32);\n            });\n        }\n        else {\n            let plugin = this._stopScrollPlugin;\n            if (plugin && plugin.cancel) {\n                plugin.cancel();\n            }\n            clearTimeout(this._tmr);\n            (void 0) /* console.debug */;\n            this.setElementClass('disable-scroll', false);\n            /**\n             * On iOS 12.2 there is a bug that\n             * prevents pointer-events from being\n             * re-enabled when removing the\n             * disable-scroll class.\n             */\n            const plaform = this._plt;\n            plaform.raf(() => {\n                this.setElementStyle('z-index', '1');\n                plaform.raf(() => {\n                    this.setElementStyle('z-index', null);\n                });\n            });\n        }\n    }\n    stopScroll() {\n        if (this._stopScrollPlugin) {\n            return new Promise((resolve) => {\n                this._stopScrollPlugin.stop(() => resolve(true));\n            });\n        }\n        else {\n            return Promise.resolve(false);\n        }\n    }\n}\nIonicApp.decorators = [\n    { type: Component, args: [{\n                selector: 'ion-app',\n                template: '<div #viewport app-viewport></div>' +\n                    '<div #modalPortal overlay-portal></div>' +\n                    '<div #overlayPortal overlay-portal></div>' +\n                    '<div #loadingPortal class=\"loading-portal\" overlay-portal></div>' +\n                    '<div #toastPortal class=\"toast-portal\" [overlay-portal]=\"10000\"></div>' +\n                    '<div class=\"click-block\"></div>'\n            },] },\n];\n/** @nocollapse */\nIonicApp.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [AppRootToken,] },] },\n    { type: ComponentFactoryResolver, },\n    { type: ElementRef, },\n    { type: Renderer, },\n    { type: Config, },\n    { type: Platform, },\n    { type: App, },\n];\nIonicApp.propDecorators = {\n    '_viewport': [{ type: ViewChild, args: ['viewport', { read: ViewContainerRef },] },],\n    '_modalPortal': [{ type: ViewChild, args: ['modalPortal', { read: OverlayPortal },] },],\n    '_overlayPortal': [{ type: ViewChild, args: ['overlayPortal', { read: OverlayPortal },] },],\n    '_loadingPortal': [{ type: ViewChild, args: ['loadingPortal', { read: OverlayPortal },] },],\n    '_toastPortal': [{ type: ViewChild, args: ['toastPortal', { read: OverlayPortal },] },],\n};\n"]}