{"version":3,"file":"base-input.js","sources":["base-input.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;6OAAC;AACD;AACA;AACA;AACA;AACA;AACA;AAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { EventEmitter, Input, Output } from '@angular/core';\nimport { deepCopy, isArray, isPresent, isString, isTrueProperty, isUndefined } from './util';\nimport { Ion } from '../components/ion';\nimport { TimeoutDebouncer } from './debouncer';\nexport class BaseInput extends Ion {\n    constructor(config, elementRef, renderer, name, _defaultValue, _form, _item, _ngControl) {\n        super(config, elementRef, renderer, name);\n        this._defaultValue = _defaultValue;\n        this._form = _form;\n        this._item = _item;\n        this._ngControl = _ngControl;\n        this._isFocus = false;\n        this._disabled = false;\n        this._debouncer = new TimeoutDebouncer(0);\n        this._init = false;\n        this._initModel = false;\n        /**\n         * @output {Range} Emitted when the range selector drag starts.\n         */\n        this.ionFocus = new EventEmitter();\n        /**\n         * @output {Range} Emitted when the range value changes.\n         */\n        this.ionChange = new EventEmitter();\n        /**\n         * @output {Range} Emitted when the range selector drag ends.\n         */\n        this.ionBlur = new EventEmitter();\n        _form && _form.register(this);\n        this._value = deepCopy(this._defaultValue);\n        if (_item) {\n            (void 0) /* assert */;\n            this.id = name + '-' + _item.registerInput(name);\n            this._labelId = _item.labelId;\n            this._item.setElementClass('item-' + name, true);\n        }\n        // If the user passed a ngControl we need to set the valueAccessor\n        if (_ngControl) {\n            _ngControl.valueAccessor = this;\n        }\n    }\n    /**\n     * @input {boolean} If true, the user cannot interact with this element.\n     */\n    get disabled() {\n        return this._disabled;\n    }\n    set disabled(val) {\n        this.setDisabledState(val);\n    }\n    get value() {\n        return this._value;\n    }\n    set value(val) {\n        if (this._writeValue(val)) {\n            this.onChange();\n            this._fireIonChange();\n        }\n    }\n    // 1. Updates the value\n    // 2. Calls _inputUpdated()\n    // 3. Dispatch onChange events\n    setValue(val) {\n        this.value = val;\n    }\n    /**\n     * @hidden\n     */\n    setDisabledState(isDisabled) {\n        this._disabled = isDisabled = isTrueProperty(isDisabled);\n        this._item && this._item.setElementClass(`item-${this._componentName}-disabled`, isDisabled);\n    }\n    /**\n     * @hidden\n     */\n    writeValue(val) {\n        if (this._writeValue(val)) {\n            if (this._initModel) {\n                this._fireIonChange();\n            }\n            else if (this._init) {\n                // ngModel fires the first time too late, we need to skip the first ngModel update\n                this._initModel = true;\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    _writeValue(val) {\n        (void 0) /* assert */;\n        if (isUndefined(val)) {\n            return false;\n        }\n        const normalized = (val === null)\n            ? deepCopy(this._defaultValue)\n            : this._inputNormalize(val);\n        const notUpdate = isUndefined(normalized) || !this._inputShouldChange(normalized);\n        if (notUpdate) {\n            return false;\n        }\n        (void 0) /* console.debug */;\n        this._value = normalized;\n        if (this._init) {\n            this._inputUpdated();\n        }\n        return true;\n    }\n    /**\n     * @hidden\n     */\n    _fireIonChange() {\n        if (this._init) {\n            this._debouncer.debounce(() => {\n                (void 0) /* assert */;\n                this.ionChange.emit(this._inputChangeEvent());\n                this._initModel = true;\n            });\n        }\n    }\n    /**\n     * @hidden\n     */\n    registerOnChange(fn) {\n        this._onChanged = fn;\n    }\n    /**\n     * @hidden\n     */\n    registerOnTouched(fn) {\n        this._onTouched = fn;\n    }\n    /**\n     * @hidden\n     */\n    _initialize() {\n        if (this._init) {\n            (void 0) /* assert */;\n            return;\n        }\n        this._init = true;\n        if (isPresent(this._value)) {\n            this._inputUpdated();\n        }\n    }\n    /**\n     * @hidden\n     */\n    _fireFocus() {\n        if (this._isFocus) {\n            return;\n        }\n        (void 0) /* console.debug */;\n        this._form && this._form.setAsFocused(this);\n        this._setFocus(true);\n        this.ionFocus.emit(this);\n    }\n    /**\n     * @hidden\n     */\n    _fireBlur() {\n        if (!this._isFocus) {\n            return;\n        }\n        (void 0) /* console.debug */;\n        this._form && this._form.unsetAsFocused(this);\n        this._setFocus(false);\n        this._fireTouched();\n        this.ionBlur.emit(this);\n    }\n    /**\n     * @hidden\n     */\n    _fireTouched() {\n        this._onTouched && this._onTouched();\n    }\n    /**\n     * @hidden\n     */\n    _setFocus(isFocused) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        this._isFocus = isFocused;\n        const item = this._item;\n        if (item) {\n            item.setElementClass('input-has-focus', isFocused);\n            item.setElementClass('item-input-has-focus', isFocused);\n        }\n        this._inputUpdated();\n    }\n    /**\n     * @hidden\n     */\n    onChange() {\n        this._onChanged && this._onChanged(this._inputNgModelEvent());\n    }\n    /**\n     * @hidden\n     */\n    isFocus() {\n        return this._isFocus;\n    }\n    /**\n     * @hidden\n     */\n    hasValue() {\n        const val = this._value;\n        if (!isPresent(val)) {\n            return false;\n        }\n        if (isArray(val) || isString(val)) {\n            return val.length > 0;\n        }\n        return true;\n    }\n    /**\n     * @hidden\n     */\n    focusNext() {\n        this._form && this._form.tabFocus(this);\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        (void 0) /* assert */;\n        const form = this._form;\n        form && form.deregister(this);\n        this._init = false;\n    }\n    /**\n     * @hidden\n     */\n    ngAfterContentInit() {\n        this._initialize();\n    }\n    /**\n     * @hidden\n     */\n    initFocus() {\n        const ele = this._elementRef.nativeElement.querySelector('button');\n        ele && ele.focus();\n    }\n    /**\n     * @hidden\n     */\n    _inputNormalize(val) {\n        return val;\n    }\n    /**\n     * @hidden\n     */\n    _inputShouldChange(val) {\n        return this._value !== val;\n    }\n    /**\n     * @hidden\n     */\n    _inputChangeEvent() {\n        return this;\n    }\n    /**\n     * @hidden\n     */\n    _inputNgModelEvent() {\n        return this._value;\n    }\n    /**\n     * @hidden\n     */\n    _inputUpdated() {\n        (void 0) /* assert */;\n        const item = this._item;\n        if (item) {\n            setControlCss(item, this._ngControl);\n            // TODO remove all uses of input-has-value in v4\n            let hasValue = this.hasValue();\n            item.setElementClass('input-has-value', hasValue);\n            item.setElementClass('item-input-has-value', hasValue);\n        }\n    }\n}\nBaseInput.propDecorators = {\n    'ionFocus': [{ type: Output },],\n    'ionChange': [{ type: Output },],\n    'ionBlur': [{ type: Output },],\n    'disabled': [{ type: Input },],\n};\nfunction setControlCss(element, control) {\n    if (!control) {\n        return;\n    }\n    element.setElementClass('ng-untouched', control.untouched);\n    element.setElementClass('ng-touched', control.touched);\n    element.setElementClass('ng-pristine', control.pristine);\n    element.setElementClass('ng-dirty', control.dirty);\n    element.setElementClass('ng-valid', control.valid);\n    element.setElementClass('ng-invalid', !control.valid);\n}\n"]}