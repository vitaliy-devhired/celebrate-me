{"version":3,"file":"nav-controller-base.js","sources":["nav-controller-base.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;8LAAC;AACD;AACA;AACA;AAAE;AACF;AACA;AACA;AACA;AACA","sourcesContent":["import { EventEmitter, Input, ReflectiveInjector } from '@angular/core';\nimport { DIRECTION_BACK, DIRECTION_FORWARD, INIT_ZINDEX, STATE_ATTACHED, STATE_DESTROYED, STATE_INITIALIZED, STATE_NEW, convertToViews, } from './nav-util';\nimport { setZIndex } from './nav-util';\nimport { isBlank, isNumber, isPresent, isTrueProperty } from '../util/util';\nimport { ViewController, isViewController } from './view-controller';\nimport { Ion } from '../components/ion';\nimport { NavController } from './nav-controller';\nimport { NavParams } from './nav-params';\nimport { SwipeBackGesture } from './swipe-back';\n/**\n * @hidden\n * This class is for internal use only. It is not exported publicly.\n */\nexport class NavControllerBase extends Ion {\n    constructor(parent, _app, config, plt, elementRef, _zone, renderer, _cfr, _gestureCtrl, _trnsCtrl, _linker, _domCtrl, _errHandler) {\n        super(config, elementRef, renderer);\n        this.parent = parent;\n        this._app = _app;\n        this.config = config;\n        this.plt = plt;\n        this._zone = _zone;\n        this._cfr = _cfr;\n        this._gestureCtrl = _gestureCtrl;\n        this._trnsCtrl = _trnsCtrl;\n        this._linker = _linker;\n        this._domCtrl = _domCtrl;\n        this._errHandler = _errHandler;\n        this._ids = -1;\n        this._init = false;\n        this._queue = [];\n        this._trnsId = null;\n        this._trnsTm = false;\n        this._views = [];\n        this._zIndexOffset = 0;\n        this.viewDidLoad = new EventEmitter();\n        this.viewWillEnter = new EventEmitter();\n        this.viewDidEnter = new EventEmitter();\n        this.viewWillLeave = new EventEmitter();\n        this.viewDidLeave = new EventEmitter();\n        this.viewWillUnload = new EventEmitter();\n        this._sbEnabled = config.getBoolean('swipeBackEnabled');\n        this._children = [];\n        this.id = 'n' + (++ctrlIds);\n        this._destroyed = false;\n    }\n    get swipeBackEnabled() {\n        return this._sbEnabled;\n    }\n    set swipeBackEnabled(val) {\n        this._sbEnabled = isTrueProperty(val);\n        this._swipeBackCheck();\n    }\n    push(page, params, opts, done) {\n        return this._queueTrns({\n            insertStart: -1,\n            insertViews: [{ page: page, params: params }],\n            opts: opts,\n        }, done);\n    }\n    insert(insertIndex, page, params, opts, done) {\n        return this._queueTrns({\n            insertStart: insertIndex,\n            insertViews: [{ page: page, params: params }],\n            opts: opts,\n        }, done);\n    }\n    insertPages(insertIndex, insertPages, opts, done) {\n        return this._queueTrns({\n            insertStart: insertIndex,\n            insertViews: insertPages,\n            opts: opts,\n        }, done);\n    }\n    pop(opts, done) {\n        return this._queueTrns({\n            removeStart: -1,\n            removeCount: 1,\n            opts: opts,\n        }, done);\n    }\n    popTo(indexOrViewCtrl, opts, done) {\n        let config = {\n            removeStart: -1,\n            removeCount: -1,\n            opts: opts\n        };\n        if (isViewController(indexOrViewCtrl)) {\n            config.removeView = indexOrViewCtrl;\n            config.removeStart = 1;\n        }\n        else if (isNumber(indexOrViewCtrl)) {\n            config.removeStart = indexOrViewCtrl + 1;\n        }\n        return this._queueTrns(config, done);\n    }\n    popToRoot(opts, done) {\n        return this._queueTrns({\n            removeStart: 1,\n            removeCount: -1,\n            opts: opts,\n        }, done);\n    }\n    popAll() {\n        let promises = [];\n        for (var i = this._views.length - 1; i >= 0; i--) {\n            promises.push(this.pop(null));\n        }\n        return Promise.all(promises);\n    }\n    remove(startIndex, removeCount = 1, opts, done) {\n        return this._queueTrns({\n            removeStart: startIndex,\n            removeCount: removeCount,\n            opts: opts,\n        }, done);\n    }\n    removeView(viewController, opts, done) {\n        return this._queueTrns({\n            removeView: viewController,\n            removeStart: 0,\n            removeCount: 1,\n            opts: opts,\n        }, done);\n    }\n    setRoot(pageOrViewCtrl, params, opts, done) {\n        return this.setPages([{ page: pageOrViewCtrl, params: params }], opts, done);\n    }\n    setPages(viewControllers, opts, done) {\n        if (isBlank(opts)) {\n            opts = {};\n        }\n        // if animation wasn't set to true then default it to NOT animate\n        if (opts.animate !== true) {\n            opts.animate = false;\n        }\n        return this._queueTrns({\n            insertStart: 0,\n            insertViews: viewControllers,\n            removeStart: 0,\n            removeCount: -1,\n            opts: opts\n        }, done);\n    }\n    // _queueTrns() adds a navigation stack change to the queue and schedules it to run:\n    // 1. _nextTrns(): consumes the next transition in the queue\n    // 2. _viewInit(): initializes enteringView if required\n    // 3. _viewTest(): ensures canLeave/canEnter returns true, so the operation can continue\n    // 4. _postViewInit(): add/remove the views from the navigation stack\n    // 5. _transitionInit(): initializes the visual transition if required and schedules it to run\n    // 6. _viewAttachToDOM(): attaches the enteringView to the DOM\n    // 7. _transitionStart(): called once the transition actually starts, it initializes the Animation underneath.\n    // 8. _transitionFinish(): called once the transition finishes\n    // 9. _cleanup(): syncs the navigation internal state with the DOM. For example it removes the pages from the DOM or hides/show them.\n    _queueTrns(ti, done) {\n        const promise = new Promise((resolve, reject) => {\n            ti.resolve = resolve;\n            ti.reject = reject;\n        });\n        ti.done = done;\n        // Normalize empty\n        if (ti.insertViews && ti.insertViews.length === 0) {\n            ti.insertViews = undefined;\n        }\n        // Enqueue transition instruction\n        this._queue.push(ti);\n        // if there isn't a transition already happening\n        // then this will kick off this transition\n        this._nextTrns();\n        return promise;\n    }\n    _success(result, ti) {\n        if (this._queue === null) {\n            this._fireError('nav controller was destroyed', ti);\n            return;\n        }\n        this._init = true;\n        this._trnsId = null;\n        // ensure we're not transitioning here\n        this.setTransitioning(false);\n        this._swipeBackCheck();\n        // let's see if there's another to kick off\n        this._nextTrns();\n        if (ti.done) {\n            ti.done(result.hasCompleted, result.requiresTransition, result.enteringName, result.leavingName, result.direction);\n        }\n        ti.resolve(result.hasCompleted);\n    }\n    _failed(rejectReason, ti) {\n        if (this._queue === null) {\n            this._fireError('nav controller was destroyed', ti);\n            return;\n        }\n        this._trnsId = null;\n        this._queue.length = 0;\n        // let's see if there's another to kick off\n        this.setTransitioning(false);\n        this._swipeBackCheck();\n        this._nextTrns();\n        this._fireError(rejectReason, ti);\n    }\n    _fireError(rejectReason, ti) {\n        if (ti.done) {\n            ti.done(false, false, rejectReason);\n        }\n        if (ti.reject && !this._destroyed) {\n            ti.reject(rejectReason);\n        }\n        else {\n            ti.resolve(false);\n        }\n    }\n    _nextTrns() {\n        // this is the framework's bread 'n butta function\n        // only one transition is allowed at any given time\n        if (this.isTransitioning()) {\n            return false;\n        }\n        // there is no transition happening right now\n        // get the next instruction\n        const ti = this._queue.shift();\n        if (!ti) {\n            return false;\n        }\n        // set that this nav is actively transitioning\n        let enteringView;\n        let leavingView;\n        this._startTI(ti)\n            .then(() => this._loadLazyLoading(ti))\n            .then(() => {\n            leavingView = this.getActive();\n            enteringView = this._getEnteringView(ti, leavingView);\n            if (!leavingView && !enteringView) {\n                throw 'no views in the stack to be removed';\n            }\n            if (enteringView && enteringView._state === STATE_NEW) {\n                this._viewInit(enteringView);\n            }\n            // Needs transition?\n            ti.requiresTransition = (ti.enteringRequiresTransition || ti.leavingRequiresTransition) && enteringView !== leavingView;\n        })\n            .then(() => this._viewTest(enteringView, leavingView, ti))\n            .then(() => this._postViewInit(enteringView, leavingView, ti))\n            .then(() => this._transition(enteringView, leavingView, ti))\n            .then((result) => this._success(result, ti))\n            .catch((rejectReason) => this._failed(rejectReason, ti));\n        return true;\n    }\n    _startTI(ti) {\n        const viewsLength = this._views.length;\n        if (isPresent(ti.removeView)) {\n            (void 0) /* assert */;\n            (void 0) /* assert */;\n            const index = this.indexOf(ti.removeView);\n            if (index < 0) {\n                return Promise.reject('removeView was not found');\n            }\n            ti.removeStart += index;\n        }\n        if (isPresent(ti.removeStart)) {\n            if (ti.removeStart < 0) {\n                ti.removeStart = (viewsLength - 1);\n            }\n            if (ti.removeCount < 0) {\n                ti.removeCount = (viewsLength - ti.removeStart);\n            }\n            ti.leavingRequiresTransition = (ti.removeCount > 0) && ((ti.removeStart + ti.removeCount) === viewsLength);\n        }\n        if (ti.insertViews) {\n            // allow -1 to be passed in to auto push it on the end\n            // and clean up the index if it's larger then the size of the stack\n            if (ti.insertStart < 0 || ti.insertStart > viewsLength) {\n                ti.insertStart = viewsLength;\n            }\n            ti.enteringRequiresTransition = (ti.insertStart === viewsLength);\n        }\n        this.setTransitioning(true);\n        return Promise.resolve();\n    }\n    _loadLazyLoading(ti) {\n        const insertViews = ti.insertViews;\n        if (insertViews) {\n            (void 0) /* assert */;\n            return convertToViews(this._linker, insertViews).then((viewControllers) => {\n                (void 0) /* assert */;\n                viewControllers = viewControllers.filter(v => v !== null);\n                if (viewControllers.length === 0) {\n                    throw 'invalid views to insert';\n                }\n                // Check all the inserted view are correct\n                for (var i = 0; i < viewControllers.length; i++) {\n                    var view = viewControllers[i];\n                    var nav = view._nav;\n                    if (nav && nav !== this) {\n                        throw 'inserted view was already inserted';\n                    }\n                    if (view._state === STATE_DESTROYED) {\n                        throw 'inserted view was already destroyed';\n                    }\n                }\n                ti.insertViews = viewControllers;\n            });\n        }\n        return Promise.resolve();\n    }\n    _getEnteringView(ti, leavingView) {\n        const insertViews = ti.insertViews;\n        if (insertViews) {\n            // grab the very last view of the views to be inserted\n            // and initialize it as the new entering view\n            return insertViews[insertViews.length - 1];\n        }\n        const removeStart = ti.removeStart;\n        if (isPresent(removeStart)) {\n            var views = this._views;\n            var removeEnd = removeStart + ti.removeCount;\n            var i;\n            var view;\n            for (i = views.length - 1; i >= 0; i--) {\n                view = views[i];\n                if ((i < removeStart || i >= removeEnd) && view !== leavingView) {\n                    return view;\n                }\n            }\n        }\n        return null;\n    }\n    _postViewInit(enteringView, leavingView, ti) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        const opts = ti.opts || {};\n        const insertViews = ti.insertViews;\n        const removeStart = ti.removeStart;\n        const removeCount = ti.removeCount;\n        let view;\n        let i;\n        let destroyQueue;\n        // there are views to remove\n        if (isPresent(removeStart)) {\n            (void 0) /* assert */;\n            (void 0) /* assert */;\n            destroyQueue = [];\n            for (i = 0; i < removeCount; i++) {\n                view = this._views[i + removeStart];\n                if (view && view !== enteringView && view !== leavingView) {\n                    destroyQueue.push(view);\n                }\n            }\n            // default the direction to \"back\"\n            opts.direction = opts.direction || DIRECTION_BACK;\n        }\n        const finalBalance = this._views.length + (insertViews ? insertViews.length : 0) - (removeCount ? removeCount : 0);\n        (void 0) /* assert */;\n        if (finalBalance === 0 && !this._isPortal) {\n            console.warn(`You can't remove all the pages in the navigation stack. nav.pop() is probably called too many times.`, this, this.getNativeElement());\n            throw 'navigation stack needs at least one root page';\n        }\n        // At this point the transition can not be rejected, any throw should be an error\n        // there are views to insert\n        if (insertViews) {\n            // manually set the new view's id if an id was passed in the options\n            if (isPresent(opts.id)) {\n                enteringView.id = opts.id;\n            }\n            // add the views to the\n            for (i = 0; i < insertViews.length; i++) {\n                view = insertViews[i];\n                this._insertViewAt(view, ti.insertStart + i);\n            }\n            if (ti.enteringRequiresTransition) {\n                // default to forward if not already set\n                opts.direction = opts.direction || DIRECTION_FORWARD;\n            }\n        }\n        // if the views to be removed are in the beginning or middle\n        // and there is not a view that needs to visually transition out\n        // then just destroy them and don't transition anything\n        // batch all of lifecycles together\n        // let's make sure, callbacks are zoned\n        if (destroyQueue && destroyQueue.length > 0) {\n            this._zone.run(() => {\n                for (i = 0; i < destroyQueue.length; i++) {\n                    view = destroyQueue[i];\n                    this._willLeave(view, true);\n                    this._didLeave(view);\n                    this._willUnload(view);\n                }\n            });\n            // once all lifecycle events has been delivered, we can safely detroy the views\n            for (i = 0; i < destroyQueue.length; i++) {\n                this._destroyView(destroyQueue[i]);\n            }\n        }\n        // set which animation it should use if it wasn't set yet\n        if (ti.requiresTransition && !opts.animation) {\n            if (isPresent(ti.removeStart)) {\n                opts.animation = (leavingView || enteringView).getTransitionName(opts.direction);\n            }\n            else {\n                opts.animation = (enteringView || leavingView).getTransitionName(opts.direction);\n            }\n        }\n        ti.opts = opts;\n    }\n    /**\n     * DOM WRITE\n     */\n    _viewInit(enteringView) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        // render the entering view, and all child navs and views\n        // entering view has not been initialized yet\n        const componentProviders = ReflectiveInjector.resolve([\n            { provide: NavController, useValue: this },\n            { provide: ViewController, useValue: enteringView },\n            { provide: NavParams, useValue: enteringView.getNavParams() }\n        ]);\n        const componentFactory = this._linker.resolveComponent(enteringView.component);\n        const childInjector = ReflectiveInjector.fromResolvedProviders(componentProviders, this._viewport.parentInjector);\n        // create ComponentRef and set it to the entering view\n        enteringView.init(componentFactory.create(childInjector, []));\n        enteringView._state = STATE_INITIALIZED;\n        this._preLoad(enteringView);\n    }\n    _viewAttachToDOM(view, componentRef, viewport) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        // fire willLoad before change detection runs\n        this._willLoad(view);\n        // render the component ref instance to the DOM\n        // ******** DOM WRITE ****************\n        viewport.insert(componentRef.hostView, viewport.length);\n        view._state = STATE_ATTACHED;\n        if (view._cssClass) {\n            // the ElementRef of the actual ion-page created\n            var pageElement = componentRef.location.nativeElement;\n            // ******** DOM WRITE ****************\n            this._renderer.setElementClass(pageElement, view._cssClass, true);\n        }\n        componentRef.changeDetectorRef.detectChanges();\n        // successfully finished loading the entering view\n        // fire off the \"didLoad\" lifecycle events\n        this._zone.run(this._didLoad.bind(this, view));\n    }\n    _viewTest(enteringView, leavingView, ti) {\n        // Only test canLeave/canEnter if there is transition\n        if (!ti.requiresTransition) {\n            return Promise.resolve();\n        }\n        const promises = [];\n        if (leavingView) {\n            promises.push(leavingView._lifecycleTest('Leave'));\n        }\n        if (enteringView) {\n            promises.push(enteringView._lifecycleTest('Enter'));\n        }\n        if (promises.length === 0) {\n            return Promise.resolve();\n        }\n        // darn, async promises, gotta wait for them to resolve\n        return Promise.all(promises).then((values) => {\n            if (values.some(result => result === false)) {\n                throw 'canEnter/Leave returned false';\n            }\n        }).catch((reason) => {\n            // Do not\n            ti.reject = null;\n            throw reason;\n        });\n    }\n    _transition(enteringView, leavingView, ti) {\n        if (!ti.requiresTransition) {\n            // transition is not required, so we are already done!\n            // they're inserting/removing the views somewhere in the middle or\n            // beginning, so visually nothing needs to animate/transition\n            // resolve immediately because there's no animation that's happening\n            return Promise.resolve({\n                hasCompleted: true,\n                requiresTransition: false\n            });\n        }\n        const opts = ti.opts;\n        // figure out if this transition is the root one or a\n        // child of a parent nav that has the root transition\n        this._trnsId = this._trnsCtrl.getRootTrnsId(this);\n        if (this._trnsId === null) {\n            // this is the root transition, meaning all child navs and their views\n            // should be added as a child transition to this one\n            this._trnsId = this._trnsCtrl.nextId();\n        }\n        // create the transition options\n        const animationOpts = {\n            animation: opts.animation,\n            direction: opts.direction,\n            duration: (opts.animate === false ? 0 : opts.duration),\n            easing: opts.easing,\n            isRTL: this._config.plt.isRTL,\n            ev: opts.ev,\n        };\n        // create the transition animation from the TransitionController\n        // this will either create the root transition, or add it as a child transition\n        const transition = this._trnsCtrl.get(this._trnsId, enteringView, leavingView, animationOpts);\n        // ensure any swipeback transitions are cleared out\n        this._sbTrns && this._sbTrns.destroy();\n        this._sbTrns = null;\n        // swipe to go back root transition\n        if (transition.isRoot() && opts.progressAnimation) {\n            this._sbTrns = transition;\n        }\n        // transition start has to be registered before attaching the view to the DOM!\n        const promise = new Promise(resolve => transition.registerStart(resolve)).then(() => {\n            return this._transitionStart(transition, enteringView, leavingView, opts);\n        });\n        if (enteringView && (enteringView._state === STATE_INITIALIZED)) {\n            // render the entering component in the DOM\n            // this would also render new child navs/views\n            // which may have their very own async canEnter/Leave tests\n            // ******** DOM WRITE ****************\n            this._viewAttachToDOM(enteringView, enteringView._cmp, this._viewport);\n        }\n        if (!transition.hasChildren) {\n            // lowest level transition, so kick it off and let it bubble up to start all of them\n            transition.start();\n        }\n        return promise;\n    }\n    _transitionStart(transition, enteringView, leavingView, opts) {\n        (void 0) /* assert */;\n        this._trnsId = null;\n        // set the correct zIndex for the entering and leaving views\n        // ******** DOM WRITE ****************\n        setZIndex(this, enteringView, leavingView, opts.direction, this._renderer);\n        // always ensure the entering view is viewable\n        // ******** DOM WRITE ****************\n        enteringView && enteringView._domShow(true, this._renderer);\n        // always ensure the leaving view is viewable\n        // ******** DOM WRITE ****************\n        leavingView && leavingView._domShow(true, this._renderer);\n        // initialize the transition\n        transition.init();\n        // we should animate (duration > 0) if the pushed page is not the first one (startup)\n        // or if it is a portal (modal, actionsheet, etc.)\n        const isFirstPage = !this._init && this._views.length === 1;\n        const shouldNotAnimate = isFirstPage && !this._isPortal;\n        const canNotAnimate = this._config.get('animate') === false;\n        if (shouldNotAnimate || canNotAnimate) {\n            opts.animate = false;\n        }\n        if (opts.animate === false) {\n            // if it was somehow set to not animation, then make the duration zero\n            transition.duration(0);\n        }\n        // create a callback that needs to run within zone\n        // that will fire off the willEnter/Leave lifecycle events at the right time\n        transition.beforeAddRead(this._viewsWillLifecycles.bind(this, enteringView, leavingView));\n        // get the set duration of this transition\n        const duration = transition.getDuration();\n        // create a callback for when the animation is done\n        const promise = new Promise(resolve => {\n            transition.onFinish(resolve);\n        });\n        if (transition.isRoot()) {\n            // this is the top most, or only active transition, so disable the app\n            // add XXms to the duration the app is disabled when the keyboard is open\n            if (duration > DISABLE_APP_MINIMUM_DURATION && opts.disableApp !== false) {\n                // if this transition has a duration and this is the root transition\n                // then set that the app is actively disabled\n                this._app.setEnabled(false, duration + ACTIVE_TRANSITION_OFFSET, opts.minClickBlockDuration);\n            }\n            else {\n                (void 0) /* console.debug */;\n            }\n            // cool, let's do this, start the transition\n            if (opts.progressAnimation) {\n                // this is a swipe to go back, just get the transition progress ready\n                // kick off the swipe animation start\n                transition.progressStart();\n            }\n            else {\n                // only the top level transition should actually start \"play\"\n                // kick it off and let it play through\n                // ******** DOM WRITE ****************\n                transition.play();\n            }\n        }\n        return promise.then(() => this._zone.run(() => {\n            return this._transitionFinish(transition, opts);\n        }));\n    }\n    _transitionFinish(transition, opts) {\n        const hasCompleted = transition.hasCompleted;\n        const enteringView = transition.enteringView;\n        const leavingView = transition.leavingView;\n        // mainly for testing\n        let enteringName;\n        let leavingName;\n        if (hasCompleted) {\n            // transition has completed (went from 0 to 1)\n            if (enteringView) {\n                enteringName = enteringView.name;\n                this._didEnter(enteringView);\n            }\n            if (leavingView) {\n                leavingName = leavingView.name;\n                this._didLeave(leavingView);\n            }\n            this._cleanup(enteringView);\n            /**\n             * On iOS 12.2 there is a bug that\n             * causes scrolling to not\n             * be re-enabled unless there\n             * is some kind of CSS reflow triggered\n             */\n            const platform = this.plt;\n            if (enteringView &&\n                enteringView.getIONContentRef &&\n                enteringView.getIONContentRef() &&\n                platform.is('ios')) {\n                platform.timeout(() => {\n                    platform.raf(() => {\n                        const content = enteringView.getIONContentRef().nativeElement;\n                        content.style.zIndex = '1';\n                        platform.raf(() => {\n                            content.style.zIndex = '';\n                        });\n                    });\n                }, 500);\n            }\n        }\n        else {\n            // If transition does not complete, we have to cleanup anyway, because\n            // previous pages in the stack are not hidden probably.\n            this._cleanup(leavingView);\n        }\n        if (transition.isRoot()) {\n            // this is the root transition\n            // it's safe to destroy this transition\n            this._trnsCtrl.destroy(transition.trnsId);\n            // it's safe to enable the app again\n            this._app.setEnabled(true);\n            // mark ourselves as not transitioning - `deepLinker navchange` requires this\n            // TODO - probably could be resolved in a better way\n            this.setTransitioning(false);\n            if (!this.hasChildren() && opts.updateUrl !== false) {\n                // notify deep linker of the nav change\n                // if a direction was provided and should update url\n                this._linker.navChange(opts.direction);\n            }\n            if (opts.keyboardClose !== false) {\n                // the keyboard is still open!\n                // no problem, let's just close for them\n                this.plt.focusOutActiveElement();\n            }\n        }\n        return {\n            hasCompleted: hasCompleted,\n            requiresTransition: true,\n            enteringName: enteringName,\n            leavingName: leavingName,\n            direction: opts.direction\n        };\n    }\n    _viewsWillLifecycles(enteringView, leavingView) {\n        if (enteringView || leavingView) {\n            this._zone.run(() => {\n                // Here, the order is important. WillLeave must be called before WillEnter.\n                if (leavingView) {\n                    const willUnload = enteringView ? leavingView.index > enteringView.index : true;\n                    this._willLeave(leavingView, willUnload);\n                }\n                enteringView && this._willEnter(enteringView);\n            });\n        }\n    }\n    _insertViewAt(view, index) {\n        const existingIndex = this._views.indexOf(view);\n        if (existingIndex > -1) {\n            // this view is already in the stack!!\n            // move it to its new location\n            (void 0) /* assert */;\n            this._views.splice(index, 0, this._views.splice(existingIndex, 1)[0]);\n        }\n        else {\n            (void 0) /* assert */;\n            // this is a new view to add to the stack\n            // create the new entering view\n            view._setNav(this);\n            // give this inserted view an ID\n            this._ids++;\n            if (!view.id) {\n                view.id = `${this.id}-${this._ids}`;\n            }\n            // insert the entering view into the correct index in the stack\n            this._views.splice(index, 0, view);\n        }\n    }\n    _removeView(view) {\n        (void 0) /* assert */;\n        const views = this._views;\n        const index = views.indexOf(view);\n        (void 0) /* assert */;\n        if (index >= 0) {\n            views.splice(index, 1);\n        }\n    }\n    _destroyView(view) {\n        view._destroy(this._renderer);\n        this._removeView(view);\n    }\n    /**\n     * DOM WRITE\n     */\n    _cleanup(activeView) {\n        // ok, cleanup time!! Destroy all of the views that are\n        // INACTIVE and come after the active view\n        // only do this if the views exist, though\n        if (!this._destroyed) {\n            const activeViewIndex = this._views.indexOf(activeView);\n            const views = this._views;\n            let reorderZIndexes = false;\n            let view;\n            let i;\n            for (i = views.length - 1; i >= 0; i--) {\n                view = views[i];\n                if (i > activeViewIndex) {\n                    // this view comes after the active view\n                    // let's unload it\n                    this._willUnload(view);\n                    this._destroyView(view);\n                }\n                else if (i < activeViewIndex && !this._isPortal) {\n                    // this view comes before the active view\n                    // and it is not a portal then ensure it is hidden\n                    view._domShow(false, this._renderer);\n                }\n                if (view._zIndex <= 0) {\n                    reorderZIndexes = true;\n                }\n            }\n            if (!this._isPortal && reorderZIndexes) {\n                for (i = 0; i < views.length; i++) {\n                    view = views[i];\n                    // ******** DOM WRITE ****************\n                    view._setZIndex(view._zIndex + INIT_ZINDEX + 1, this._renderer);\n                }\n            }\n        }\n    }\n    _preLoad(view) {\n        (void 0) /* assert */;\n        view._preLoad();\n    }\n    _willLoad(view) {\n        (void 0) /* assert */;\n        try {\n            view._willLoad();\n        }\n        catch (e) {\n            this._errHandler && this._errHandler.handleError(e);\n        }\n    }\n    _didLoad(view) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        try {\n            view._didLoad();\n            this.viewDidLoad.emit(view);\n            this._app.viewDidLoad.emit(view);\n        }\n        catch (e) {\n            this._errHandler && this._errHandler.handleError(e);\n        }\n    }\n    _willEnter(view) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        try {\n            view._willEnter();\n            this.viewWillEnter.emit(view);\n            this._app.viewWillEnter.emit(view);\n        }\n        catch (e) {\n            this._errHandler && this._errHandler.handleError(e);\n        }\n    }\n    _didEnter(view) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        try {\n            view._didEnter();\n            this.viewDidEnter.emit(view);\n            this._app.viewDidEnter.emit(view);\n        }\n        catch (e) {\n            this._errHandler && this._errHandler.handleError(e);\n        }\n    }\n    _willLeave(view, willUnload) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        try {\n            view._willLeave(willUnload);\n            this.viewWillLeave.emit(view);\n            this._app.viewWillLeave.emit(view);\n        }\n        catch (e) {\n            this._errHandler && this._errHandler.handleError(e);\n        }\n    }\n    _didLeave(view) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        try {\n            view._didLeave();\n            this.viewDidLeave.emit(view);\n            this._app.viewDidLeave.emit(view);\n        }\n        catch (e) {\n            this._errHandler && this._errHandler.handleError(e);\n        }\n    }\n    _willUnload(view) {\n        (void 0) /* assert */;\n        (void 0) /* assert */;\n        try {\n            view._willUnload();\n            this.viewWillUnload.emit(view);\n            this._app.viewWillUnload.emit(view);\n        }\n        catch (e) {\n            this._errHandler && this._errHandler.handleError(e);\n        }\n    }\n    hasChildren() {\n        return this._children && this._children.length > 0;\n    }\n    getActiveChildNavs() {\n        return this._children;\n    }\n    getAllChildNavs() {\n        return this._children;\n    }\n    registerChildNav(container) {\n        this._children.push(container);\n    }\n    unregisterChildNav(nav) {\n        this._children = this._children.filter(child => child !== nav);\n    }\n    destroy() {\n        const views = this._views;\n        let view;\n        for (var i = 0; i < views.length; i++) {\n            view = views[i];\n            view._willUnload();\n            view._destroy(this._renderer);\n        }\n        // release swipe back gesture and transition\n        this._sbGesture && this._sbGesture.destroy();\n        this._sbTrns && this._sbTrns.destroy();\n        this._queue = this._views = this._sbGesture = this._sbTrns = null;\n        // Unregister navcontroller\n        if (this.parent && this.parent.unregisterChildNav) {\n            this.parent.unregisterChildNav(this);\n        }\n        else if (this._app) {\n            this._app.unregisterRootNav(this);\n        }\n        this._destroyed = true;\n    }\n    swipeBackStart() {\n        if (this.isTransitioning() || this._queue.length > 0) {\n            return;\n        }\n        // default the direction to \"back\";\n        const opts = {\n            direction: DIRECTION_BACK,\n            progressAnimation: true\n        };\n        this._queueTrns({\n            removeStart: -1,\n            removeCount: 1,\n            opts: opts,\n        }, null);\n    }\n    swipeBackProgress(stepValue) {\n        if (this._sbTrns && this._sbGesture) {\n            // continue to disable the app while actively dragging\n            this._app.setEnabled(false, ACTIVE_TRANSITION_DEFAULT);\n            this.setTransitioning(true);\n            // set the transition animation's progress\n            this._sbTrns.progressStep(stepValue);\n        }\n    }\n    swipeBackEnd(shouldComplete, currentStepValue, velocity) {\n        if (this._sbTrns && this._sbGesture) {\n            // the swipe back gesture has ended\n            var dur = this._sbTrns.getDuration() / (Math.abs(velocity) + 1);\n            this._sbTrns.progressEnd(shouldComplete, currentStepValue, dur);\n        }\n    }\n    _swipeBackCheck() {\n        if (this.canSwipeBack()) {\n            if (!this._sbGesture) {\n                this._sbGesture = new SwipeBackGesture(this.plt, this, this._gestureCtrl, this._domCtrl);\n            }\n            this._sbGesture.listen();\n        }\n        else if (this._sbGesture) {\n            this._sbGesture.unlisten();\n        }\n    }\n    canSwipeBack() {\n        return (this._sbEnabled &&\n            !this._isPortal &&\n            !this._children.length &&\n            !this.isTransitioning() &&\n            this._app.isEnabled() &&\n            this.canGoBack());\n    }\n    canGoBack() {\n        const activeView = this.getActive();\n        return !!(activeView && activeView.enableBack());\n    }\n    isTransitioning() {\n        return this._trnsTm;\n    }\n    setTransitioning(isTransitioning) {\n        this._trnsTm = isTransitioning;\n    }\n    getActive() {\n        return this._views[this._views.length - 1];\n    }\n    isActive(view) {\n        return (view === this.getActive());\n    }\n    getByIndex(index) {\n        return this._views[index];\n    }\n    getPrevious(view) {\n        // returns the view controller which is before the given view controller.\n        if (!view) {\n            view = this.getActive();\n        }\n        const views = this._views;\n        const index = views.indexOf(view);\n        return (index > 0) ? views[index - 1] : null;\n    }\n    first() {\n        // returns the first view controller in this nav controller's stack.\n        return this._views[0];\n    }\n    last() {\n        // returns the last page in this nav controller's stack.\n        const views = this._views;\n        return views[views.length - 1];\n    }\n    indexOf(view) {\n        // returns the index number of the given view controller.\n        return this._views.indexOf(view);\n    }\n    length() {\n        return this._views.length;\n    }\n    getViews() {\n        return this._views;\n    }\n    /**\n     * Return a view controller\n     */\n    getViewById(id) {\n        for (const vc of this._views) {\n            if (vc && vc.id === id) {\n                return vc;\n            }\n        }\n        return null;\n    }\n    isSwipeBackEnabled() {\n        return this._sbEnabled;\n    }\n    dismissPageChangeViews() {\n        for (let view of this._views) {\n            if (view.data && view.data.dismissOnPageChange) {\n                view.dismiss().catch(() => { });\n            }\n        }\n    }\n    setViewport(val) {\n        this._viewport = val;\n    }\n    resize() {\n        const active = this.getActive();\n        if (!active) {\n            return;\n        }\n        const content = active.getIONContent();\n        content && content.resize();\n    }\n    goToRoot(_opts) {\n        return Promise.reject(new Error('goToRoot needs to be implemented by child class'));\n    }\n    /*\n     * @private\n     */\n    getType() {\n        return 'nav';\n    }\n    /*\n     * @private\n     */\n    getSecondaryIdentifier() {\n        return null;\n    }\n    /**\n     * Returns the active child navigation.\n     */\n    getActiveChildNav() {\n        console.warn('(getActiveChildNav) is deprecated and will be removed in the next major release. Use getActiveChildNavs instead.');\n        return this._children[this._children.length - 1];\n    }\n}\nNavControllerBase.propDecorators = {\n    'swipeBackEnabled': [{ type: Input },],\n};\nlet ctrlIds = -1;\nconst DISABLE_APP_MINIMUM_DURATION = 64;\nconst ACTIVE_TRANSITION_DEFAULT = 5000;\nconst ACTIVE_TRANSITION_OFFSET = 2000;\n"]}