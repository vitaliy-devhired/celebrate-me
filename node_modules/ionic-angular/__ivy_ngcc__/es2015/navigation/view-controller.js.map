{"version":3,"file":"view-controller.js","sources":["view-controller.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;0HAAC;AACD;AACA;AACA;AAAE;AACF;AACA;AACA;AACA;AACA","sourcesContent":["import { EventEmitter, Output } from '@angular/core';\nimport { isPresent } from '../util/util';\nimport { STATE_DESTROYED, STATE_NEW } from './nav-util';\nimport { NavParams } from './nav-params';\n/**\n * @name ViewController\n * @description\n * Access various features and information about the current view.\n * @usage\n *  ```ts\n * import { Component } from '@angular/core';\n * import { ViewController } from 'ionic-angular';\n *\n * @Component({...})\n * export class MyPage{\n *\n *   constructor(public viewCtrl: ViewController) {}\n *\n * }\n * ```\n */\nexport class ViewController {\n    constructor(component, data, rootCssClass = DEFAULT_CSS_CLASS) {\n        this.component = component;\n        this._isHidden = false;\n        this._state = STATE_NEW;\n        /**\n         * Observable to be subscribed to when the current component will become active\n         * @returns {Observable} Returns an observable\n         */\n        this.willEnter = new EventEmitter();\n        /**\n         * Observable to be subscribed to when the current component has become active\n         * @returns {Observable} Returns an observable\n         */\n        this.didEnter = new EventEmitter();\n        /**\n         * Observable to be subscribed to when the current component will no longer be active\n         * @returns {Observable} Returns an observable\n         */\n        this.willLeave = new EventEmitter();\n        /**\n         * Observable to be subscribed to when the current component is no long active\n         * @returns {Observable} Returns an observable\n         */\n        this.didLeave = new EventEmitter();\n        /**\n         * Observable to be subscribed to when the current component has been destroyed\n         * @returns {Observable} Returns an observable\n         */\n        this.willUnload = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.readReady = new EventEmitter();\n        /**\n         * @hidden\n         */\n        this.writeReady = new EventEmitter();\n        /** @hidden */\n        this.isOverlay = false;\n        /** @hidden */\n        this._emitter = new EventEmitter();\n        // passed in data could be NavParams, but all we care about is its data object\n        this.data = (data instanceof NavParams ? data.data : (isPresent(data) ? data : {}));\n        this._cssClass = rootCssClass;\n        this._ts = Date.now();\n        this._bindHandler = this.handleOrientationChange.bind(this);\n        window.addEventListener('orientationchange', this._bindHandler);\n    }\n    handleOrientationChange() {\n        if (this.getContent()) {\n            this.getContent().resize();\n        }\n    }\n    /**\n     * @hidden\n     */\n    init(componentRef) {\n        (void 0) /* assert */;\n        this._ts = Date.now();\n        this._cmp = componentRef;\n        this.instance = this.instance || componentRef.instance;\n        this._detached = false;\n    }\n    _setNav(navCtrl) {\n        this._nav = navCtrl;\n    }\n    _setInstance(instance) {\n        this.instance = instance;\n    }\n    /**\n     * @hidden\n     */\n    subscribe(generatorOrNext) {\n        return this._emitter.subscribe(generatorOrNext);\n    }\n    /**\n     * @hidden\n     */\n    emit(data) {\n        this._emitter.emit(data);\n    }\n    /**\n     * Called when the current viewController has be successfully dismissed\n     */\n    onDidDismiss(callback) {\n        this._onDidDismiss = callback;\n    }\n    /**\n     * Called when the current viewController will be dismissed\n     */\n    onWillDismiss(callback) {\n        this._onWillDismiss = callback;\n    }\n    /**\n     * Dismiss the current viewController\n     * @param {any} [data] Data that you want to return when the viewController is dismissed.\n     * @param {any} [role ]\n     * @param {NavOptions} navOptions Options for the dismiss navigation.\n     * @returns {any} data Returns the data passed in, if any.\n     */\n    dismiss(data, role, navOptions = {}) {\n        if (!this._nav) {\n            (void 0) /* assert */;\n            return Promise.resolve(false);\n        }\n        if (this.isOverlay && !navOptions.minClickBlockDuration) {\n            // This is a Modal being dismissed so we need\n            // to add the minClickBlockDuration option\n            // for UIWebView\n            navOptions.minClickBlockDuration = 400;\n        }\n        this._dismissData = data;\n        this._dismissRole = role;\n        const options = Object.assign({}, this._leavingOpts, navOptions);\n        return this._nav.removeView(this, options).then(() => data);\n    }\n    /**\n     * @hidden\n     */\n    getNav() {\n        return this._nav;\n    }\n    /**\n     * @hidden\n     */\n    getTransitionName(_direction) {\n        return this._nav && this._nav.config.get('pageTransition');\n    }\n    /**\n     * @hidden\n     */\n    getNavParams() {\n        return new NavParams(this.data);\n    }\n    /**\n     * @hidden\n     */\n    setLeavingOpts(opts) {\n        this._leavingOpts = opts;\n    }\n    /**\n     * Check to see if you can go back in the navigation stack.\n     * @returns {boolean} Returns if it's possible to go back from this Page.\n     */\n    enableBack() {\n        // update if it's possible to go back from this nav item\n        if (!this._nav) {\n            return false;\n        }\n        // the previous view may exist, but if it's about to be destroyed\n        // it shouldn't be able to go back to\n        const previousItem = this._nav.getPrevious(this);\n        return !!(previousItem);\n    }\n    /**\n     * @hidden\n     */\n    get name() {\n        return (this.component ? this.component.name : '');\n    }\n    /**\n     * Get the index of the current component in the current navigation stack.\n     * @returns {number} Returns the index of this page within its `NavController`.\n     */\n    get index() {\n        return (this._nav ? this._nav.indexOf(this) : -1);\n    }\n    /**\n     * @returns {boolean} Returns if this Page is the first in the stack of pages within its NavController.\n     */\n    isFirst() {\n        return (this._nav ? this._nav.first() === this : false);\n    }\n    /**\n     * @returns {boolean} Returns if this Page is the last in the stack of pages within its NavController.\n     */\n    isLast() {\n        return (this._nav ? this._nav.last() === this : false);\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    _domShow(shouldShow, renderer) {\n        // using hidden element attribute to display:none and not render views\n        // _hidden value of '' means the hidden attribute will be added\n        // _hidden value of null means the hidden attribute will be removed\n        // doing checks to make sure we only update the DOM when actually needed\n        // if it should render, then the hidden attribute should not be on the element\n        if (this._cmp && shouldShow === this._isHidden) {\n            this._isHidden = !shouldShow;\n            let value = (shouldShow ? null : '');\n            // ******** DOM WRITE ****************\n            renderer.setElementAttribute(this.pageRef().nativeElement, 'hidden', value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    getZIndex() {\n        return this._zIndex;\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    _setZIndex(zIndex, renderer) {\n        if (zIndex !== this._zIndex) {\n            this._zIndex = zIndex;\n            const pageRef = this.pageRef();\n            if (pageRef) {\n                // ******** DOM WRITE ****************\n                renderer.setElementStyle(pageRef.nativeElement, 'z-index', zIndex);\n            }\n        }\n    }\n    /**\n     * @returns {ElementRef} Returns the Page's ElementRef.\n     */\n    pageRef() {\n        return this._cmp && this._cmp.location;\n    }\n    _setContent(directive) {\n        this._cntDir = directive;\n    }\n    /**\n     * @returns {component} Returns the Page's Content component reference.\n     */\n    getContent() {\n        return this._cntDir;\n    }\n    _setContentRef(elementRef) {\n        this._cntRef = elementRef;\n    }\n    /**\n     * @returns {ElementRef} Returns the Content's ElementRef.\n     */\n    contentRef() {\n        return this._cntRef;\n    }\n    _setIONContent(content) {\n        this._setContent(content);\n        this._ionCntDir = content;\n    }\n    /**\n     * @hidden\n     */\n    getIONContent() {\n        return this._ionCntDir;\n    }\n    _setIONContentRef(elementRef) {\n        this._setContentRef(elementRef);\n        this._ionCntRef = elementRef;\n    }\n    /**\n     * @hidden\n     */\n    getIONContentRef() {\n        return this._ionCntRef;\n    }\n    _setHeader(directive) {\n        this._hdrDir = directive;\n    }\n    /**\n     * @hidden\n     */\n    getHeader() {\n        return this._hdrDir;\n    }\n    _setFooter(directive) {\n        this._ftrDir = directive;\n    }\n    /**\n     * @hidden\n     */\n    getFooter() {\n        return this._ftrDir;\n    }\n    _setNavbar(directive) {\n        this._nb = directive;\n    }\n    /**\n     * @hidden\n     */\n    getNavbar() {\n        return this._nb;\n    }\n    /**\n     * Find out if the current component has a NavBar or not. Be sure\n     * to wrap this in an `ionViewWillEnter` method in order to make sure\n     * the view has rendered fully.\n     * @returns {boolean} Returns a boolean if this Page has a navbar or not.\n     */\n    hasNavbar() {\n        return !!this._nb;\n    }\n    /**\n     * Change the title of the back-button. Be sure to call this\n     * after `ionViewWillEnter` to make sure the  DOM has been rendered.\n     * @param {string} val Set the back button text.\n     */\n    setBackButtonText(val) {\n        this._nb && this._nb.setBackButtonText(val);\n    }\n    /**\n     * Set if the back button for the current view is visible or not. Be sure to call this\n     * after `ionViewWillEnter` to make sure the  DOM has been rendered.\n     * @param {boolean} Set if this Page's back button should show or not.\n     */\n    showBackButton(shouldShow) {\n        if (this._nb) {\n            this._nb.hideBackButton = !shouldShow;\n        }\n    }\n    _preLoad() {\n        (void 0) /* assert */;\n        this._lifecycle('PreLoad');\n    }\n    /**\n     * @hidden\n     * The view has loaded. This event only happens once per view will be created.\n     * This event is fired before the component and his children have been initialized.\n     */\n    _willLoad() {\n        (void 0) /* assert */;\n        this._lifecycle('WillLoad');\n    }\n    /**\n     * @hidden\n     * The view has loaded. This event only happens once per view being\n     * created. If a view leaves but is cached, then this will not\n     * fire again on a subsequent viewing. This method is a good place\n     * to put your setup code for the view; however, it is not the\n     * recommended method to use when a view becomes active.\n     */\n    _didLoad() {\n        (void 0) /* assert */;\n        this._lifecycle('DidLoad');\n    }\n    /**\n     * @hidden\n     * The view is about to enter and become the active view.\n     */\n    _willEnter() {\n        this.handleOrientationChange();\n        (void 0) /* assert */;\n        if (this._detached && this._cmp) {\n            // ensure this has been re-attached to the change detector\n            this._cmp.changeDetectorRef.reattach();\n            this._detached = false;\n        }\n        this.willEnter.emit(null);\n        this._lifecycle('WillEnter');\n    }\n    /**\n     * @hidden\n     * The view has fully entered and is now the active view. This\n     * will fire, whether it was the first load or loaded from the cache.\n     */\n    _didEnter() {\n        (void 0) /* assert */;\n        this._nb && this._nb.didEnter();\n        this.didEnter.emit(null);\n        this._lifecycle('DidEnter');\n    }\n    /**\n     * @hidden\n     * The view is about to leave and no longer be the active view.\n     */\n    _willLeave(willUnload) {\n        this.willLeave.emit(null);\n        this._lifecycle('WillLeave');\n        if (willUnload && this._onWillDismiss) {\n            this._onWillDismiss(this._dismissData, this._dismissRole);\n            this._onWillDismiss = null;\n        }\n    }\n    /**\n     * @hidden\n     * The view has finished leaving and is no longer the active view. This\n     * will fire, whether it is cached or unloaded.\n     */\n    _didLeave() {\n        this.didLeave.emit(null);\n        this._lifecycle('DidLeave');\n        // when this is not the active page\n        // we no longer need to detect changes\n        if (!this._detached && this._cmp) {\n            this._cmp.changeDetectorRef.detach();\n            this._detached = true;\n        }\n    }\n    /**\n     * @hidden\n     */\n    _willUnload() {\n        this.willUnload.emit(null);\n        this._lifecycle('WillUnload');\n        this._onDidDismiss && this._onDidDismiss(this._dismissData, this._dismissRole);\n        this._onDidDismiss = null;\n        this._dismissData = null;\n        this._dismissRole = null;\n    }\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    _destroy(renderer) {\n        (void 0) /* assert */;\n        if (this._cmp) {\n            if (renderer) {\n                // ensure the element is cleaned up for when the view pool reuses this element\n                // ******** DOM WRITE ****************\n                var cmpEle = this._cmp.location.nativeElement;\n                renderer.setElementAttribute(cmpEle, 'class', null);\n                renderer.setElementAttribute(cmpEle, 'style', null);\n            }\n            window.removeEventListener('orientationchange', this._bindHandler);\n            // completely destroy this component. boom.\n            this._cmp.destroy();\n        }\n        this._nav = this._cmp = this.instance = this._cntDir = this._cntRef = this._leavingOpts = this._hdrDir = this._ftrDir = this._nb = this._onDidDismiss = this._onWillDismiss = null;\n        this._state = STATE_DESTROYED;\n    }\n    /**\n     * @hidden\n     */\n    _lifecycleTest(lifecycle) {\n        const instance = this.instance;\n        const methodName = 'ionViewCan' + lifecycle;\n        if (instance && instance[methodName]) {\n            try {\n                var result = instance[methodName]();\n                if (result instanceof Promise) {\n                    return result;\n                }\n                else {\n                    // Any value but explitic false, should be true\n                    return Promise.resolve(result !== false);\n                }\n            }\n            catch (e) {\n                return Promise.reject(`${this.name} ${methodName} error: ${e.message}`);\n            }\n        }\n        return Promise.resolve(true);\n    }\n    /**\n     * @hidden\n     */\n    _lifecycle(lifecycle) {\n        const instance = this.instance;\n        const methodName = 'ionView' + lifecycle;\n        if (instance && instance[methodName]) {\n            instance[methodName]();\n        }\n    }\n}\nViewController.propDecorators = {\n    '_emitter': [{ type: Output },],\n};\nexport function isViewController(viewCtrl) {\n    return !!(viewCtrl && viewCtrl._didLoad && viewCtrl._willUnload);\n}\nconst DEFAULT_CSS_CLASS = 'ion-page';\n"]}