{"version":3,"file":"virtual-scroll.d.ts","sources":["virtual-scroll.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { AfterContentInit, ChangeDetectorRef, DoCheck, ElementRef, IterableDiffer, IterableDiffers, NgZone, OnChanges, OnDestroy, Renderer, SimpleChanges, TrackByFunction } from '@angular/core';\nimport { Config } from '../../config/config';\nimport { Content, ScrollEvent } from '../content/content';\nimport { DomController } from '../../platform/dom-controller';\nimport { Platform } from '../../platform/platform';\nimport { ViewController } from '../../navigation/view-controller';\nimport { VirtualCell, VirtualData, VirtualNode } from './virtual-util';\nimport { VirtualItem } from './virtual-item';\nimport { VirtualFooter } from './virtual-footer';\nimport { VirtualHeader } from './virtual-header';\n/**\n * @name VirtualScroll\n * @description\n * Virtual Scroll displays a virtual, \"infinite\" list. An array of records\n * is passed to the virtual scroll containing the data to create templates\n * for. The template created for each record, referred to as a cell, can\n * consist of items, headers, and footers.\n *\n * For performance reasons, not every record in the list is rendered at once;\n * instead a small subset of records (enough to fill the viewport) are rendered\n * and reused as the user scrolls.\n *\n * ### The Basics\n *\n * The array of records should be passed to the `virtualScroll` property.\n * The data given to the `virtualScroll` property must be an array. An item\n * template with the `*virtualItem` property is required in the `virtualScroll`.\n * The `virtualScroll` and `*virtualItem` properties can be added to any element.\n *\n * ```html\n * <ion-list [virtualScroll]=\"items\">\n *\n *   <ion-item *virtualItem=\"let item\">\n *     {% raw %}{{ item }}{% endraw %}\n *   </ion-item>\n *\n * </ion-list>\n * ```\n *\n *\n * ### Section Headers and Footers\n *\n * Section headers and footers are optional. They can be dynamically created\n * from developer-defined functions. For example, a large list of contacts\n * usually has a divider for each letter in the alphabet. Developers provide\n * their own custom function to be called on each record. The logic in the\n * custom function should determine whether to create the section template\n * and what data to provide to the template. The custom function should\n * return `null` if a template shouldn't be created.\n *\n * ```html\n * <ion-list [virtualScroll]=\"items\" [headerFn]=\"myHeaderFn\">\n *\n *   <ion-item-divider *virtualHeader=\"let header\">\n *     Header: {% raw %}{{ header }}{% endraw %}\n *   </ion-item-divider>\n *\n *   <ion-item *virtualItem=\"let item\">\n *     Item: {% raw %}{{ item }}{% endraw %}\n *   </ion-item>\n *\n * </ion-list>\n * ```\n *\n * Below is an example of a custom function called on every record. It\n * gets passed the individual record, the record's index number,\n * and the entire array of records. In this example, after every 20\n * records a header will be inserted. So between the 19th and 20th records,\n * between the 39th and 40th, and so on, a `<ion-item-divider>` will\n * be created and the template's data will come from the function's\n * returned data.\n *\n * ```ts\n * myHeaderFn(record, recordIndex, records) {\n *   if (recordIndex % 20 === 0) {\n *     return 'Header ' + recordIndex;\n *   }\n *   return null;\n * }\n * ```\n *\n *\n * ### Approximate Widths and Heights\n *\n * If the height of items in the virtual scroll are not close to the\n * default size of 40px, it is extremely important to provide a value for\n * approxItemHeight height. An exact pixel-perfect size is not necessary,\n * but without an estimate the virtual scroll will not render correctly.\n *\n * The approximate width and height of each template is used to help\n * determine how many cells should be created, and to help calculate\n * the height of the scrollable area. Note that the actual rendered size\n * of each cell comes from the app's CSS, whereas this approximation\n * is only used to help calculate initial dimensions.\n *\n * It's also important to know that Ionic's default item sizes have\n * slightly different heights between platforms, which is perfectly fine.\n *\n *\n * ### Images Within Virtual Scroll\n *\n * HTTP requests, image decoding, and image rendering can cause jank while\n * scrolling. In order to better control images, Ionic provides `<ion-img>`\n * to manage HTTP requests and image rendering. While scrolling through items\n * quickly, `<ion-img>` knows when and when not to make requests, when and\n * when not to render images, and only loads the images that are viewable\n * after scrolling. [Read more about `ion-img`.](../../img/Img/)\n *\n * It's also important for app developers to ensure image sizes are locked in,\n * and after images have fully loaded they do not change size and affect any\n * other element sizes. Simply put, to ensure rendering bugs are not introduced,\n * it's vital that elements within a virtual item does not dynamically change.\n *\n * For virtual scrolling, the natural effects of the `<img>` are not desirable\n * features. We recommend using the `<ion-img>` component over the native\n * `<img>` element because when an `<img>` element is added to the DOM, it\n * immediately makes a HTTP request for the image file. Additionally, `<img>`\n * renders whenever it wants which could be while the user is scrolling. However,\n * `<ion-img>` is governed by the containing `ion-content` and does not render\n * images while scrolling quickly.\n *\n * ```html\n * <ion-list [virtualScroll]=\"items\">\n *\n *   <ion-item *virtualItem=\"let item\">\n *     <ion-avatar item-start>\n *       <ion-img [src]=\"item.avatarUrl\"></ion-img>\n *     </ion-avatar>\n *    {% raw %} {{ item.firstName }} {{ item.lastName }}{% endraw %}\n *   </ion-item>\n *\n * </ion-list>\n * ```\n *\n *\n * ### Custom Components\n *\n * If a custom component is going to be used within Virtual Scroll, it's best\n * to wrap it with a good old `<div>` to ensure the component is rendered\n * correctly. Since each custom component's implementation and internals can be\n * quite different, wrapping within a `<div>` is a safe way to make sure\n * dimensions are measured correctly.\n *\n * ```html\n * <ion-list [virtualScroll]=\"items\">\n *\n *   <div *virtualItem=\"let item\">\n *     <my-custom-item [item]=\"item\">\n *       {% raw %} {{ item }}{% endraw %}\n *     </my-custom-item>\n *   </div>\n *\n * </ion-list>\n * ```\n *\n *\n * ## Virtual Scroll Performance Tips\n *\n * #### iOS Cordova WKWebView\n *\n * When deploying to iOS with Cordova, it's highly recommended to use the\n * [WKWebView plugin](http://blog.ionic.io/cordova-ios-performance-improvements-drop-in-speed-with-wkwebview/)\n * in order to take advantage of iOS's higher performimg webview. Additionally,\n * WKWebView is superior at scrolling efficiently in comparision to the older\n * UIWebView.\n *\n * #### Lock in element dimensions and locations\n *\n * In order for virtual scroll to efficiently size and locate every item, it's\n * very important every element within each virtual item does not dynamically\n * change its dimensions or location. The best way to ensure size and location\n * does not change, it's recommended each virtual item has locked in its size\n * via CSS.\n *\n * #### Use `ion-img` for images\n *\n * When including images within Virtual Scroll, be sure to use\n * [`ion-img`](../img/Img/) rather than the standard `<img>` HTML element.\n * With `ion-img`, images are lazy loaded so only the viewable ones are\n * rendered, and HTTP requests are efficiently controlled while scrolling.\n *\n * #### Set Approximate Widths and Heights\n *\n * As mentioned above, all elements should lock in their dimensions. However,\n * virtual scroll isn't aware of the dimensions until after they have been\n * rendered. For the initial render, virtual scroll still needs to set\n * how many items should be built. With \"approx\" property inputs, such as\n * `approxItemHeight`, we're able to give virtual scroll an approximate size,\n * therefore allowing virtual scroll to decide how many items should be\n * created.\n *\n * #### Changing dataset should use `virtualTrackBy`\n *\n * It is possible for the identities of elements in the iterator to change\n * while the data does not. This can happen, for example, if the iterator\n * produced from an RPC to the server, and that RPC is re-run. Even if the\n * \"data\" hasn't changed, the second response will produce objects with\n * different identities, and Ionic will tear down the entire DOM and rebuild\n * it. This is an expensive operation and should be avoided if possible.\n *\n * #### Efficient headers and footer functions\n *\n * Each virtual item must stay extremely efficient, but one way to really\n * kill its performance is to perform any DOM operations within section header\n * and footer functions. These functions are called for every record in the\n * dataset, so please make sure they're performant.\n *\n */\nexport declare class VirtualScroll implements DoCheck, OnChanges, AfterContentInit, OnDestroy {\n    private _iterableDiffers;\n    private _elementRef;\n    private _renderer;\n    private _zone;\n    private _cd;\n    private _content;\n    private _plt;\n    private _ctrl;\n    private _config;\n    private _dom;\n    _differ: IterableDiffer<any>;\n    _scrollSub: any;\n    _scrollEndSub: any;\n    _resizeSub: any;\n    _init: boolean;\n    _lastEle: boolean;\n    _hdrFn: Function;\n    _ftrFn: Function;\n    _records: any[];\n    _cells: VirtualCell[];\n    _nodes: VirtualNode[];\n    _vHeight: number;\n    _lastCheck: number;\n    _recordSize: number;\n    _data: VirtualData;\n    _queue: number;\n    _itmTmp: VirtualItem;\n    _hdrTmp: VirtualHeader;\n    _ftrTmp: VirtualFooter;\n    /**\n     * @input {array} The data that builds the templates within the virtual scroll.\n     * This is the same data that you'd pass to `*ngFor`. It's important to note\n     * that when this data has changed, then the entire virtual scroll is reset,\n     * which is an expensive operation and should be avoided if possible.\n     */\n    virtualScroll: any;\n    /**\n     * @input {number} The buffer ratio is used to decide how many cells\n     * should get created when initially rendered. The number is a\n     * multiplier against the viewable area's height. For example, if it\n     * takes `20` cells to fill up the height of the viewable area, then\n     * with a buffer ratio of `3` it will create `60` cells that are\n     * available for reuse while scrolling. For better performance, it's\n     * better to have more cells than what are required to fill the\n     * viewable area. Default is `3`.\n     * In case more than one items are rendered per row, bufferRatio\n     * has to account for that and a multiple number should be used.\n     * For example if a single item per row list used 3 as bufferRatio\n     * a 4 item per row list should use 3 * 4 = 12 as buffer ratio.\n     */\n    bufferRatio: number;\n    /**\n     * @input {string} The approximate width of each item template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This value can use either `px` or `%` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered. Default is\n     * `100%`.\n     */\n    approxItemWidth: string;\n    /**\n     * @input {string} It is important to provide this\n     * if virtual item height will be significantly larger than the default\n     * The approximate height of each virtual item template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered. Default is\n     * `40px`.\n     */\n    approxItemHeight: string;\n    /**\n     * @input {string} The approximate width of each header template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This value can use either `px` or `%` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions. Default is `100%`.\n     */\n    approxHeaderWidth: string;\n    /**\n     * @input {string} The approximate height of each header template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered. Default is `40px`.\n     */\n    approxHeaderHeight: string;\n    /**\n     * @input {string} The approximate width of each footer template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This value can use either `px` or `%` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered. Default is `100%`.\n     */\n    approxFooterWidth: string;\n    /**\n     * @input {string} The approximate height of each footer template's cell.\n     * This dimension is used to help determine how many cells should\n     * be created when initialized, and to help calculate the height of\n     * the scrollable area. This height value can only use `px` units.\n     * Note that the actual rendered size of each cell comes from the\n     * app's CSS, whereas this approximation is used to help calculate\n     * initial dimensions before the item has been rendered. Default is `40px`.\n     */\n    approxFooterHeight: string;\n    /**\n     * @input {function} Section headers and the data used within its given\n     * template can be dynamically created by passing a function to `headerFn`.\n     * For example, a large list of contacts usually has dividers between each\n     * letter in the alphabet. App's can provide their own custom `headerFn`\n     * which is called with each record within the dataset. The logic within\n     * the header function can decide if the header template should be used,\n     * and what data to give to the header template. The function must return\n     * `null` if a header cell shouldn't be created.\n     */\n    headerFn: Function;\n    /**\n     * @input {function} Section footers and the data used within its given\n     * template can be dynamically created by passing a function to `footerFn`.\n     * The logic within the footer function can decide if the footer template\n     * should be used, and what data to give to the footer template. The function\n     * must return `null` if a footer cell shouldn't be created.\n     */\n    footerFn: Function;\n    /**\n     * @input {function} Same as `ngForTrackBy` which can be used on `ngFor`.\n     */\n    virtualTrackBy: TrackByFunction<any>;\n    constructor(_iterableDiffers: IterableDiffers, _elementRef: ElementRef, _renderer: Renderer, _zone: NgZone, _cd: ChangeDetectorRef, _content: Content, _plt: Platform, _ctrl: ViewController, _config: Config, _dom: DomController);\n    /**\n     * @hidden\n     */\n    firstRecord(): number;\n    /**\n     * @hidden\n     */\n    lastRecord(): number;\n    /**\n    * @hidden\n    */\n    ngOnChanges(changes: SimpleChanges): void;\n    /**\n     * @hidden\n     */\n    ngDoCheck(): void;\n    /**\n     * @hidden\n     */\n    readUpdate(needClean: boolean): void;\n    /**\n     * @hidden\n     */\n    writeUpdate(needClean: boolean): void;\n    /**\n     * @hidden\n     */\n    private calcDimensions();\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    renderVirtual(needClean: boolean): void;\n    /**\n     * @hidden\n     */\n    resize(): void;\n    /**\n     * @hidden\n     */\n    private _stepDOMWrite();\n    /**\n     * @hidden\n     */\n    private _stepChangeDetection();\n    /**\n     * @hidden\n     */\n    private _stepNoChanges();\n    /**\n     * @hidden\n     */\n    scrollUpdate(ev: ScrollEvent): void;\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    scrollEnd(): void;\n    /**\n     * @hidden\n     * NO DOM\n     */\n    private _listeners();\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    private _setHeight(newVirtualHeight);\n    /**\n     * @hidden\n     */\n    ngAfterContentInit(): void;\n    /**\n     * @hidden\n     */\n    setElementClass(className: string, add: boolean): void;\n    /**\n     * @hidden\n     */\n    ngOnDestroy(): void;\n}\n"]}