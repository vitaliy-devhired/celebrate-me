{"version":3,"file":"img.d.ts","sources":["img.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ElementRef, OnDestroy, Renderer } from '@angular/core';\nimport { Img as IImg } from './img-interface';\nimport { Content } from '../content/content';\nimport { DomController } from '../../platform/dom-controller';\nimport { Platform } from '../../platform/platform';\n/**\n * @name Img\n * @description\n * Two of the biggest cuprits of scroll jank is starting up a new HTTP\n * request, and rendering images. These two reasons is largely why\n * `ion-img` was created. The standard HTML `img` element is often a large\n * source of these problems, and what makes matters worse is that the app\n * does not have fine-grained control of requests and rendering for each\n * `img` element.\n *\n * The `ion-img` component is similar to the standard `img` element,\n * but it also adds features in order to provide improved performance.\n * Features include only loading images which are visible, using web workers\n * for HTTP requests, preventing jank while scrolling and in-memory caching.\n *\n * Note that `ion-img` also comes with a few more restrictions in comparison\n * to the standard `img` element. A good rule is, if there are only a few\n * images to be rendered on a page, then the standard `img` is probably\n * best. However, if a page has the potential for hundreds or even thousands\n * of images within a scrollable area, then `ion-img` would be better suited\n * for the job.\n *\n * > Note: `ion-img` is only meant to be used inside of [virtual-scroll](/docs/api/components/virtual-scroll/VirtualScroll/)\n *\n *\n * ### Lazy Loading\n *\n * Lazy loading images refers to only loading images which are actually\n * visible within the user's viewport. This also means that images which are\n * not viewable on the initial load would not be downloaded or rendered. Next,\n * as the user scrolls, each image which becomes visible is then requested\n * then rendered on-demand.\n *\n * The benefits of this approach is that unnecessary and resource intensive\n * HTTP requests are not started, valuable bandwidth isn't wasted, and this\n * allows the browser to free up resources which would be wasted on images\n * which are not even viewable. For example, animated GIFs are enourmous\n * performance drains, however, with `ion-img` the app is able to dedicate\n * resources to just the viewable images. But again, if the problems listed\n * above are not problems within your app, then the standard `img` element\n * may be best.\n *\n *\n * ### Image Dimensions\n *\n * By providing image dimensions up front, Ionic is able to accurately size\n * up the image's location within the viewport, which helps lazy load only\n * images which are viewable. Image dimensions can either by set as\n * properties, inline styles, or external stylesheets. It doesn't matter\n * which method of setting dimensions is used, but it's important that somehow\n * each `ion-img` has been given an exact size.\n *\n * For example, by default `<ion-avatar>` and `<ion-thumbnail>` already come\n * with exact sizes when placed within an `<ion-item>`. By giving each image\n * an exact size, this then further locks in the size of each `ion-item`,\n * which again helps improve scroll performance.\n *\n * ```html\n * <!-- dimensions set using attributes -->\n * <ion-img width=\"80\" height=\"80\" src=\"...\"></ion-img>\n *\n * <!-- dimensions set using input properties -->\n * <ion-img [width]=\"imgWidth\" [height]=\"imgHeight\" src=\"...\"></ion-img>\n *\n * <!-- dimensions set using inline styles -->\n * <ion-img style=\"width: 80px; height: 80px;\" src=\"...\"></ion-img>\n * ```\n *\n * Additionally, each `ion-img` uses the `object-fit: cover` CSS property.\n * What this means is that the actual rendered image will center itself within\n * it's container. Or to really get detailed: The image is sized to maintain\n * its aspect ratio while filling the containing element’s entire content box.\n * Its concrete object size is resolved as a cover constraint against the\n * element’s used width and height.\n *\n * ### Future Optimizations\n *\n * Future goals are to place image requests within web workers, and cache\n * images in-memory as datauris. This method has proven to be effective,\n * however there are some current limitations with Cordova which we are\n * currently working on.\n *\n */\nexport declare class Img implements OnDestroy, IImg {\n    private _elementRef;\n    private _renderer;\n    private _plt;\n    private _content;\n    private _dom;\n    /** @internal */\n    _src: string;\n    /** @internal */\n    _requestingSrc: string;\n    /** @internal */\n    _renderedSrc: string;\n    /** @internal */\n    _hasLoaded: boolean;\n    /** @internal */\n    _cache: boolean;\n    /** @internal */\n    _bounds: any;\n    /** @internal */\n    _rect: any;\n    /** @internal */\n    _w: string;\n    /** @internal */\n    _h: string;\n    /** @internal */\n    _wQ: string;\n    /** @internal */\n    _hQ: string;\n    /** @internal */\n    _img: HTMLImageElement;\n    /** @internal */\n    _unreg: Function;\n    /** @hidden */\n    canRequest: boolean;\n    /** @hidden */\n    canRender: boolean;\n    constructor(_elementRef: ElementRef, _renderer: Renderer, _plt: Platform, _content: Content, _dom: DomController);\n    /**\n     * @input {string} The source of the image.\n     */\n    src: string;\n    /**\n     * @hidden\n     */\n    reset(): void;\n    /**\n     * @hidden\n     */\n    update(): void;\n    /**\n     * @internal\n     */\n    _isLoaded(isLoaded: boolean): void;\n    /**\n     * @internal\n     */\n    _srcAttr(srcAttr: string): void;\n    /**\n     * @hidden\n     */\n    readonly top: number;\n    /**\n     * @hidden\n     */\n    readonly bottom: number;\n    private _getBounds();\n    /**\n     * @input {any}  Sets the bounding rectangle of the element relative to the viewport.\n     * When using `VirtualScroll`, each virtual item should pass its bounds to each\n     * `ion-img`. The passed in data object should include `top` and `bottom` properties.\n     */\n    bounds: any;\n    /**\n     * @input {boolean}  After an image has been successfully downloaded, it can be cached\n     * in-memory. This is useful for `VirtualScroll` by allowing image responses to be\n     * cached, and not rendered, until after scrolling has completed, which allows for\n     * smoother scrolling.\n     */\n    cache: boolean;\n    /**\n     * @input {string}  Image width. If this property is not set it's important that\n     * the dimensions are still set using CSS. If the dimension is just a number it\n     * will assume the `px` unit.\n     */\n    width: string | number;\n    /**\n     * @input {string}  Image height. If this property is not set it's important that\n     * the dimensions are still set using CSS. If the dimension is just a number it\n     * will assume the `px` unit.\n     */\n    height: string | number;\n    private _setDims();\n    /**\n     * @input {string}  Set the `alt` attribute which gets assigned to\n     * the inner `img` element.\n     */\n    alt: string;\n    /**\n     * @hidden\n     */\n    ngAfterContentInit(): void;\n    /**\n     * @hidden\n     */\n    ngOnDestroy(): void;\n}\n"]}