{"version":3,"file":"menu.d.ts","sources":["menu.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ElementRef, EventEmitter, OnDestroy, OnInit, Renderer } from '@angular/core';\nimport { App } from '../app/app';\nimport { Backdrop } from '../backdrop/backdrop';\nimport { Config } from '../../config/config';\nimport { Content } from '../content/content';\nimport { DomController } from '../../platform/dom-controller';\nimport { GestureController } from '../../gestures/gesture-controller';\nimport { Side } from '../../util/util';\nimport { Keyboard } from '../../platform/keyboard';\nimport { Menu as MenuInterface } from '../app/menu-interface';\nimport { MenuController } from '../app/menu-controller';\nimport { Nav } from '../nav/nav';\nimport { Platform } from '../../platform/platform';\nimport { RootNode } from '../split-pane/split-pane';\n/**\n * @name Menu\n * @description\n * The Menu component is a navigation drawer that slides in from the side of the current\n * view. By default, it slides in from the left, but the side can be overridden. The menu\n * will be displayed differently based on the mode, however the display type can be changed\n * to any of the available [menu types](#menu-types). The menu element should be a sibling\n * to the app's content element. There can be any number of menus attached to the content.\n * These can be controlled from the templates, or programmatically using the [MenuController](../../app/MenuController).\n *\n * @usage\n *\n * ```html\n * <ion-menu [content]=\"mycontent\">\n *   <ion-content>\n *     <ion-list>\n *       <p>some menu content, could be list items</p>\n *     </ion-list>\n *   </ion-content>\n * </ion-menu>\n *\n * <ion-nav #mycontent [root]=\"rootPage\"></ion-nav>\n * ```\n *\n * To add a menu to an app, the `<ion-menu>` element should be added as a sibling to the `ion-nav` it will belong\n * to. A [local variable](https://angular.io/docs/ts/latest/guide/user-input.html#local-variables)\n * should be added to the `ion-nav` and passed to the `ion-menu`s `content` property.\n *\n * This tells the menu what it is bound to and what element to watch for gestures.\n * In the below example, `content` is using [property binding](https://angular.io/docs/ts/latest/guide/template-syntax.html#!#property-binding)\n * because `mycontent` is a reference to the `<ion-nav>` element, and not a string.\n *\n *\n * ### Opening/Closing Menus\n *\n * There are several ways to open or close a menu. The menu can be **toggled** open or closed\n * from the template using the [MenuToggle](../MenuToggle) directive. It can also be\n * **closed** from the template using the [MenuClose](../MenuClose) directive. To display a menu\n * programmatically, inject the [MenuController](../MenuController) provider and call any of the\n * `MenuController` methods.\n *\n *\n * ### Menu Types\n *\n * The menu supports several display types: `overlay`, `reveal` and `push`. By default,\n * it will use the correct type based on the mode, but this can be changed. The default\n * type for both Material Design and Windows mode is `overlay`, and `reveal` is the default\n * type for iOS mode. The menu type can be changed in the app's [config](../../config/Config)\n * via the `menuType` property, or passed in the `type` property on the `<ion-menu>` element.\n * See [usage](#usage) below for examples of changing the menu type.\n *\n *\n * ### Navigation Bar Behavior\n *\n * If a [MenuToggle](../MenuToggle) button is added to the [Navbar](../../navbar/Navbar) of\n * a page, the button will only appear when the page it's in is currently a root page. The\n * root page is the initial page loaded in the app, or a page that has been set as the root\n * using the [setRoot](../../nav/NavController/#setRoot) method on the [NavController](../../nav/NavController).\n *\n * For example, say the application has two pages, `Page1` and `Page2`, and both have a\n * `MenuToggle` button in their navigation bars. Assume the initial page loaded into the app\n * is `Page1`, making it the root page. `Page1` will display the `MenuToggle` button, but once\n * `Page2` is pushed onto the navigation stack, the `MenuToggle` will not be displayed.\n *\n *\n * ### Persistent Menus\n *\n * Persistent menus display the [MenuToggle](../MenuToggle) button in the [Navbar](../../navbar/Navbar)\n * on all pages in the navigation stack. To make a menu persistent set `persistent` to `true` on the\n * `<ion-menu>` element. Note that this will only affect the `MenuToggle` button in the `Navbar` attached\n * to the `Menu` with `persistent` set to true, any other `MenuToggle` buttons will not be affected.\n * ### Menu Side\n *\n * By default, menus slide in from the left, but this can be overridden by passing `right`\n * to the `side` property:\n *\n * ```html\n * <ion-menu side=\"right\" [content]=\"mycontent\">...</ion-menu>\n * ```\n *\n *\n * ### Menu Type\n *\n * The menu type can be changed by passing the value to `type` on the `<ion-menu>`:\n *\n * ```html\n * <ion-menu type=\"overlay\" [content]=\"mycontent\">...</ion-menu>\n * ```\n *\n * It can also be set in the app's config. The below will set the menu type to\n * `push` for all modes, and then set the type to `overlay` for the `ios` mode.\n *\n * ```ts\n * // in NgModules\n *\n * imports: [\n *   IonicModule.forRoot(MyApp,{\n *     menuType: 'push',\n *     platforms: {\n *       ios: {\n *         menuType: 'overlay',\n *       }\n *     }\n *   })\n * ],\n * ```\n *\n *\n * ### Displaying the Menu\n *\n * To toggle a menu from the template, add a button with the `menuToggle`\n * directive anywhere in the page's template:\n *\n * ```html\n * <button ion-button menuToggle>Toggle Menu</button>\n * ```\n *\n * To close a menu, add the `menuClose` button. It can be added anywhere\n * in the content, or even the menu itself. Below it is added to the menu's\n * content:\n *\n * ```html\n * <ion-menu [content]=\"mycontent\">\n *   <ion-content>\n *     <ion-list>\n *       <ion-item menuClose detail-none>Close Menu</ion-item>\n *     </ion-list>\n *   </ion-content>\n * </ion-menu>\n * ```\n *\n * See the [MenuToggle](../MenuToggle) and [MenuClose](../MenuClose) docs\n * for more information on these directives.\n *\n * The menu can also be controlled from the Page by using the `MenuController`.\n * Inject the `MenuController` provider into the page and then call any of its\n * methods. In the below example, the `openMenu` method will open the menu\n * when it is called.\n *\n * ```ts\n * import { Component } from '@angular/core';\n * import { MenuController } from 'ionic-angular';\n *\n * @Component({...})\n * export class MyPage {\n *  constructor(public menuCtrl: MenuController) {}\n *\n *  openMenu() {\n *    this.menuCtrl.open();\n *  }\n * }\n * ```\n *\n * See the [MenuController](../../app/MenuController) API docs for all of the methods\n * and usage information.\n *\n *\n * @demo /docs/demos/src/menu/\n *\n * @see {@link /docs/components#menus Menu Component Docs}\n * @see {@link ../../app/MenuController MenuController API Docs}\n * @see {@link ../../nav/Nav Nav API Docs}\n * @see {@link ../../nav/NavController NavController API Docs}\n */\nexport declare class Menu implements RootNode, MenuInterface, OnInit, OnDestroy {\n    _menuCtrl: MenuController;\n    private _elementRef;\n    private _config;\n    private _plt;\n    private _renderer;\n    private _keyboard;\n    private _gestureCtrl;\n    private _domCtrl;\n    private _app;\n    private _cntEle;\n    private _gesture;\n    private _type;\n    private _isEnabled;\n    private _isSwipeEnabled;\n    private _isAnimating;\n    private _isPersistent;\n    private _init;\n    private _events;\n    private _gestureBlocker;\n    private _isPane;\n    private _side;\n    /**\n     * @hidden\n     */\n    isOpen: boolean;\n    /**\n     * @hidden\n     */\n    isRightSide: boolean;\n    /**\n     * @hidden\n     */\n    backdrop: Backdrop;\n    /**\n     * @hidden\n     */\n    menuContent: Content;\n    /**\n     * @hidden\n     */\n    menuNav: Nav;\n    /**\n     * @input {any} A reference to the content element the menu should use.\n     */\n    content: any;\n    /**\n     * @input {string} An id for the menu.\n     */\n    id: string;\n    /**\n     * @input {string} The display type of the menu. Default varies based on the mode,\n     * see the `menuType` in the [config](../../config/Config). Available options:\n     * `\"overlay\"`, `\"reveal\"`, `\"push\"`.\n     */\n    type: string;\n    /**\n     * @input {boolean} If true, the menu is enabled. Default `true`.\n     */\n    enabled: boolean;\n    /**\n     * @input {string} Which side of the view the menu should be placed. Default `\"left\"`.\n     */\n    side: Side;\n    /**\n     * @input {boolean} If true, swiping the menu is enabled. Default `true`.\n     */\n    swipeEnabled: boolean;\n    /**\n     * @input {boolean} If true, the menu will persist on child pages.\n     */\n    persistent: boolean;\n    /**\n     * @hidden\n     */\n    maxEdgeStart: number;\n    /**\n     * @output {event} Emitted when the menu is being dragged open.\n     */\n    ionDrag: EventEmitter<number>;\n    /**\n     * @output {event} Emitted when the menu has been opened.\n     */\n    ionOpen: EventEmitter<boolean>;\n    /**\n     * @output {event} Emitted when the menu has been closed.\n     */\n    ionClose: EventEmitter<boolean>;\n    constructor(_menuCtrl: MenuController, _elementRef: ElementRef, _config: Config, _plt: Platform, _renderer: Renderer, _keyboard: Keyboard, _gestureCtrl: GestureController, _domCtrl: DomController, _app: App);\n    /**\n     * @hidden\n     */\n    ngOnInit(): void;\n    /**\n     * @hidden\n     */\n    onBackdropClick(ev: UIEvent): void;\n    /**\n     * @hidden\n     */\n    private _getType();\n    /**\n     * @hidden\n     */\n    setOpen(shouldOpen: boolean, animated?: boolean): Promise<boolean>;\n    _forceClosing(): void;\n    /**\n     * @hidden\n     */\n    canSwipe(): boolean;\n    /**\n     * @hidden\n     */\n    isAnimating(): boolean;\n    _swipeBeforeStart(): void;\n    _swipeStart(): void;\n    _swipeProgress(stepValue: number): void;\n    _swipeEnd(shouldCompleteLeft: boolean, shouldCompleteRight: boolean, stepValue: number, velocity: number): void;\n    private _before();\n    private _after(isOpen);\n    /**\n     * @hidden\n     */\n    open(): Promise<boolean>;\n    /**\n     * @hidden\n     */\n    close(): Promise<boolean>;\n    /**\n     * @hidden\n     */\n    resize(): void;\n    /**\n     * @hidden\n     */\n    toggle(): Promise<boolean>;\n    _canOpen(): boolean;\n    /**\n     * @hidden\n     */\n    _updateState(): void;\n    /**\n     * @hidden\n     */\n    enable(shouldEnable: boolean): Menu;\n    /**\n     * @internal\n     */\n    initPane(): boolean;\n    /**\n     * @internal\n     */\n    paneChanged(isPane: boolean): void;\n    /**\n     * @hidden\n     */\n    swipeEnable(shouldEnable: boolean): Menu;\n    /**\n     * @hidden\n     */\n    getNativeElement(): HTMLElement;\n    /**\n     * @hidden\n     */\n    getMenuElement(): HTMLElement;\n    /**\n     * @hidden\n     */\n    getContentElement(): HTMLElement;\n    /**\n     * @hidden\n     */\n    getBackdropElement(): HTMLElement;\n    /**\n     * @hidden\n     */\n    width(): number;\n    /**\n     * @hidden\n     */\n    getMenuController(): MenuController;\n    /**\n     * @hidden\n     */\n    setElementClass(className: string, add: boolean): void;\n    /**\n     * @hidden\n     */\n    setElementAttribute(attributeName: string, value: string): void;\n    /**\n     * @hidden\n     */\n    getElementRef(): ElementRef;\n    /**\n     * @hidden\n     */\n    ngOnDestroy(): void;\n}\n"]}