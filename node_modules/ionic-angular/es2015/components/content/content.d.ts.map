{"version":3,"file":"content.d.ts","sources":["content.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { AfterViewInit, ElementRef, EventEmitter, NgZone, OnDestroy, Renderer } from '@angular/core';\nimport { App } from '../app/app';\nimport { Config } from '../../config/config';\nimport { DomController } from '../../platform/dom-controller';\nimport { Img } from '../img/img-interface';\nimport { Ion } from '../ion';\nimport { Keyboard } from '../../platform/keyboard';\nimport { NavController } from '../../navigation/nav-controller';\nimport { Content as IContent, Tabs } from '../../navigation/nav-interfaces';\nimport { Platform } from '../../platform/platform';\nimport { ScrollEvent, ScrollView } from '../../util/scroll-view';\nimport { ViewController } from '../../navigation/view-controller';\nexport { ScrollEvent } from '../../util/scroll-view';\nexport declare class EventEmitterProxy<T> extends EventEmitter<T> {\n    onSubscribe: Function;\n    subscribe(generatorOrNext?: any, error?: any, complete?: any): any;\n}\n/**\n * @name Content\n * @description\n * The Content component provides an easy to use content area with\n * some useful methods to control the scrollable area. There should\n * only be one content in a single view component. If additional scrollable\n * elements are needed, use [ionScroll](../../scroll/Scroll).\n *\n *\n * The content area can also implement pull-to-refresh with the\n * [Refresher](../../refresher/Refresher) component.\n *\n * @usage\n * ```html\n * <ion-content>\n *   Add your content here!\n * </ion-content>\n * ```\n *\n * To get a reference to the content component from a Page's logic,\n * you can use Angular's `@ViewChild` annotation:\n *\n * ```ts\n * import { Component, ViewChild } from '@angular/core';\n * import { Content } from 'ionic-angular';\n *\n * @Component({...})\n * export class MyPage{\n *   @ViewChild(Content) content: Content;\n *\n *   scrollToTop() {\n *     this.content.scrollToTop();\n *   }\n * }\n * ```\n *\n * @advanced\n *\n * ### Scroll Events\n *\n * Scroll events happen outside of Angular's Zones. This is for performance reasons. So\n * if you're trying to bind a value to any scroll event, it will need to be wrapped in\n * a `zone.run()`\n *\n * ```ts\n * import { Component, NgZone } from '@angular/core';\n * @Component({\n *   template: `\n *     <ion-header>\n *       <ion-navbar>\n *         <ion-title>{{scrollAmount}}</ion-title>\n *       </ion-navbar>\n *     </ion-header>\n *     <ion-content (ionScroll)=\"scrollHandler($event)\">\n *        <p> Some realllllllly long content </p>\n *     </ion-content>\n * `})\n * class E2EPage {\n *  public scrollAmount = 0;\n *  constructor( public zone: NgZone){}\n *  scrollHandler(event) {\n *    console.log(`ScrollEvent: ${event}`)\n *    this.zone.run(()=>{\n *      // since scrollAmount is data-binded,\n *      // the update needs to happen in zone\n *      this.scrollAmount++\n *    })\n *  }\n * }\n * ```\n *\n * This goes for any scroll event, not just `ionScroll`.\n *\n * ### Resizing the content\n *\n * If the height of `ion-header`, `ion-footer` or `ion-tabbar`\n * changes dynamically, `content.resize()` has to be called in order to update the\n * layout of `Content`.\n *\n *\n * ```ts\n * @Component({\n *   template: `\n *     <ion-header>\n *       <ion-navbar>\n *         <ion-title>Main Navbar</ion-title>\n *       </ion-navbar>\n *       <ion-toolbar *ngIf=\"showToolbar\">\n *         <ion-title>Dynamic Toolbar</ion-title>\n *       </ion-toolbar>\n *     </ion-header>\n *     <ion-content>\n *       <button ion-button (click)=\"toggleToolbar()\">Toggle Toolbar</button>\n *     </ion-content>\n * `})\n *\n * class E2EPage {\n *   @ViewChild(Content) content: Content;\n *   showToolbar: boolean = false;\n *\n *   toggleToolbar() {\n *     this.showToolbar = !this.showToolbar;\n *     this.content.resize();\n *   }\n * }\n * ```\n *\n *\n * Scroll to a specific position\n *\n * ```ts\n * import { Component, ViewChild } from '@angular/core';\n * import { Content } from 'ionic-angular';\n *\n * @Component({\n *   template: `<ion-content>\n *                <button ion-button (click)=\"scrollTo()\">Down 500px</button>\n *              </ion-content>`\n * )}\n * export class MyPage{\n *   @ViewChild(Content) content: Content;\n *\n *   scrollTo() {\n *     // set the scrollLeft to 0px, and scrollTop to 500px\n *     // the scroll duration should take 200ms\n *     this.content.scrollTo(0, 500, 200);\n *   }\n * }\n * ```\n *\n */\nexport declare class Content extends Ion implements OnDestroy, AfterViewInit, IContent {\n    private _plt;\n    private _dom;\n    _app: App;\n    _keyboard: Keyboard;\n    _zone: NgZone;\n    /** @internal */\n    _cTop: number;\n    /** @internal */\n    _cBottom: number;\n    /** @internal */\n    _pTop: number;\n    /** @internal */\n    _pRight: number;\n    /** @internal */\n    _pBottom: number;\n    /** @internal */\n    _pLeft: number;\n    /** @internal */\n    _scrollPadding: number;\n    /** @internal */\n    _hdrHeight: number;\n    /** @internal */\n    _ftrHeight: number;\n    /** @internal */\n    _tabs: Tabs;\n    /** @internal */\n    _tabbarHeight: number;\n    /** @internal */\n    _tabsPlacement: string;\n    /** @internal */\n    _tTop: number;\n    /** @internal */\n    _fTop: number;\n    /** @internal */\n    _fBottom: number;\n    /** @internal */\n    _inputPolling: boolean;\n    /** @internal */\n    _scroll: ScrollView;\n    /** @internal */\n    _scLsn: Function;\n    /** @internal */\n    _fullscreen: boolean;\n    /** @internal */\n    _hasRefresher: boolean;\n    /** @internal */\n    _footerEle: HTMLElement;\n    /** @internal */\n    _dirty: boolean;\n    /** @internal */\n    _imgs: Img[];\n    /** @internal */\n    _viewCtrlReadSub: any;\n    /** @internal */\n    _viewCtrlWriteSub: any;\n    /** @internal */\n    _scrollDownOnLoad: boolean;\n    _viewCtrl: any;\n    private _imgReqBfr;\n    private _imgRndBfr;\n    private _imgVelMax;\n    /** @hidden */\n    statusbarPadding: boolean;\n    /** @internal */\n    _fixedContent: ElementRef;\n    /** @internal */\n    _scrollContent: ElementRef;\n    /**\n     * Content height of the viewable area. This does not include content\n     * which is outside the overflow area, or content area which is under\n     * headers and footers. Read-only.\n     *\n     * @return {number}\n     */\n    readonly contentHeight: number;\n    /**\n     * Content width including content which is not visible on the screen\n     * due to overflow. Read-only.\n     *\n     * @return {number}\n     */\n    readonly contentWidth: number;\n    /**\n     * A number representing how many pixels the top of the content has been\n     * adjusted, which could be by either padding or margin. This adjustment\n     * is to account for the space needed for the header.\n     *\n     * @return {number}\n     */\n    contentTop: number;\n    /**\n     * A number representing how many pixels the bottom of the content has been\n     * adjusted, which could be by either padding or margin. This adjustment\n     * is to account for the space needed for the footer.\n     *\n     * @return {number}\n     */\n    contentBottom: number;\n    /**\n     * Content height including content which is not visible on the screen\n     * due to overflow. Read-only.\n     *\n     * @return {number}\n     */\n    readonly scrollHeight: number;\n    /**\n     * Content width including content which is not visible due to\n     * overflow. Read-only.\n     *\n     * @return {number}\n     */\n    readonly scrollWidth: number;\n    /**\n     * The distance of the content's top to its topmost visible content.\n     *\n     * @return {number}\n     */\n    /**\n     * @param {number} top\n     */\n    scrollTop: number;\n    /**\n     * The distance of the content's left to its leftmost visible content.\n     *\n     * @return {number}\n     */\n    /**\n     * @param {number} top\n     */\n    scrollLeft: number;\n    /**\n     * If the content is actively scrolling or not.\n     *\n     * @return {boolean}\n     */\n    readonly isScrolling: boolean;\n    /**\n     * The current, or last known, vertical scroll direction. Possible\n     * string values include `down` and `up`.\n     *\n     * @return {string}\n     */\n    readonly directionY: string;\n    /**\n     * The current, or last known, horizontal scroll direction. Possible\n     * string values include `right` and `left`.\n     *\n     * @return {string}\n     */\n    readonly directionX: string;\n    /**\n     * @output {ScrollEvent} Emitted when the scrolling first starts.\n     */\n    ionScrollStart: EventEmitterProxy<ScrollEvent>;\n    /**\n     * @output {ScrollEvent} Emitted on every scroll event.\n     */\n    ionScroll: EventEmitterProxy<ScrollEvent>;\n    /**\n     * @output {ScrollEvent} Emitted when scrolling ends.\n     */\n    ionScrollEnd: EventEmitterProxy<ScrollEvent>;\n    constructor(config: Config, _plt: Platform, _dom: DomController, elementRef: ElementRef, renderer: Renderer, _app: App, _keyboard: Keyboard, _zone: NgZone, viewCtrl: ViewController, navCtrl: NavController);\n    /**\n     * @hidden\n     */\n    ngAfterViewInit(): void;\n    /**\n     * @hidden\n     */\n    enableJsScroll(): void;\n    /**\n     * @hidden\n     */\n    ngOnDestroy(): void;\n    /**\n     * @hidden\n     */\n    getScrollElement(): HTMLElement;\n    /**\n     * @private\n     */\n    getFixedElement(): HTMLElement;\n    /**\n     * @hidden\n     */\n    onScrollElementTransitionEnd(callback: {\n        (ev: TransitionEvent): void;\n    }): void;\n    /**\n     * Scroll to the specified position.\n     *\n     * @param {number} x  The x-value to scroll to.\n     * @param {number} y  The y-value to scroll to.\n     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.\n     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.\n     */\n    scrollTo(x: number, y: number, duration?: number, done?: Function): Promise<any>;\n    /**\n     * Scroll to the top of the content component.\n     *\n     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.\n     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.\n     */\n    scrollToTop(duration?: number): Promise<any>;\n    /**\n     * Scroll to the bottom of the content component.\n     *\n     * @param {number} [duration]  Duration of the scroll animation in milliseconds. Defaults to `300`.\n     * @returns {Promise} Returns a promise which is resolved when the scroll has completed.\n     */\n    scrollToBottom(duration?: number): Promise<any>;\n    /**\n     * @input {boolean} If true, the content will scroll behind the headers\n     * and footers. This effect can easily be seen by setting the toolbar\n     * to transparent.\n     */\n    fullscreen: boolean;\n    /**\n     * @input {boolean} If true, the content will scroll down on load.\n     */\n    scrollDownOnLoad: boolean;\n    /**\n     * @private\n     */\n    addImg(img: Img): void;\n    /**\n     * @hidden\n     */\n    removeImg(img: Img): void;\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    setScrollElementStyle(prop: string, val: any): void;\n    /**\n     * Returns the content and scroll elements' dimensions.\n     * @returns {object} dimensions  The content and scroll elements' dimensions\n     * {number} dimensions.contentHeight  content offsetHeight\n     * {number} dimensions.contentTop  content offsetTop\n     * {number} dimensions.contentBottom  content offsetTop+offsetHeight\n     * {number} dimensions.contentWidth  content offsetWidth\n     * {number} dimensions.contentLeft  content offsetLeft\n     * {number} dimensions.contentRight  content offsetLeft + offsetWidth\n     * {number} dimensions.scrollHeight  scroll scrollHeight\n     * {number} dimensions.scrollTop  scroll scrollTop\n     * {number} dimensions.scrollBottom  scroll scrollTop + scrollHeight\n     * {number} dimensions.scrollWidth  scroll scrollWidth\n     * {number} dimensions.scrollLeft  scroll scrollLeft\n     * {number} dimensions.scrollRight  scroll scrollLeft + scrollWidth\n     */\n    getContentDimensions(): ContentDimensions;\n    /**\n     * @hidden\n     * DOM WRITE\n     * Adds padding to the bottom of the scroll element when the keyboard is open\n     * so content below the keyboard can be scrolled into view.\n     */\n    addScrollPadding(newPadding: number): void;\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    clearScrollPaddingFocusOut(): void;\n    /**\n     * Tell the content to recalculate its dimensions. This should be called\n     * after dynamically adding/removing headers, footers, or tabs.\n     */\n    resize(): void;\n    /**\n     * @hidden\n     * DOM READ\n     */\n    private _readDimensions();\n    /**\n     * @hidden\n     * DOM WRITE\n     */\n    private _writeDimensions();\n    /**\n     * @hidden\n     */\n    imgsUpdate(): void;\n    /**\n     * @hidden\n     */\n    isImgsUpdatable(): boolean;\n}\nexport declare function updateImgs(imgs: Img[], viewableTop: number, contentHeight: number, scrollDirectionY: string, requestableBuffer: number, renderableBuffer: number): void;\nexport interface ContentDimensions {\n    contentHeight: number;\n    contentTop: number;\n    contentBottom: number;\n    contentWidth: number;\n    contentLeft: number;\n    scrollHeight: number;\n    scrollTop: number;\n    scrollWidth: number;\n    scrollLeft: number;\n}\n"]}