{"version":3,"file":"refresher.d.ts","sources":["refresher.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { EventEmitter, NgZone } from '@angular/core';\nimport { Content } from '../content/content';\nimport { GestureController, GestureDelegate } from '../../gestures/gesture-controller';\nimport { Platform } from '../../platform/platform';\nimport { PointerEvents } from '../../gestures/pointer-events';\nimport { UIEventManager } from '../../gestures/ui-event-manager';\n/**\n * @name Refresher\n * @description\n * The Refresher provides pull-to-refresh functionality on a content component.\n * Place the `ion-refresher` as the first child of your `ion-content` element.\n *\n * Pages can then listen to the refresher's various output events. The\n * `refresh` output event is fired when the user has pulled down far\n * enough to kick off the refreshing process. Once the async operation\n * has completed and the refreshing should end, call `complete()`.\n *\n * Note: Do not wrap the `ion-refresher` in a `*ngIf`. It will not render\n * properly this way. Please use the `enabled` property instead to\n * display or hide the refresher.\n *\n * @usage\n * ```html\n * <ion-content>\n *\n *   <ion-refresher (ionRefresh)=\"doRefresh($event)\">\n *     <ion-refresher-content></ion-refresher-content>\n *   </ion-refresher>\n *\n * </ion-content>\n * ```\n *\n * ```ts\n * @Component({...})\n * export class NewsFeedPage {\n *\n *   doRefresh(refresher) {\n *     console.log('Begin async operation', refresher);\n *\n *     setTimeout(() => {\n *       console.log('Async operation has ended');\n *       refresher.complete();\n *     }, 2000);\n *   }\n *\n * }\n * ```\n *\n *\n * ## Refresher Content\n *\n * By default, Ionic provides the pulling icon and refreshing spinner that\n * looks best for the platform the user is on. However, you can change the\n * default icon and spinner, along with adding text for each state by\n * adding properties to the child `ion-refresher-content` component.\n *\n *  ```html\n *  <ion-content>\n *\n *    <ion-refresher (ionRefresh)=\"doRefresh($event)\">\n *      <ion-refresher-content\n *        pullingIcon=\"arrow-dropdown\"\n *        pullingText=\"Pull to refresh\"\n *        refreshingSpinner=\"circles\"\n *        refreshingText=\"Refreshing...\">\n *      </ion-refresher-content>\n *    </ion-refresher>\n *\n *  </ion-content>\n *  ```\n *\n *\n * ## Further Customizing Refresher Content\n *\n * The `ion-refresher` component holds the refresh logic.\n * It requires a child component in order to display the content.\n * Ionic uses `ion-refresher-content` by default. This component\n * displays the refresher and changes the look depending\n * on the refresher's state. Separating these components\n * allows developers to create their own refresher content\n * components. You could replace our default content with\n * custom SVG or CSS animations.\n *\n * @demo /docs/demos/src/refresher/\n *\n */\nexport declare class Refresher {\n    private _plt;\n    private _content;\n    private _zone;\n    _appliedStyles: boolean;\n    _didStart: boolean;\n    _lastCheck: number;\n    _isEnabled: boolean;\n    _gesture: GestureDelegate;\n    _events: UIEventManager;\n    _pointerEvents: PointerEvents;\n    _top: string;\n    /**\n     * The current state which the refresher is in. The refresher's states include:\n     *\n     * - `inactive` - The refresher is not being pulled down or refreshing and is currently hidden.\n     * - `pulling` - The user is actively pulling down the refresher, but has not reached the point yet that if the user lets go, it'll refresh.\n     * - `cancelling` - The user pulled down the refresher and let go, but did not pull down far enough to kick off the `refreshing` state. After letting go, the refresher is in the `cancelling` state while it is closing, and will go back to the `inactive` state once closed.\n     * - `ready` - The user has pulled down the refresher far enough that if they let go, it'll begin the `refreshing` state.\n     * - `refreshing` - The refresher is actively waiting on the async operation to end. Once the refresh handler calls `complete()` it will begin the `completing` state.\n     * - `completing` - The `refreshing` state has finished and the refresher is in the process of closing itself. Once closed, the refresher will go back to the `inactive` state.\n     */\n    state: string;\n    /**\n     * The Y coordinate of where the user started to the pull down the content.\n     */\n    startY: number;\n    /**\n     * The current touch or mouse event's Y coordinate.\n     */\n    currentY: number;\n    /**\n     * The distance between the start of the pull and the current touch or\n     * mouse event's Y coordinate.\n     */\n    deltaY: number;\n    /**\n     * A number representing how far down the user has pulled.\n     * The number `0` represents the user hasn't pulled down at all. The\n     * number `1`, and anything greater than `1`, represents that the user\n     * has pulled far enough down that when they let go then the refresh will\n     * happen. If they let go and the number is less than `1`, then the\n     * refresh will not happen, and the content will return to it's original\n     * position.\n     */\n    progress: number;\n    /**\n     * @input {number} The min distance the user must pull down until the\n     * refresher can go into the `refreshing` state. Default is `60`.\n     */\n    pullMin: number;\n    /**\n     * @input {number} The maximum distance of the pull until the refresher\n     * will automatically go into the `refreshing` state. By default, the pull\n     * maximum will be the result of `pullMin + 60`.\n     */\n    pullMax: number;\n    /**\n     * @input {number} How many milliseconds it takes to close the refresher. Default is `280`.\n     */\n    closeDuration: number;\n    /**\n     * @input {number} How many milliseconds it takes the refresher to to snap back to the `refreshing` state. Default is `280`.\n     */\n    snapbackDuration: number;\n    /**\n     * @input {boolean} If the refresher is enabled or not. This should be used in place of an `ngIf`. Default is `true`.\n     */\n    enabled: boolean;\n    /**\n     * @output {event} Emitted when the user lets go and has pulled down\n     * far enough, which would be farther than the `pullMin`, then your refresh hander if\n     * fired and the state is updated to `refreshing`. From within your refresh handler,\n     * you must call the `complete()` method when your async operation has completed.\n     */\n    ionRefresh: EventEmitter<Refresher>;\n    /**\n     * @output {event} Emitted while the user is pulling down the content and exposing the refresher.\n     */\n    ionPull: EventEmitter<Refresher>;\n    /**\n     * @output {event} Emitted when the user begins to start pulling down.\n     */\n    ionStart: EventEmitter<Refresher>;\n    constructor(_plt: Platform, _content: Content, _zone: NgZone, gestureCtrl: GestureController);\n    _onStart(ev: TouchEvent): any;\n    _onMove(ev: TouchEvent): 1 | 2 | 3 | 0 | 5 | 6 | 8 | 7;\n    _onMoveInZone(): 2 | 3 | 4;\n    _onEnd(): void;\n    _beginRefresh(): void;\n    /**\n     * Call `complete()` when your async operation has completed.\n     * For example, the `refreshing` state is while the app is performing\n     * an asynchronous operation, such as receiving more data from an\n     * AJAX request. Once the data has been received, you then call this\n     * method to signify that the refreshing has completed and to close\n     * the refresher. This method also changes the refresher's state from\n     * `refreshing` to `completing`.\n     */\n    complete(): void;\n    /**\n     * Changes the refresher's state from `refreshing` to `cancelling`.\n     */\n    cancel(): void;\n    _close(state: string, delay: string): void;\n    _setCss(y: number, duration: string, overflowVisible: boolean, delay: string): void;\n    _setListeners(shouldListen: boolean): void;\n    /**\n     * @hidden\n     */\n    ngOnInit(): void;\n    /**\n     * @hidden\n     */\n    ngOnDestroy(): void;\n}\n"]}