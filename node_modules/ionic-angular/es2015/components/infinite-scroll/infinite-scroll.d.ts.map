{"version":3,"file":"infinite-scroll.d.ts","sources":["infinite-scroll.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { ElementRef, EventEmitter, NgZone } from '@angular/core';\nimport { Content, ScrollEvent } from '../content/content';\nimport { DomController } from '../../platform/dom-controller';\n/**\n * @name InfiniteScroll\n * @description\n * The Infinite Scroll allows you to perform an action when the user\n * scrolls a specified distance from the bottom or top of the page.\n *\n * The expression assigned to the `infinite` event is called when\n * the user scrolls to the specified distance. When this expression\n * has finished its tasks, it should call the `complete()` method\n * on the infinite scroll instance.\n *\n * @usage\n * ```html\n * <ion-content>\n *\n *  <ion-list>\n *    <ion-item *ngFor=\"let i of items\">{% raw %}{{i}}{% endraw %}</ion-item>\n *  </ion-list>\n *\n *  <ion-infinite-scroll (ionInfinite)=\"doInfinite($event)\">\n *    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n *  </ion-infinite-scroll>\n *\n * </ion-content>\n * ```\n *\n * ```ts\n * @Component({...})\n * export class NewsFeedPage {\n *   items = [];\n *\n *   constructor() {\n *     for (let i = 0; i < 30; i++) {\n *       this.items.push( this.items.length );\n *     }\n *   }\n *\n *   doInfinite(infiniteScroll) {\n *     console.log('Begin async operation');\n *\n *     setTimeout(() => {\n *       for (let i = 0; i < 30; i++) {\n *         this.items.push( this.items.length );\n *       }\n *\n *       console.log('Async operation has ended');\n *       infiniteScroll.complete();\n *     }, 500);\n *   }\n *\n * }\n * ```\n *\n * ## `waitFor` method of InfiniteScroll\n *\n * In case if your async operation returns promise you can utilize\n * `waitFor` method inside your template.\n *\n * ```html\n * <ion-content>\n *\n *  <ion-list>\n *    <ion-item *ngFor=\"let item of items\">{{item}}</ion-item>\n *  </ion-list>\n *\n *  <ion-infinite-scroll (ionInfinite)=\"$event.waitFor(doInfinite())\">\n *    <ion-infinite-scroll-content></ion-infinite-scroll-content>\n *  </ion-infinite-scroll>\n *\n * </ion-content>\n * ```\n *\n * ```ts\n * @Component({...})\n * export class NewsFeedPage {\n *   items = [];\n *\n *   constructor() {\n *     for (var i = 0; i < 30; i++) {\n *       this.items.push( this.items.length );\n *     }\n *   }\n *\n *   doInfinite(): Promise<any> {\n *     console.log('Begin async operation');\n *\n *     return new Promise((resolve) => {\n *       setTimeout(() => {\n *         for (var i = 0; i < 30; i++) {\n *           this.items.push( this.items.length );\n *         }\n *\n *         console.log('Async operation has ended');\n *         resolve();\n *       }, 500);\n *     })\n *   }\n * }\n * ```\n *\n * ## Infinite Scroll Content\n *\n * By default, Ionic uses the infinite scroll spinner that looks\n * best for the platform the user is on. However, you can change the\n * default spinner or add text by adding properties to the\n * `ion-infinite-scroll-content` component.\n *\n *  ```html\n *  <ion-content>\n *\n *    <ion-infinite-scroll (ionInfinite)=\"doInfinite($event)\">\n *      <ion-infinite-scroll-content\n *        loadingSpinner=\"bubbles\"\n *        loadingText=\"Loading more data...\">\n *      </ion-infinite-scroll-content>\n *    </ion-infinite-scroll>\n *\n *  </ion-content>\n *  ```\n *\n *\n * ## Further Customizing Infinite Scroll Content\n *\n * The `ion-infinite-scroll` component holds the infinite scroll logic.\n * It requires a child component in order to display the content.\n * Ionic uses `ion-infinite-scroll-content` by default. This component\n * displays the infinite scroll and changes the look depending\n * on the infinite scroll's state. Separating these components allows\n * developers to create their own infinite scroll content components.\n * You could replace our default content with custom SVG or CSS animations.\n *\n * @demo /docs/demos/src/infinite-scroll/\n *\n */\nexport declare class InfiniteScroll {\n    private _content;\n    private _zone;\n    private _elementRef;\n    private _dom;\n    _lastCheck: number;\n    _highestY: number;\n    _scLsn: any;\n    _thr: string;\n    _thrPx: number;\n    _thrPc: number;\n    _position: string;\n    _init: boolean;\n    /**\n     * @internal\n     */\n    state: string;\n    /**\n     * @input {string} The threshold distance from the bottom\n     * of the content to call the `infinite` output event when scrolled.\n     * The threshold value can be either a percent, or\n     * in pixels. For example, use the value of `10%` for the `infinite`\n     * output event to get called when the user has scrolled 10%\n     * from the bottom of the page. Use the value `100px` when the\n     * scroll is within 100 pixels from the bottom of the page.\n     * Default is `15%`.\n     */\n    threshold: string;\n    /**\n     * @input {boolean} If true, Whether or not the infinite scroll should be\n     * enabled or not. Setting to `false` will remove scroll event listeners\n     * and hide the display.\n     */\n    enabled: boolean;\n    /**\n     * @input {string} The position of the infinite scroll element.\n     * The value can be either `top` or `bottom`.\n     * Default is `bottom`.\n     */\n    position: string;\n    /**\n     * @output {event} Emitted when the scroll reaches\n     * the threshold distance. From within your infinite handler,\n     * you must call the infinite scroll's `complete()` method when\n     * your async operation has completed.\n     */\n    ionInfinite: EventEmitter<InfiniteScroll>;\n    constructor(_content: Content, _zone: NgZone, _elementRef: ElementRef, _dom: DomController);\n    _onScroll(ev: ScrollEvent): 1 | 2 | 3 | 5 | 6;\n    /**\n     * Call `complete()` within the `infinite` output event handler when\n     * your async operation has completed. For example, the `loading`\n     * state is while the app is performing an asynchronous operation,\n     * such as receiving more data from an AJAX request to add more items\n     * to a data list. Once the data has been received and UI updated, you\n     * then call this method to signify that the loading has completed.\n     * This method will change the infinite scroll's state from `loading`\n     * to `enabled`.\n     */\n    complete(): void;\n    /**\n    * Pass a promise inside `waitFor()` within the `infinite` output event handler in order to\n    * change state of infiniteScroll to \"complete\"\n    */\n    waitFor(action: Promise<any>): void;\n    /**\n     * Call `enable(false)` to disable the infinite scroll from actively\n     * trying to receive new data while scrolling. This method is useful\n     * when it is known that there is no more data that can be added, and\n     * the infinite scroll is no longer needed.\n     * @param {boolean} shouldEnable  If the infinite scroll should be\n     * enabled or not. Setting to `false` will remove scroll event listeners\n     * and hide the display.\n     */\n    enable(shouldEnable: boolean): void;\n    /**\n     * @hidden\n     */\n    _setListeners(shouldListen: boolean): void;\n    /**\n     * @hidden\n     */\n    ngAfterContentInit(): void;\n    /**\n     * @hidden\n     */\n    ngOnDestroy(): void;\n}\n"]}